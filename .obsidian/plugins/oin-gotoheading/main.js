/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => GotoHeadingPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// src/heading_modal.ts
var import_obsidian = require("obsidian");
var HeadingModalLimit = 5e4;
var HeadingModal = class extends import_obsidian.FuzzySuggestModal {
  constructor(app) {
    super(app);
    __publicField(this, "items", []);
    __publicField(this, "defaultItemIndex", -1);
    __publicField(this, "onChoose");
    __publicField(this, "settings");
    this.limit = HeadingModalLimit;
  }
  onOpen() {
    super.onOpen();
    if (this.defaultItemIndex >= 0 && this.defaultItemIndex < this.items.length) {
      let chooser = this["chooser"];
      if (this.defaultItemIndex <= this.items.length / 2) {
        for (let i = 0; i < this.defaultItemIndex; i++) {
          chooser["moveDown"](new KeyboardEvent("keydown", { key: "ArrowDown" }));
        }
      } else {
        for (let i = this.items.length - 1; i >= this.defaultItemIndex; --i) {
          chooser["moveUp"](new KeyboardEvent("keydown", { key: "ArrowUp" }));
        }
      }
    }
  }
  getItems() {
    return this.items;
  }
  getItemText(item) {
    return item.text;
  }
  onChooseItem(item, evt) {
    var _a;
    (_a = this.onChoose) == null ? void 0 : _a.call(this, item);
  }
  renderSuggestion(item, el) {
    el.classList.add("join-gotoheading-headingmodal-suggestion");
    if (this.settings.highlightCurrentHeading && this.defaultItemIndex >= 0 && this.items.indexOf(item.item) == this.defaultItemIndex) {
      el.classList.add("join-gotoheading-headingmodal-suggestion-default");
    }
    switch (item.item.type) {
      case 0 /* File */:
        return this.renderFileSuggestion(item, el);
      case 1 /* Heading */:
        return this.renderHeadingSuggestion(item, el);
    }
  }
  renderFileSuggestion(item, el) {
    const s = item.item;
    const isSearching = this.inputEl.value.length > 0;
    el.classList.add("join-gotoheading-headingmodal-suggestion");
    el.classList.add("join-gotoheading-headingmodal-suggestion-file");
    if (isSearching) {
      el.classList.add("join-gotoheading-headingmodal-suggestion-searching");
    }
    const titleEl = el.createSpan({ cls: "title" });
    super.renderSuggestion(item, titleEl);
    let smallEl = el.createEl("small", { cls: "icon" });
    (0, import_obsidian.setIcon)(smallEl, "file-text");
  }
  renderHeadingSuggestion(item, el) {
    const s = item.item;
    const isSearching = this.inputEl.value.length > 0;
    const level = s.level;
    const iconName = level >= 1 && level <= 6 ? `heading-${level}` : "heading";
    if (isSearching) {
      (0, import_obsidian.setIcon)(el, iconName);
    } else {
      el.createDiv({
        text: "#".repeat(level),
        cls: "join-gotoheading-headingmodal-suggestion-spacer"
      });
    }
    const titleEl = el.createSpan({ cls: "title" });
    super.renderSuggestion(item, titleEl);
    if (isSearching) {
      el.createEl("small", { text: this.parentHeadingString(s), cls: "path" });
    } else {
      let smallEl = el.createEl("small", { cls: "icon" });
      (0, import_obsidian.setIcon)(smallEl, iconName);
    }
  }
  parentHeadingString(item) {
    let string = "";
    if (item.file) {
      string = item.file.text;
    }
    while (item) {
      const parentIndex = this.items.findLastIndex(
        (heading) => heading.type == 1 /* Heading */ && heading.line < item.line && heading.level < item.level
      );
      if (parentIndex < 0)
        break;
      const parent = this.items[parentIndex];
      if (parent.type != 1 /* Heading */)
        break;
      if (string.length > 0) {
        string = `${parent.heading} > ${string}`;
      } else {
        string = parent.heading;
      }
      item = parent;
    }
    return string;
  }
};

// src/settings_tab.ts
var import_obsidian2 = require("obsidian");

// src/settings.ts
var FolderSortMethod = /* @__PURE__ */ ((FolderSortMethod2) => {
  FolderSortMethod2[FolderSortMethod2["ByNameAscending"] = 0] = "ByNameAscending";
  FolderSortMethod2[FolderSortMethod2["ByNameDescending"] = 1] = "ByNameDescending";
  FolderSortMethod2[FolderSortMethod2["ByModificationDateDescending"] = 2] = "ByModificationDateDescending";
  FolderSortMethod2[FolderSortMethod2["ByModificationDateAscending"] = 3] = "ByModificationDateAscending";
  FolderSortMethod2[FolderSortMethod2["ByCreationDateDescending"] = 4] = "ByCreationDateDescending";
  FolderSortMethod2[FolderSortMethod2["ByCreationDateAscending"] = 5] = "ByCreationDateAscending";
  return FolderSortMethod2;
})(FolderSortMethod || {});
var FolderSortMethodIdentifiers = Object.keys(FolderSortMethod).filter((x) => isNaN(Number(x)));
var DEFAULT_SETTINGS = {
  highlightCurrentHeading: true,
  fileSortOrder: FolderSortMethod[0 /* ByNameAscending */],
  includeDocumentBoundaries: false
};

// src/settings_tab.ts
var FolderSortMethodName = {
  [0 /* ByNameAscending */]: "File name (A to Z)",
  [1 /* ByNameDescending */]: "File name (Z to A)",
  [2 /* ByModificationDateDescending */]: "Modified time (new to old)",
  [3 /* ByModificationDateAscending */]: "Modified time (old to new)",
  [4 /* ByCreationDateDescending */]: "Creation date (new to old)",
  [5 /* ByCreationDateAscending */]: "Creation date (old to new)"
};
var GotoHeadingSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    __publicField(this, "plugin");
    this.plugin = plugin;
  }
  display() {
    let { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Previous/Next Settings" });
    new import_obsidian2.Setting(containerEl).setName("Include first/last line").setDesc("Go to the last line after the last heading, and the first line before the first heading").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.includeDocumentBoundaries).onChange(async (value) => {
        this.plugin.settings.includeDocumentBoundaries = toggle.getValue();
        await this.plugin.saveSettings();
      });
    });
    containerEl.createEl("h2", { text: "Switcher Settings" });
    new import_obsidian2.Setting(containerEl).setName("Highlight current heading").setDesc("Emphasize the current heading in the switcher").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.highlightCurrentHeading).onChange(async (value) => {
        this.plugin.settings.highlightCurrentHeading = toggle.getValue();
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian2.Setting(containerEl).setName("File sort order").setDesc("How to sort files in the 'In folder' switcher").addDropdown((dropdown) => {
      const ids = Object.keys(FolderSortMethodName).forEach((key, index) => {
        dropdown.addOption(FolderSortMethod[index], FolderSortMethodName[index]);
      });
      dropdown.setValue(this.plugin.settings.fileSortOrder).onChange(async (value) => {
        if (!FolderSortMethodIdentifiers.contains(value))
          return;
        this.plugin.settings.fileSortOrder = value;
        await this.plugin.saveSettings();
      });
    });
  }
};

// src/utility.ts
var import_obsidian3 = require("obsidian");
function headingsForActiveFile(app) {
  const activeFile = app.workspace.getActiveFile();
  if (!activeFile)
    return void 0;
  const fileCache = app.metadataCache.getFileCache(activeFile);
  return fileCache == null ? void 0 : fileCache.headings;
}
function headingsForFolder(app, folder, childrenFn = (x) => x) {
  const files = folder.children.filter((x) => x instanceof import_obsidian3.TFile);
  const subfolders = folder.children.filter((x) => x instanceof import_obsidian3.TFolder);
  return [
    ...subfolders.map((x) => headingsForFolder(app, x, childrenFn)).reduce((a, b) => a.concat(b), []),
    ...childrenFn(files).map((x) => {
      var _a, _b;
      return {
        file: x,
        headings: (_b = (_a = app.metadataCache.getFileCache(x)) == null ? void 0 : _a.headings) != null ? _b : []
      };
    })
  ];
}
function headingsForActiveFolder(app, childrenFn = (x) => x) {
  const activeFile = app.workspace.getActiveFile();
  if (!activeFile)
    return [];
  const activeFolder = activeFile.parent;
  if (!activeFolder)
    return [];
  return headingsForFolder(app, activeFolder, childrenFn);
}
function fileNameWithoutPathOrExtension(path) {
  const fileName = path.split("/").pop();
  if (!fileName)
    return path;
  return fileName.split(".").slice(0, -1).join(".");
}
function goAndScrollToLine(editor, line) {
  var _a;
  editor.setCursor(line);
  const position = editor.getCursor();
  var range = (_a = editor.wordAt(position)) != null ? _a : { from: position, to: position };
  editor.scrollIntoView(range, true);
}

// src/main.ts
var FolderSortMethodFn = {
  [0 /* ByNameAscending */]: (children) => children.sort((a, b) => a.name.localeCompare(b.name)),
  [1 /* ByNameDescending */]: (children) => children.sort((a, b) => b.name.localeCompare(a.name)),
  [2 /* ByModificationDateDescending */]: (children) => children.sort((a, b) => b.stat.mtime - a.stat.mtime),
  [3 /* ByModificationDateAscending */]: (children) => children.sort((a, b) => a.stat.mtime - b.stat.mtime),
  [4 /* ByCreationDateDescending */]: (children) => children.sort((a, b) => b.stat.ctime - a.stat.ctime),
  [5 /* ByCreationDateAscending */]: (children) => children.sort((a, b) => a.stat.ctime - b.stat.ctime)
};
var GotoHeadingPlugin = class extends import_obsidian4.Plugin {
  constructor() {
    super(...arguments);
    __publicField(this, "settings");
  }
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new GotoHeadingSettingTab(this.app, this));
    this.addCommand({
      id: "gotoheading-previous",
      name: "Previous heading",
      editorCallback: (editor, view) => {
        this.goToRelativeHeading(editor, view, -1);
      }
    });
    this.addCommand({
      id: "gotoheading-next",
      name: "Next heading",
      editorCallback: (editor, view) => {
        this.goToRelativeHeading(editor, view, 1);
      }
    });
    this.addCommand({
      id: "gotoheading-switcher",
      name: "Open switcher",
      editorCallback: (editor, view) => {
        this.openHeadingSwitcher(editor, view);
      }
    });
    this.addCommand({
      id: "gotoheading-switcher-folder",
      name: "In folder: Open switcher",
      editorCallback: (editor, view) => {
        this.openHeadingSwitcherInFolder(editor, view);
      }
    });
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  goToRelativeHeading(editor, view, offset) {
    if (offset == 0)
      return;
    const headings = headingsForActiveFile(this.app);
    if (!(headings == null ? void 0 : headings.length)) {
      if (this.settings.includeDocumentBoundaries) {
        if (offset < 0) {
          goAndScrollToLine(editor, 0);
        } else if (offset > 0) {
          goAndScrollToLine(editor, editor.lastLine());
        }
      }
      return;
    }
    const line = editor.getCursor().line;
    var nearestHeadingIndex = headings.findLastIndex((heading2) => heading2.position.start.line <= line);
    if (nearestHeadingIndex >= 0) {
      const nearestHeading = headings[nearestHeadingIndex];
      if (offset == -1 && line > nearestHeading.position.end.line) {
        offset = 0;
      }
    }
    let idx = nearestHeadingIndex + offset;
    if (idx >= headings.length) {
      if (this.settings.includeDocumentBoundaries) {
        goAndScrollToLine(editor, editor.lastLine());
      }
      return;
    }
    if (idx < 0) {
      if (this.settings.includeDocumentBoundaries) {
        goAndScrollToLine(editor, 0);
      }
      return;
    }
    const heading = headings[idx];
    goAndScrollToLine(editor, heading.position.start.line);
  }
  openHeadingSwitcher(editor, view) {
    const headings = headingsForActiveFile(this.app);
    if (!(headings == null ? void 0 : headings.length))
      return;
    let modal = new HeadingModal(this.app);
    modal.setInstructions([
      { command: "\u2191\u2193", purpose: "to navigate" },
      { command: "\u21B5", purpose: "to jump to heading" },
      { command: "esc", purpose: "to dismiss" }
    ]);
    modal.setPlaceholder("Go to heading...");
    modal.items = headings.map((heading) => ({
      type: 1 /* Heading */,
      text: heading.heading,
      heading: heading.heading,
      level: heading.level,
      line: heading.position.start.line
    }));
    modal.onChoose = (item) => {
      goAndScrollToLine(editor, item.line);
      modal.close();
    };
    const line = editor.getCursor().line;
    modal.defaultItemIndex = headings.findLastIndex((heading) => heading.position.start.line <= line);
    modal.settings = this.settings;
    modal.open();
  }
  openHeadingSwitcherInFolder(editor, view) {
    var _a;
    let sortMethodFn = (x) => x;
    const sortMethodId = this.settings.fileSortOrder;
    if (FolderSortMethodIdentifiers.contains(sortMethodId)) {
      sortMethodFn = FolderSortMethodFn[FolderSortMethod[sortMethodId]];
    }
    const headings = headingsForActiveFolder(this.app, sortMethodFn);
    if (!headings.length)
      return;
    let modal = new HeadingModal(this.app);
    modal.setInstructions([
      { command: "\u2191\u2193", purpose: "to navigate" },
      { command: "\u21B5", purpose: "to jump to file/heading" },
      { command: "esc", purpose: "to dismiss" }
    ]);
    modal.setPlaceholder("Go to file/heading...");
    let items = [];
    for (const heading of headings) {
      const f = {
        type: 0 /* File */,
        text: fileNameWithoutPathOrExtension(heading.file.path),
        path: heading.file.path
      };
      items.push(f, ...heading.headings.map((heading2) => ({
        type: 1 /* Heading */,
        text: heading2.heading,
        heading: heading2.heading,
        level: heading2.level,
        line: heading2.position.start.line,
        file: f
      })));
    }
    modal.items = items;
    modal.onChoose = async (item) => {
      switch (item.type) {
        case 0 /* File */: {
          const s = item;
          await this.app.workspace.openLinkText(s.path, "", false);
          break;
        }
        case 1 /* Heading */: {
          const s = item;
          if (s.file) {
            await this.app.workspace.openLinkText(s.file.path, "", false);
          }
          goAndScrollToLine(editor, s.line);
          break;
        }
      }
      modal.close();
    };
    const line = editor.getCursor().line;
    const activeFilePath = (_a = this.app.workspace.getActiveFile()) == null ? void 0 : _a.path;
    let idx = items.findLastIndex(
      (item) => {
        var _a2;
        return item.type == 1 /* Heading */ && ((_a2 = item.file) == null ? void 0 : _a2.path) === activeFilePath && item.line <= line;
      }
    );
    if (idx < 0) {
      idx = items.findIndex((item) => item.type == 0 /* File */ && item.path === activeFilePath);
    }
    modal.defaultItemIndex = idx;
    modal.settings = this.settings;
    modal.open();
  }
};
