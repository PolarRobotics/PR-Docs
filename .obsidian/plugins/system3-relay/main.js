/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all2) => {
  for (var name in all2)
    __defProp(target, name, { get: all2[name], enumerable: true });
};
var __copyProps = (to, from3, except, desc) => {
  if (from3 && typeof from3 === "object" || typeof from3 === "function") {
    for (let key of __getOwnPropNames(from3))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from3[key], enumerable: !(desc = __getOwnPropDesc(from3, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// node_modules/path-browserify/index.js
var require_path_browserify = __commonJS({
  "node_modules/path-browserify/index.js"(exports, module2) {
    "use strict";
    function assertPath(path2) {
      if (typeof path2 !== "string") {
        throw new TypeError("Path must be a string. Received " + JSON.stringify(path2));
      }
    }
    function normalizeStringPosix(path2, allowAboveRoot) {
      var res = "";
      var lastSegmentLength = 0;
      var lastSlash = -1;
      var dots = 0;
      var code;
      for (var i2 = 0; i2 <= path2.length; ++i2) {
        if (i2 < path2.length)
          code = path2.charCodeAt(i2);
        else if (code === 47)
          break;
        else
          code = 47;
        if (code === 47) {
          if (lastSlash === i2 - 1 || dots === 1) {
          } else if (lastSlash !== i2 - 1 && dots === 2) {
            if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
              if (res.length > 2) {
                var lastSlashIndex = res.lastIndexOf("/");
                if (lastSlashIndex !== res.length - 1) {
                  if (lastSlashIndex === -1) {
                    res = "";
                    lastSegmentLength = 0;
                  } else {
                    res = res.slice(0, lastSlashIndex);
                    lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                  }
                  lastSlash = i2;
                  dots = 0;
                  continue;
                }
              } else if (res.length === 2 || res.length === 1) {
                res = "";
                lastSegmentLength = 0;
                lastSlash = i2;
                dots = 0;
                continue;
              }
            }
            if (allowAboveRoot) {
              if (res.length > 0)
                res += "/..";
              else
                res = "..";
              lastSegmentLength = 2;
            }
          } else {
            if (res.length > 0)
              res += "/" + path2.slice(lastSlash + 1, i2);
            else
              res = path2.slice(lastSlash + 1, i2);
            lastSegmentLength = i2 - lastSlash - 1;
          }
          lastSlash = i2;
          dots = 0;
        } else if (code === 46 && dots !== -1) {
          ++dots;
        } else {
          dots = -1;
        }
      }
      return res;
    }
    function _format(sep2, pathObject) {
      var dir = pathObject.dir || pathObject.root;
      var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
      if (!dir) {
        return base;
      }
      if (dir === pathObject.root) {
        return dir + base;
      }
      return dir + sep2 + base;
    }
    var posix = {
      // path.resolve([from ...], to)
      resolve: function resolve() {
        var resolvedPath = "";
        var resolvedAbsolute = false;
        var cwd;
        for (var i2 = arguments.length - 1; i2 >= -1 && !resolvedAbsolute; i2--) {
          var path2;
          if (i2 >= 0)
            path2 = arguments[i2];
          else {
            if (cwd === void 0)
              cwd = process.cwd();
            path2 = cwd;
          }
          assertPath(path2);
          if (path2.length === 0) {
            continue;
          }
          resolvedPath = path2 + "/" + resolvedPath;
          resolvedAbsolute = path2.charCodeAt(0) === 47;
        }
        resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
        if (resolvedAbsolute) {
          if (resolvedPath.length > 0)
            return "/" + resolvedPath;
          else
            return "/";
        } else if (resolvedPath.length > 0) {
          return resolvedPath;
        } else {
          return ".";
        }
      },
      normalize: function normalize(path2) {
        assertPath(path2);
        if (path2.length === 0)
          return ".";
        var isAbsolute = path2.charCodeAt(0) === 47;
        var trailingSeparator = path2.charCodeAt(path2.length - 1) === 47;
        path2 = normalizeStringPosix(path2, !isAbsolute);
        if (path2.length === 0 && !isAbsolute)
          path2 = ".";
        if (path2.length > 0 && trailingSeparator)
          path2 += "/";
        if (isAbsolute)
          return "/" + path2;
        return path2;
      },
      isAbsolute: function isAbsolute(path2) {
        assertPath(path2);
        return path2.length > 0 && path2.charCodeAt(0) === 47;
      },
      join: function join3() {
        if (arguments.length === 0)
          return ".";
        var joined;
        for (var i2 = 0; i2 < arguments.length; ++i2) {
          var arg = arguments[i2];
          assertPath(arg);
          if (arg.length > 0) {
            if (joined === void 0)
              joined = arg;
            else
              joined += "/" + arg;
          }
        }
        if (joined === void 0)
          return ".";
        return posix.normalize(joined);
      },
      relative: function relative(from3, to) {
        assertPath(from3);
        assertPath(to);
        if (from3 === to)
          return "";
        from3 = posix.resolve(from3);
        to = posix.resolve(to);
        if (from3 === to)
          return "";
        var fromStart = 1;
        for (; fromStart < from3.length; ++fromStart) {
          if (from3.charCodeAt(fromStart) !== 47)
            break;
        }
        var fromEnd = from3.length;
        var fromLen = fromEnd - fromStart;
        var toStart = 1;
        for (; toStart < to.length; ++toStart) {
          if (to.charCodeAt(toStart) !== 47)
            break;
        }
        var toEnd = to.length;
        var toLen = toEnd - toStart;
        var length4 = fromLen < toLen ? fromLen : toLen;
        var lastCommonSep = -1;
        var i2 = 0;
        for (; i2 <= length4; ++i2) {
          if (i2 === length4) {
            if (toLen > length4) {
              if (to.charCodeAt(toStart + i2) === 47) {
                return to.slice(toStart + i2 + 1);
              } else if (i2 === 0) {
                return to.slice(toStart + i2);
              }
            } else if (fromLen > length4) {
              if (from3.charCodeAt(fromStart + i2) === 47) {
                lastCommonSep = i2;
              } else if (i2 === 0) {
                lastCommonSep = 0;
              }
            }
            break;
          }
          var fromCode = from3.charCodeAt(fromStart + i2);
          var toCode = to.charCodeAt(toStart + i2);
          if (fromCode !== toCode)
            break;
          else if (fromCode === 47)
            lastCommonSep = i2;
        }
        var out = "";
        for (i2 = fromStart + lastCommonSep + 1; i2 <= fromEnd; ++i2) {
          if (i2 === fromEnd || from3.charCodeAt(i2) === 47) {
            if (out.length === 0)
              out += "..";
            else
              out += "/..";
          }
        }
        if (out.length > 0)
          return out + to.slice(toStart + lastCommonSep);
        else {
          toStart += lastCommonSep;
          if (to.charCodeAt(toStart) === 47)
            ++toStart;
          return to.slice(toStart);
        }
      },
      _makeLong: function _makeLong(path2) {
        return path2;
      },
      dirname: function dirname2(path2) {
        assertPath(path2);
        if (path2.length === 0)
          return ".";
        var code = path2.charCodeAt(0);
        var hasRoot2 = code === 47;
        var end = -1;
        var matchedSlash = true;
        for (var i2 = path2.length - 1; i2 >= 1; --i2) {
          code = path2.charCodeAt(i2);
          if (code === 47) {
            if (!matchedSlash) {
              end = i2;
              break;
            }
          } else {
            matchedSlash = false;
          }
        }
        if (end === -1)
          return hasRoot2 ? "/" : ".";
        if (hasRoot2 && end === 1)
          return "//";
        return path2.slice(0, end);
      },
      basename: function basename(path2, ext) {
        if (ext !== void 0 && typeof ext !== "string")
          throw new TypeError('"ext" argument must be a string');
        assertPath(path2);
        var start = 0;
        var end = -1;
        var matchedSlash = true;
        var i2;
        if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {
          if (ext.length === path2.length && ext === path2)
            return "";
          var extIdx = ext.length - 1;
          var firstNonSlashEnd = -1;
          for (i2 = path2.length - 1; i2 >= 0; --i2) {
            var code = path2.charCodeAt(i2);
            if (code === 47) {
              if (!matchedSlash) {
                start = i2 + 1;
                break;
              }
            } else {
              if (firstNonSlashEnd === -1) {
                matchedSlash = false;
                firstNonSlashEnd = i2 + 1;
              }
              if (extIdx >= 0) {
                if (code === ext.charCodeAt(extIdx)) {
                  if (--extIdx === -1) {
                    end = i2;
                  }
                } else {
                  extIdx = -1;
                  end = firstNonSlashEnd;
                }
              }
            }
          }
          if (start === end)
            end = firstNonSlashEnd;
          else if (end === -1)
            end = path2.length;
          return path2.slice(start, end);
        } else {
          for (i2 = path2.length - 1; i2 >= 0; --i2) {
            if (path2.charCodeAt(i2) === 47) {
              if (!matchedSlash) {
                start = i2 + 1;
                break;
              }
            } else if (end === -1) {
              matchedSlash = false;
              end = i2 + 1;
            }
          }
          if (end === -1)
            return "";
          return path2.slice(start, end);
        }
      },
      extname: function extname(path2) {
        assertPath(path2);
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var preDotState = 0;
        for (var i2 = path2.length - 1; i2 >= 0; --i2) {
          var code = path2.charCodeAt(i2);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i2 + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i2 + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i2;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          return "";
        }
        return path2.slice(startDot, end);
      },
      format: function format(pathObject) {
        if (pathObject === null || typeof pathObject !== "object") {
          throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
        }
        return _format("/", pathObject);
      },
      parse: function parse(path2) {
        assertPath(path2);
        var ret = { root: "", dir: "", base: "", ext: "", name: "" };
        if (path2.length === 0)
          return ret;
        var code = path2.charCodeAt(0);
        var isAbsolute = code === 47;
        var start;
        if (isAbsolute) {
          ret.root = "/";
          start = 1;
        } else {
          start = 0;
        }
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var i2 = path2.length - 1;
        var preDotState = 0;
        for (; i2 >= start; --i2) {
          code = path2.charCodeAt(i2);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i2 + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i2 + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i2;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          if (end !== -1) {
            if (startPart === 0 && isAbsolute)
              ret.base = ret.name = path2.slice(1, end);
            else
              ret.base = ret.name = path2.slice(startPart, end);
          }
        } else {
          if (startPart === 0 && isAbsolute) {
            ret.name = path2.slice(1, startDot);
            ret.base = path2.slice(1, end);
          } else {
            ret.name = path2.slice(startPart, startDot);
            ret.base = path2.slice(startPart, end);
          }
          ret.ext = path2.slice(startDot, end);
        }
        if (startPart > 0)
          ret.dir = path2.slice(0, startPart - 1);
        else if (isAbsolute)
          ret.dir = "/";
        return ret;
      },
      sep: "/",
      delimiter: ":",
      win32: null,
      posix: null
    };
    posix.posix = posix;
    module2.exports = posix;
  }
});

// node_modules/moment/moment.js
var require_moment = __commonJS({
  "node_modules/moment/moment.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global2.moment = factory();
    })(exports, function() {
      "use strict";
      var hookCallback;
      function hooks() {
        return hookCallback.apply(null, arguments);
      }
      function setHookCallback(callback) {
        hookCallback = callback;
      }
      function isArray3(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
      }
      function isObject2(input) {
        return input != null && Object.prototype.toString.call(input) === "[object Object]";
      }
      function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
      }
      function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
          return Object.getOwnPropertyNames(obj).length === 0;
        } else {
          var k;
          for (k in obj) {
            if (hasOwnProp(obj, k)) {
              return false;
            }
          }
          return true;
        }
      }
      function isUndefined(input) {
        return input === void 0;
      }
      function isNumber(input) {
        return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
      }
      function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
      }
      function map3(arr, fn) {
        var res = [], i2, arrLen = arr.length;
        for (i2 = 0; i2 < arrLen; ++i2) {
          res.push(fn(arr[i2], i2));
        }
        return res;
      }
      function extend(a, b) {
        for (var i2 in b) {
          if (hasOwnProp(b, i2)) {
            a[i2] = b[i2];
          }
        }
        if (hasOwnProp(b, "toString")) {
          a.toString = b.toString;
        }
        if (hasOwnProp(b, "valueOf")) {
          a.valueOf = b.valueOf;
        }
        return a;
      }
      function createUTC(input, format2, locale2, strict) {
        return createLocalOrUTC(input, format2, locale2, strict, true).utc();
      }
      function defaultParsingFlags() {
        return {
          empty: false,
          unusedTokens: [],
          unusedInput: [],
          overflow: -2,
          charsLeftOver: 0,
          nullInput: false,
          invalidEra: null,
          invalidMonth: null,
          invalidFormat: false,
          userInvalidated: false,
          iso: false,
          parsedDateParts: [],
          era: null,
          meridiem: null,
          rfc2822: false,
          weekdayMismatch: false
        };
      }
      function getParsingFlags(m) {
        if (m._pf == null) {
          m._pf = defaultParsingFlags();
        }
        return m._pf;
      }
      var some2;
      if (Array.prototype.some) {
        some2 = Array.prototype.some;
      } else {
        some2 = function(fun) {
          var t2 = Object(this), len = t2.length >>> 0, i2;
          for (i2 = 0; i2 < len; i2++) {
            if (i2 in t2 && fun.call(this, t2[i2], i2, t2)) {
              return true;
            }
          }
          return false;
        };
      }
      function isValid(m) {
        if (m._isValid == null) {
          var flags = getParsingFlags(m), parsedParts = some2.call(flags.parsedDateParts, function(i2) {
            return i2 != null;
          }), isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
          if (m._strict) {
            isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
          }
          if (Object.isFrozen == null || !Object.isFrozen(m)) {
            m._isValid = isNowValid;
          } else {
            return isNowValid;
          }
        }
        return m._isValid;
      }
      function createInvalid(flags) {
        var m = createUTC(NaN);
        if (flags != null) {
          extend(getParsingFlags(m), flags);
        } else {
          getParsingFlags(m).userInvalidated = true;
        }
        return m;
      }
      var momentProperties = hooks.momentProperties = [], updateInProgress = false;
      function copyConfig(to2, from4) {
        var i2, prop, val, momentPropertiesLen = momentProperties.length;
        if (!isUndefined(from4._isAMomentObject)) {
          to2._isAMomentObject = from4._isAMomentObject;
        }
        if (!isUndefined(from4._i)) {
          to2._i = from4._i;
        }
        if (!isUndefined(from4._f)) {
          to2._f = from4._f;
        }
        if (!isUndefined(from4._l)) {
          to2._l = from4._l;
        }
        if (!isUndefined(from4._strict)) {
          to2._strict = from4._strict;
        }
        if (!isUndefined(from4._tzm)) {
          to2._tzm = from4._tzm;
        }
        if (!isUndefined(from4._isUTC)) {
          to2._isUTC = from4._isUTC;
        }
        if (!isUndefined(from4._offset)) {
          to2._offset = from4._offset;
        }
        if (!isUndefined(from4._pf)) {
          to2._pf = getParsingFlags(from4);
        }
        if (!isUndefined(from4._locale)) {
          to2._locale = from4._locale;
        }
        if (momentPropertiesLen > 0) {
          for (i2 = 0; i2 < momentPropertiesLen; i2++) {
            prop = momentProperties[i2];
            val = from4[prop];
            if (!isUndefined(val)) {
              to2[prop] = val;
            }
          }
        }
        return to2;
      }
      function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
          this._d = new Date(NaN);
        }
        if (updateInProgress === false) {
          updateInProgress = true;
          hooks.updateOffset(this);
          updateInProgress = false;
        }
      }
      function isMoment(obj) {
        return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
      }
      function warn2(msg) {
        if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
          console.warn("Deprecation warning: " + msg);
        }
      }
      function deprecate(msg, fn) {
        var firstTime = true;
        return extend(function() {
          if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(null, msg);
          }
          if (firstTime) {
            var args3 = [], arg, i2, key, argLen = arguments.length;
            for (i2 = 0; i2 < argLen; i2++) {
              arg = "";
              if (typeof arguments[i2] === "object") {
                arg += "\n[" + i2 + "] ";
                for (key in arguments[0]) {
                  if (hasOwnProp(arguments[0], key)) {
                    arg += key + ": " + arguments[0][key] + ", ";
                  }
                }
                arg = arg.slice(0, -2);
              } else {
                arg = arguments[i2];
              }
              args3.push(arg);
            }
            warn2(
              msg + "\nArguments: " + Array.prototype.slice.call(args3).join("") + "\n" + new Error().stack
            );
            firstTime = false;
          }
          return fn.apply(this, arguments);
        }, fn);
      }
      var deprecations = {};
      function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
          hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
          warn2(msg);
          deprecations[name] = true;
        }
      }
      hooks.suppressDeprecationWarnings = false;
      hooks.deprecationHandler = null;
      function isFunction(input) {
        return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
      }
      function set(config) {
        var prop, i2;
        for (i2 in config) {
          if (hasOwnProp(config, i2)) {
            prop = config[i2];
            if (isFunction(prop)) {
              this[i2] = prop;
            } else {
              this["_" + i2] = prop;
            }
          }
        }
        this._config = config;
        this._dayOfMonthOrdinalParseLenient = new RegExp(
          (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
        );
      }
      function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig), prop;
        for (prop in childConfig) {
          if (hasOwnProp(childConfig, prop)) {
            if (isObject2(parentConfig[prop]) && isObject2(childConfig[prop])) {
              res[prop] = {};
              extend(res[prop], parentConfig[prop]);
              extend(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
              res[prop] = childConfig[prop];
            } else {
              delete res[prop];
            }
          }
        }
        for (prop in parentConfig) {
          if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject2(parentConfig[prop])) {
            res[prop] = extend({}, res[prop]);
          }
        }
        return res;
      }
      function Locale(config) {
        if (config != null) {
          this.set(config);
        }
      }
      var keys2;
      if (Object.keys) {
        keys2 = Object.keys;
      } else {
        keys2 = function(obj) {
          var i2, res = [];
          for (i2 in obj) {
            if (hasOwnProp(obj, i2)) {
              res.push(i2);
            }
          }
          return res;
        };
      }
      var defaultCalendar = {
        sameDay: "[Today at] LT",
        nextDay: "[Tomorrow at] LT",
        nextWeek: "dddd [at] LT",
        lastDay: "[Yesterday at] LT",
        lastWeek: "[Last] dddd [at] LT",
        sameElse: "L"
      };
      function calendar(key, mom, now3) {
        var output = this._calendar[key] || this._calendar["sameElse"];
        return isFunction(output) ? output.call(mom, now3) : output;
      }
      function zeroFill(number, targetLength, forceSign) {
        var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
        return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
      }
      var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
      function addFormatToken(token2, padded, ordinal2, callback) {
        var func = callback;
        if (typeof callback === "string") {
          func = function() {
            return this[callback]();
          };
        }
        if (token2) {
          formatTokenFunctions[token2] = func;
        }
        if (padded) {
          formatTokenFunctions[padded[0]] = function() {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
          };
        }
        if (ordinal2) {
          formatTokenFunctions[ordinal2] = function() {
            return this.localeData().ordinal(
              func.apply(this, arguments),
              token2
            );
          };
        }
      }
      function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
          return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
      }
      function makeFormatFunction(format2) {
        var array = format2.match(formattingTokens), i2, length4;
        for (i2 = 0, length4 = array.length; i2 < length4; i2++) {
          if (formatTokenFunctions[array[i2]]) {
            array[i2] = formatTokenFunctions[array[i2]];
          } else {
            array[i2] = removeFormattingTokens(array[i2]);
          }
        }
        return function(mom) {
          var output = "", i3;
          for (i3 = 0; i3 < length4; i3++) {
            output += isFunction(array[i3]) ? array[i3].call(mom, format2) : array[i3];
          }
          return output;
        };
      }
      function formatMoment(m, format2) {
        if (!m.isValid()) {
          return m.localeData().invalidDate();
        }
        format2 = expandFormat(format2, m.localeData());
        formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
        return formatFunctions[format2](m);
      }
      function expandFormat(format2, locale2) {
        var i2 = 5;
        function replaceLongDateFormatTokens(input) {
          return locale2.longDateFormat(input) || input;
        }
        localFormattingTokens.lastIndex = 0;
        while (i2 >= 0 && localFormattingTokens.test(format2)) {
          format2 = format2.replace(
            localFormattingTokens,
            replaceLongDateFormatTokens
          );
          localFormattingTokens.lastIndex = 0;
          i2 -= 1;
        }
        return format2;
      }
      var defaultLongDateFormat = {
        LTS: "h:mm:ss A",
        LT: "h:mm A",
        L: "MM/DD/YYYY",
        LL: "MMMM D, YYYY",
        LLL: "MMMM D, YYYY h:mm A",
        LLLL: "dddd, MMMM D, YYYY h:mm A"
      };
      function longDateFormat(key) {
        var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
        if (format2 || !formatUpper) {
          return format2;
        }
        this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
          if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
            return tok.slice(1);
          }
          return tok;
        }).join("");
        return this._longDateFormat[key];
      }
      var defaultInvalidDate = "Invalid date";
      function invalidDate() {
        return this._invalidDate;
      }
      var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
      function ordinal(number) {
        return this._ordinal.replace("%d", number);
      }
      var defaultRelativeTime = {
        future: "in %s",
        past: "%s ago",
        s: "a few seconds",
        ss: "%d seconds",
        m: "a minute",
        mm: "%d minutes",
        h: "an hour",
        hh: "%d hours",
        d: "a day",
        dd: "%d days",
        w: "a week",
        ww: "%d weeks",
        M: "a month",
        MM: "%d months",
        y: "a year",
        yy: "%d years"
      };
      function relativeTime(number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
      }
      function pastFuture(diff2, output) {
        var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
        return isFunction(format2) ? format2(output) : format2.replace(/%s/i, output);
      }
      var aliases = {};
      function addUnitAlias(unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
      }
      function normalizeUnits(units) {
        return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
      }
      function normalizeObjectUnits(inputObject) {
        var normalizedInput = {}, normalizedProp, prop;
        for (prop in inputObject) {
          if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
              normalizedInput[normalizedProp] = inputObject[prop];
            }
          }
        }
        return normalizedInput;
      }
      var priorities = {};
      function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
      }
      function getPrioritizedUnits(unitsObj) {
        var units = [], u;
        for (u in unitsObj) {
          if (hasOwnProp(unitsObj, u)) {
            units.push({ unit: u, priority: priorities[u] });
          }
        }
        units.sort(function(a, b) {
          return a.priority - b.priority;
        });
        return units;
      }
      function isLeapYear(year2) {
        return year2 % 4 === 0 && year2 % 100 !== 0 || year2 % 400 === 0;
      }
      function absFloor(number) {
        if (number < 0) {
          return Math.ceil(number) || 0;
        } else {
          return Math.floor(number);
        }
      }
      function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion, value = 0;
        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
          value = absFloor(coercedNumber);
        }
        return value;
      }
      function makeGetSet(unit, keepTime) {
        return function(value) {
          if (value != null) {
            set$1(this, unit, value);
            hooks.updateOffset(this, keepTime);
            return this;
          } else {
            return get2(this, unit);
          }
        };
      }
      function get2(mom, unit) {
        return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
      }
      function set$1(mom, unit, value) {
        if (mom.isValid() && !isNaN(value)) {
          if (unit === "FullYear" && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
            value = toInt(value);
            mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](
              value,
              mom.month(),
              daysInMonth(value, mom.month())
            );
          } else {
            mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
          }
        }
      }
      function stringGet(units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
          return this[units]();
        }
        return this;
      }
      function stringSet(units, value) {
        if (typeof units === "object") {
          units = normalizeObjectUnits(units);
          var prioritized = getPrioritizedUnits(units), i2, prioritizedLen = prioritized.length;
          for (i2 = 0; i2 < prioritizedLen; i2++) {
            this[prioritized[i2].unit](units[prioritized[i2].unit]);
          }
        } else {
          units = normalizeUnits(units);
          if (isFunction(this[units])) {
            return this[units](value);
          }
        }
        return this;
      }
      var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, regexes;
      regexes = {};
      function addRegexToken(token2, regex, strictRegex) {
        regexes[token2] = isFunction(regex) ? regex : function(isStrict, localeData2) {
          return isStrict && strictRegex ? strictRegex : regex;
        };
      }
      function getParseRegexForToken(token2, config) {
        if (!hasOwnProp(regexes, token2)) {
          return new RegExp(unescapeFormat(token2));
        }
        return regexes[token2](config._strict, config._locale);
      }
      function unescapeFormat(s2) {
        return regexEscape(
          s2.replace("\\", "").replace(
            /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
            function(matched, p1, p2, p3, p4) {
              return p1 || p2 || p3 || p4;
            }
          )
        );
      }
      function regexEscape(s2) {
        return s2.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
      }
      var tokens = {};
      function addParseToken(token2, callback) {
        var i2, func = callback, tokenLen;
        if (typeof token2 === "string") {
          token2 = [token2];
        }
        if (isNumber(callback)) {
          func = function(input, array) {
            array[callback] = toInt(input);
          };
        }
        tokenLen = token2.length;
        for (i2 = 0; i2 < tokenLen; i2++) {
          tokens[token2[i2]] = func;
        }
      }
      function addWeekParseToken(token2, callback) {
        addParseToken(token2, function(input, array, config, token3) {
          config._w = config._w || {};
          callback(input, config._w, config, token3);
        });
      }
      function addTimeToArrayFromToken(token2, input, config) {
        if (input != null && hasOwnProp(tokens, token2)) {
          tokens[token2](input, config._a, config, token2);
        }
      }
      var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
      function mod(n, x) {
        return (n % x + x) % x;
      }
      var indexOf;
      if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
      } else {
        indexOf = function(o) {
          var i2;
          for (i2 = 0; i2 < this.length; ++i2) {
            if (this[i2] === o) {
              return i2;
            }
          }
          return -1;
        };
      }
      function daysInMonth(year2, month) {
        if (isNaN(year2) || isNaN(month)) {
          return NaN;
        }
        var modMonth = mod(month, 12);
        year2 += (month - modMonth) / 12;
        return modMonth === 1 ? isLeapYear(year2) ? 29 : 28 : 31 - modMonth % 7 % 2;
      }
      addFormatToken("M", ["MM", 2], "Mo", function() {
        return this.month() + 1;
      });
      addFormatToken("MMM", 0, 0, function(format2) {
        return this.localeData().monthsShort(this, format2);
      });
      addFormatToken("MMMM", 0, 0, function(format2) {
        return this.localeData().months(this, format2);
      });
      addUnitAlias("month", "M");
      addUnitPriority("month", 8);
      addRegexToken("M", match1to2);
      addRegexToken("MM", match1to2, match2);
      addRegexToken("MMM", function(isStrict, locale2) {
        return locale2.monthsShortRegex(isStrict);
      });
      addRegexToken("MMMM", function(isStrict, locale2) {
        return locale2.monthsRegex(isStrict);
      });
      addParseToken(["M", "MM"], function(input, array) {
        array[MONTH] = toInt(input) - 1;
      });
      addParseToken(["MMM", "MMMM"], function(input, array, config, token2) {
        var month = config._locale.monthsParse(input, token2, config._strict);
        if (month != null) {
          array[MONTH] = month;
        } else {
          getParsingFlags(config).invalidMonth = input;
        }
      });
      var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split(
        "_"
      ), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
      function localeMonths(m, format2) {
        if (!m) {
          return isArray3(this._months) ? this._months : this._months["standalone"];
        }
        return isArray3(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m.month()];
      }
      function localeMonthsShort(m, format2) {
        if (!m) {
          return isArray3(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
        }
        return isArray3(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m.month()];
      }
      function handleStrictParse(monthName, format2, strict) {
        var i2, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
          for (i2 = 0; i2 < 12; ++i2) {
            mom = createUTC([2e3, i2]);
            this._shortMonthsParse[i2] = this.monthsShort(
              mom,
              ""
            ).toLocaleLowerCase();
            this._longMonthsParse[i2] = this.months(mom, "").toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format2 === "MMM") {
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format2 === "MMM") {
            ii = indexOf.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      function localeMonthsParse(monthName, format2, strict) {
        var i2, mom, regex;
        if (this._monthsParseExact) {
          return handleStrictParse.call(this, monthName, format2, strict);
        }
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
        }
        for (i2 = 0; i2 < 12; i2++) {
          mom = createUTC([2e3, i2]);
          if (strict && !this._longMonthsParse[i2]) {
            this._longMonthsParse[i2] = new RegExp(
              "^" + this.months(mom, "").replace(".", "") + "$",
              "i"
            );
            this._shortMonthsParse[i2] = new RegExp(
              "^" + this.monthsShort(mom, "").replace(".", "") + "$",
              "i"
            );
          }
          if (!strict && !this._monthsParse[i2]) {
            regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
            this._monthsParse[i2] = new RegExp(regex.replace(".", ""), "i");
          }
          if (strict && format2 === "MMMM" && this._longMonthsParse[i2].test(monthName)) {
            return i2;
          } else if (strict && format2 === "MMM" && this._shortMonthsParse[i2].test(monthName)) {
            return i2;
          } else if (!strict && this._monthsParse[i2].test(monthName)) {
            return i2;
          }
        }
      }
      function setMonth(mom, value) {
        var dayOfMonth;
        if (!mom.isValid()) {
          return mom;
        }
        if (typeof value === "string") {
          if (/^\d+$/.test(value)) {
            value = toInt(value);
          } else {
            value = mom.localeData().monthsParse(value);
            if (!isNumber(value)) {
              return mom;
            }
          }
        }
        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
        return mom;
      }
      function getSetMonth(value) {
        if (value != null) {
          setMonth(this, value);
          hooks.updateOffset(this, true);
          return this;
        } else {
          return get2(this, "Month");
        }
      }
      function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
      }
      function monthsShortRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, "_monthsRegex")) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsShortStrictRegex;
          } else {
            return this._monthsShortRegex;
          }
        } else {
          if (!hasOwnProp(this, "_monthsShortRegex")) {
            this._monthsShortRegex = defaultMonthsShortRegex;
          }
          return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
        }
      }
      function monthsRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, "_monthsRegex")) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsStrictRegex;
          } else {
            return this._monthsRegex;
          }
        } else {
          if (!hasOwnProp(this, "_monthsRegex")) {
            this._monthsRegex = defaultMonthsRegex;
          }
          return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
        }
      }
      function computeMonthsParse() {
        function cmpLenRev(a, b) {
          return b.length - a.length;
        }
        var shortPieces = [], longPieces = [], mixedPieces = [], i2, mom;
        for (i2 = 0; i2 < 12; i2++) {
          mom = createUTC([2e3, i2]);
          shortPieces.push(this.monthsShort(mom, ""));
          longPieces.push(this.months(mom, ""));
          mixedPieces.push(this.months(mom, ""));
          mixedPieces.push(this.monthsShort(mom, ""));
        }
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i2 = 0; i2 < 12; i2++) {
          shortPieces[i2] = regexEscape(shortPieces[i2]);
          longPieces[i2] = regexEscape(longPieces[i2]);
        }
        for (i2 = 0; i2 < 24; i2++) {
          mixedPieces[i2] = regexEscape(mixedPieces[i2]);
        }
        this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp(
          "^(" + longPieces.join("|") + ")",
          "i"
        );
        this._monthsShortStrictRegex = new RegExp(
          "^(" + shortPieces.join("|") + ")",
          "i"
        );
      }
      addFormatToken("Y", 0, 0, function() {
        var y = this.year();
        return y <= 9999 ? zeroFill(y, 4) : "+" + y;
      });
      addFormatToken(0, ["YY", 2], 0, function() {
        return this.year() % 100;
      });
      addFormatToken(0, ["YYYY", 4], 0, "year");
      addFormatToken(0, ["YYYYY", 5], 0, "year");
      addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
      addUnitAlias("year", "y");
      addUnitPriority("year", 1);
      addRegexToken("Y", matchSigned);
      addRegexToken("YY", match1to2, match2);
      addRegexToken("YYYY", match1to4, match4);
      addRegexToken("YYYYY", match1to6, match6);
      addRegexToken("YYYYYY", match1to6, match6);
      addParseToken(["YYYYY", "YYYYYY"], YEAR);
      addParseToken("YYYY", function(input, array) {
        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
      });
      addParseToken("YY", function(input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
      });
      addParseToken("Y", function(input, array) {
        array[YEAR] = parseInt(input, 10);
      });
      function daysInYear(year2) {
        return isLeapYear(year2) ? 366 : 365;
      }
      hooks.parseTwoDigitYear = function(input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
      };
      var getSetYear = makeGetSet("FullYear", true);
      function getIsLeapYear() {
        return isLeapYear(this.year());
      }
      function createDate(y, m, d, h, M, s2, ms) {
        var date;
        if (y < 100 && y >= 0) {
          date = new Date(y + 400, m, d, h, M, s2, ms);
          if (isFinite(date.getFullYear())) {
            date.setFullYear(y);
          }
        } else {
          date = new Date(y, m, d, h, M, s2, ms);
        }
        return date;
      }
      function createUTCDate(y) {
        var date, args3;
        if (y < 100 && y >= 0) {
          args3 = Array.prototype.slice.call(arguments);
          args3[0] = y + 400;
          date = new Date(Date.UTC.apply(null, args3));
          if (isFinite(date.getUTCFullYear())) {
            date.setUTCFullYear(y);
          }
        } else {
          date = new Date(Date.UTC.apply(null, arguments));
        }
        return date;
      }
      function firstWeekOffset(year2, dow, doy) {
        var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year2, 0, fwd).getUTCDay() - dow) % 7;
        return -fwdlw + fwd - 1;
      }
      function dayOfYearFromWeeks(year2, week2, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year2, dow, doy), dayOfYear = 1 + 7 * (week2 - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
        if (dayOfYear <= 0) {
          resYear = year2 - 1;
          resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year2)) {
          resYear = year2 + 1;
          resDayOfYear = dayOfYear - daysInYear(year2);
        } else {
          resYear = year2;
          resDayOfYear = dayOfYear;
        }
        return {
          year: resYear,
          dayOfYear: resDayOfYear
        };
      }
      function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy), week2 = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
        if (week2 < 1) {
          resYear = mom.year() - 1;
          resWeek = week2 + weeksInYear(resYear, dow, doy);
        } else if (week2 > weeksInYear(mom.year(), dow, doy)) {
          resWeek = week2 - weeksInYear(mom.year(), dow, doy);
          resYear = mom.year() + 1;
        } else {
          resYear = mom.year();
          resWeek = week2;
        }
        return {
          week: resWeek,
          year: resYear
        };
      }
      function weeksInYear(year2, dow, doy) {
        var weekOffset = firstWeekOffset(year2, dow, doy), weekOffsetNext = firstWeekOffset(year2 + 1, dow, doy);
        return (daysInYear(year2) - weekOffset + weekOffsetNext) / 7;
      }
      addFormatToken("w", ["ww", 2], "wo", "week");
      addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
      addUnitAlias("week", "w");
      addUnitAlias("isoWeek", "W");
      addUnitPriority("week", 5);
      addUnitPriority("isoWeek", 5);
      addRegexToken("w", match1to2);
      addRegexToken("ww", match1to2, match2);
      addRegexToken("W", match1to2);
      addRegexToken("WW", match1to2, match2);
      addWeekParseToken(
        ["w", "ww", "W", "WW"],
        function(input, week2, config, token2) {
          week2[token2.substr(0, 1)] = toInt(input);
        }
      );
      function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
      }
      var defaultLocaleWeek = {
        dow: 0,
        // Sunday is the first day of the week.
        doy: 6
        // The week that contains Jan 6th is the first week of the year.
      };
      function localeFirstDayOfWeek() {
        return this._week.dow;
      }
      function localeFirstDayOfYear() {
        return this._week.doy;
      }
      function getSetWeek(input) {
        var week2 = this.localeData().week(this);
        return input == null ? week2 : this.add((input - week2) * 7, "d");
      }
      function getSetISOWeek(input) {
        var week2 = weekOfYear(this, 1, 4).week;
        return input == null ? week2 : this.add((input - week2) * 7, "d");
      }
      addFormatToken("d", 0, "do", "day");
      addFormatToken("dd", 0, 0, function(format2) {
        return this.localeData().weekdaysMin(this, format2);
      });
      addFormatToken("ddd", 0, 0, function(format2) {
        return this.localeData().weekdaysShort(this, format2);
      });
      addFormatToken("dddd", 0, 0, function(format2) {
        return this.localeData().weekdays(this, format2);
      });
      addFormatToken("e", 0, 0, "weekday");
      addFormatToken("E", 0, 0, "isoWeekday");
      addUnitAlias("day", "d");
      addUnitAlias("weekday", "e");
      addUnitAlias("isoWeekday", "E");
      addUnitPriority("day", 11);
      addUnitPriority("weekday", 11);
      addUnitPriority("isoWeekday", 11);
      addRegexToken("d", match1to2);
      addRegexToken("e", match1to2);
      addRegexToken("E", match1to2);
      addRegexToken("dd", function(isStrict, locale2) {
        return locale2.weekdaysMinRegex(isStrict);
      });
      addRegexToken("ddd", function(isStrict, locale2) {
        return locale2.weekdaysShortRegex(isStrict);
      });
      addRegexToken("dddd", function(isStrict, locale2) {
        return locale2.weekdaysRegex(isStrict);
      });
      addWeekParseToken(["dd", "ddd", "dddd"], function(input, week2, config, token2) {
        var weekday = config._locale.weekdaysParse(input, token2, config._strict);
        if (weekday != null) {
          week2.d = weekday;
        } else {
          getParsingFlags(config).invalidWeekday = input;
        }
      });
      addWeekParseToken(["d", "e", "E"], function(input, week2, config, token2) {
        week2[token2] = toInt(input);
      });
      function parseWeekday(input, locale2) {
        if (typeof input !== "string") {
          return input;
        }
        if (!isNaN(input)) {
          return parseInt(input, 10);
        }
        input = locale2.weekdaysParse(input);
        if (typeof input === "number") {
          return input;
        }
        return null;
      }
      function parseIsoWeekday(input, locale2) {
        if (typeof input === "string") {
          return locale2.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
      }
      function shiftWeekdays(ws, n) {
        return ws.slice(n, 7).concat(ws.slice(0, n));
      }
      var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
      function localeWeekdays(m, format2) {
        var weekdays = isArray3(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
        return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
      }
      function localeWeekdaysShort(m) {
        return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
      }
      function localeWeekdaysMin(m) {
        return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
      }
      function handleStrictParse$1(weekdayName, format2, strict) {
        var i2, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._minWeekdaysParse = [];
          for (i2 = 0; i2 < 7; ++i2) {
            mom = createUTC([2e3, 1]).day(i2);
            this._minWeekdaysParse[i2] = this.weekdaysMin(
              mom,
              ""
            ).toLocaleLowerCase();
            this._shortWeekdaysParse[i2] = this.weekdaysShort(
              mom,
              ""
            ).toLocaleLowerCase();
            this._weekdaysParse[i2] = this.weekdays(mom, "").toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format2 === "dddd") {
            ii = indexOf.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format2 === "ddd") {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format2 === "dddd") {
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format2 === "ddd") {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      function localeWeekdaysParse(weekdayName, format2, strict) {
        var i2, mom, regex;
        if (this._weekdaysParseExact) {
          return handleStrictParse$1.call(this, weekdayName, format2, strict);
        }
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._minWeekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._fullWeekdaysParse = [];
        }
        for (i2 = 0; i2 < 7; i2++) {
          mom = createUTC([2e3, 1]).day(i2);
          if (strict && !this._fullWeekdaysParse[i2]) {
            this._fullWeekdaysParse[i2] = new RegExp(
              "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
            this._shortWeekdaysParse[i2] = new RegExp(
              "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
            this._minWeekdaysParse[i2] = new RegExp(
              "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
          }
          if (!this._weekdaysParse[i2]) {
            regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
            this._weekdaysParse[i2] = new RegExp(regex.replace(".", ""), "i");
          }
          if (strict && format2 === "dddd" && this._fullWeekdaysParse[i2].test(weekdayName)) {
            return i2;
          } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i2].test(weekdayName)) {
            return i2;
          } else if (strict && format2 === "dd" && this._minWeekdaysParse[i2].test(weekdayName)) {
            return i2;
          } else if (!strict && this._weekdaysParse[i2].test(weekdayName)) {
            return i2;
          }
        }
      }
      function getSetDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var day2 = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
          input = parseWeekday(input, this.localeData());
          return this.add(input - day2, "d");
        } else {
          return day2;
        }
      }
      function getSetLocaleDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, "d");
      }
      function getSetISODayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          var weekday = parseIsoWeekday(input, this.localeData());
          return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
          return this.day() || 7;
        }
      }
      function weekdaysRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysStrictRegex;
          } else {
            return this._weekdaysRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            this._weekdaysRegex = defaultWeekdaysRegex;
          }
          return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
        }
      }
      function weekdaysShortRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysShortStrictRegex;
          } else {
            return this._weekdaysShortRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysShortRegex")) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
          }
          return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
      }
      function weekdaysMinRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysMinStrictRegex;
          } else {
            return this._weekdaysMinRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysMinRegex")) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
          }
          return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
      }
      function computeWeekdaysParse() {
        function cmpLenRev(a, b) {
          return b.length - a.length;
        }
        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i2, mom, minp, shortp, longp;
        for (i2 = 0; i2 < 7; i2++) {
          mom = createUTC([2e3, 1]).day(i2);
          minp = regexEscape(this.weekdaysMin(mom, ""));
          shortp = regexEscape(this.weekdaysShort(mom, ""));
          longp = regexEscape(this.weekdays(mom, ""));
          minPieces.push(minp);
          shortPieces.push(shortp);
          longPieces.push(longp);
          mixedPieces.push(minp);
          mixedPieces.push(shortp);
          mixedPieces.push(longp);
        }
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;
        this._weekdaysStrictRegex = new RegExp(
          "^(" + longPieces.join("|") + ")",
          "i"
        );
        this._weekdaysShortStrictRegex = new RegExp(
          "^(" + shortPieces.join("|") + ")",
          "i"
        );
        this._weekdaysMinStrictRegex = new RegExp(
          "^(" + minPieces.join("|") + ")",
          "i"
        );
      }
      function hFormat() {
        return this.hours() % 12 || 12;
      }
      function kFormat() {
        return this.hours() || 24;
      }
      addFormatToken("H", ["HH", 2], 0, "hour");
      addFormatToken("h", ["hh", 2], 0, hFormat);
      addFormatToken("k", ["kk", 2], 0, kFormat);
      addFormatToken("hmm", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
      });
      addFormatToken("hmmss", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      addFormatToken("Hmm", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2);
      });
      addFormatToken("Hmmss", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      function meridiem(token2, lowercase) {
        addFormatToken(token2, 0, 0, function() {
          return this.localeData().meridiem(
            this.hours(),
            this.minutes(),
            lowercase
          );
        });
      }
      meridiem("a", true);
      meridiem("A", false);
      addUnitAlias("hour", "h");
      addUnitPriority("hour", 13);
      function matchMeridiem(isStrict, locale2) {
        return locale2._meridiemParse;
      }
      addRegexToken("a", matchMeridiem);
      addRegexToken("A", matchMeridiem);
      addRegexToken("H", match1to2);
      addRegexToken("h", match1to2);
      addRegexToken("k", match1to2);
      addRegexToken("HH", match1to2, match2);
      addRegexToken("hh", match1to2, match2);
      addRegexToken("kk", match1to2, match2);
      addRegexToken("hmm", match3to4);
      addRegexToken("hmmss", match5to6);
      addRegexToken("Hmm", match3to4);
      addRegexToken("Hmmss", match5to6);
      addParseToken(["H", "HH"], HOUR);
      addParseToken(["k", "kk"], function(input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
      });
      addParseToken(["a", "A"], function(input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
      });
      addParseToken(["h", "hh"], function(input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("Hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
      });
      addParseToken("Hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
      });
      function localeIsPM(input) {
        return (input + "").toLowerCase().charAt(0) === "p";
      }
      var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
      function localeMeridiem(hours2, minutes2, isLower) {
        if (hours2 > 11) {
          return isLower ? "pm" : "PM";
        } else {
          return isLower ? "am" : "AM";
        }
      }
      var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,
        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,
        week: defaultLocaleWeek,
        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,
        meridiemParse: defaultLocaleMeridiemParse
      };
      var locales = {}, localeFamilies = {}, globalLocale;
      function commonPrefix(arr1, arr2) {
        var i2, minl = Math.min(arr1.length, arr2.length);
        for (i2 = 0; i2 < minl; i2 += 1) {
          if (arr1[i2] !== arr2[i2]) {
            return i2;
          }
        }
        return minl;
      }
      function normalizeLocale(key) {
        return key ? key.toLowerCase().replace("_", "-") : key;
      }
      function chooseLocale(names) {
        var i2 = 0, j, next, locale2, split;
        while (i2 < names.length) {
          split = normalizeLocale(names[i2]).split("-");
          j = split.length;
          next = normalizeLocale(names[i2 + 1]);
          next = next ? next.split("-") : null;
          while (j > 0) {
            locale2 = loadLocale(split.slice(0, j).join("-"));
            if (locale2) {
              return locale2;
            }
            if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
              break;
            }
            j--;
          }
          i2++;
        }
        return globalLocale;
      }
      function isLocaleNameSane(name) {
        return name.match("^[^/\\\\]*$") != null;
      }
      function loadLocale(name) {
        var oldLocale = null, aliasedRequire;
        if (locales[name] === void 0 && typeof module2 !== "undefined" && module2 && module2.exports && isLocaleNameSane(name)) {
          try {
            oldLocale = globalLocale._abbr;
            aliasedRequire = require;
            aliasedRequire("./locale/" + name);
            getSetGlobalLocale(oldLocale);
          } catch (e2) {
            locales[name] = null;
          }
        }
        return locales[name];
      }
      function getSetGlobalLocale(key, values) {
        var data;
        if (key) {
          if (isUndefined(values)) {
            data = getLocale(key);
          } else {
            data = defineLocale(key, values);
          }
          if (data) {
            globalLocale = data;
          } else {
            if (typeof console !== "undefined" && console.warn) {
              console.warn(
                "Locale " + key + " not found. Did you forget to load it?"
              );
            }
          }
        }
        return globalLocale._abbr;
      }
      function defineLocale(name, config) {
        if (config !== null) {
          var locale2, parentConfig = baseConfig;
          config.abbr = name;
          if (locales[name] != null) {
            deprecateSimple(
              "defineLocaleOverride",
              "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
            );
            parentConfig = locales[name]._config;
          } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
              parentConfig = locales[config.parentLocale]._config;
            } else {
              locale2 = loadLocale(config.parentLocale);
              if (locale2 != null) {
                parentConfig = locale2._config;
              } else {
                if (!localeFamilies[config.parentLocale]) {
                  localeFamilies[config.parentLocale] = [];
                }
                localeFamilies[config.parentLocale].push({
                  name,
                  config
                });
                return null;
              }
            }
          }
          locales[name] = new Locale(mergeConfigs(parentConfig, config));
          if (localeFamilies[name]) {
            localeFamilies[name].forEach(function(x) {
              defineLocale(x.name, x.config);
            });
          }
          getSetGlobalLocale(name);
          return locales[name];
        } else {
          delete locales[name];
          return null;
        }
      }
      function updateLocale(name, config) {
        if (config != null) {
          var locale2, tmpLocale, parentConfig = baseConfig;
          if (locales[name] != null && locales[name].parentLocale != null) {
            locales[name].set(mergeConfigs(locales[name]._config, config));
          } else {
            tmpLocale = loadLocale(name);
            if (tmpLocale != null) {
              parentConfig = tmpLocale._config;
            }
            config = mergeConfigs(parentConfig, config);
            if (tmpLocale == null) {
              config.abbr = name;
            }
            locale2 = new Locale(config);
            locale2.parentLocale = locales[name];
            locales[name] = locale2;
          }
          getSetGlobalLocale(name);
        } else {
          if (locales[name] != null) {
            if (locales[name].parentLocale != null) {
              locales[name] = locales[name].parentLocale;
              if (name === getSetGlobalLocale()) {
                getSetGlobalLocale(name);
              }
            } else if (locales[name] != null) {
              delete locales[name];
            }
          }
        }
        return locales[name];
      }
      function getLocale(key) {
        var locale2;
        if (key && key._locale && key._locale._abbr) {
          key = key._locale._abbr;
        }
        if (!key) {
          return globalLocale;
        }
        if (!isArray3(key)) {
          locale2 = loadLocale(key);
          if (locale2) {
            return locale2;
          }
          key = [key];
        }
        return chooseLocale(key);
      }
      function listLocales() {
        return keys2(locales);
      }
      function checkOverflow(m) {
        var overflow, a = m._a;
        if (a && getParsingFlags(m).overflow === -2) {
          overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
          if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
          }
          if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
          }
          if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
          }
          getParsingFlags(m).overflow = overflow;
        }
        return m;
      }
      var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
        ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
        ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
        ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
        ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
        ["YYYY-DDD", /\d{4}-\d{3}/],
        ["YYYY-MM", /\d{4}-\d\d/, false],
        ["YYYYYYMMDD", /[+-]\d{10}/],
        ["YYYYMMDD", /\d{8}/],
        ["GGGG[W]WWE", /\d{4}W\d{3}/],
        ["GGGG[W]WW", /\d{4}W\d{2}/, false],
        ["YYYYDDD", /\d{7}/],
        ["YYYYMM", /\d{6}/, false],
        ["YYYY", /\d{4}/, false]
      ], isoTimes = [
        ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
        ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
        ["HH:mm:ss", /\d\d:\d\d:\d\d/],
        ["HH:mm", /\d\d:\d\d/],
        ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
        ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
        ["HHmmss", /\d\d\d\d\d\d/],
        ["HHmm", /\d\d\d\d/],
        ["HH", /\d\d/]
      ], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
        UT: 0,
        GMT: 0,
        EDT: -4 * 60,
        EST: -5 * 60,
        CDT: -5 * 60,
        CST: -6 * 60,
        MDT: -6 * 60,
        MST: -7 * 60,
        PDT: -7 * 60,
        PST: -8 * 60
      };
      function configFromISO(config) {
        var i2, l, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
        if (match) {
          getParsingFlags(config).iso = true;
          for (i2 = 0, l = isoDatesLen; i2 < l; i2++) {
            if (isoDates[i2][1].exec(match[1])) {
              dateFormat = isoDates[i2][0];
              allowTime = isoDates[i2][2] !== false;
              break;
            }
          }
          if (dateFormat == null) {
            config._isValid = false;
            return;
          }
          if (match[3]) {
            for (i2 = 0, l = isoTimesLen; i2 < l; i2++) {
              if (isoTimes[i2][1].exec(match[3])) {
                timeFormat = (match[2] || " ") + isoTimes[i2][0];
                break;
              }
            }
            if (timeFormat == null) {
              config._isValid = false;
              return;
            }
          }
          if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
          }
          if (match[4]) {
            if (tzRegex.exec(match[4])) {
              tzFormat = "Z";
            } else {
              config._isValid = false;
              return;
            }
          }
          config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
          configFromStringAndFormat(config);
        } else {
          config._isValid = false;
        }
      }
      function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        var result = [
          untruncateYear(yearStr),
          defaultLocaleMonthsShort.indexOf(monthStr),
          parseInt(dayStr, 10),
          parseInt(hourStr, 10),
          parseInt(minuteStr, 10)
        ];
        if (secondStr) {
          result.push(parseInt(secondStr, 10));
        }
        return result;
      }
      function untruncateYear(yearStr) {
        var year2 = parseInt(yearStr, 10);
        if (year2 <= 49) {
          return 2e3 + year2;
        } else if (year2 <= 999) {
          return 1900 + year2;
        }
        return year2;
      }
      function preprocessRFC2822(s2) {
        return s2.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
      }
      function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
          var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(
            parsedInput[0],
            parsedInput[1],
            parsedInput[2]
          ).getDay();
          if (weekdayProvided !== weekdayActual) {
            getParsingFlags(config).weekdayMismatch = true;
            config._isValid = false;
            return false;
          }
        }
        return true;
      }
      function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
          return obsOffsets[obsOffset];
        } else if (militaryOffset) {
          return 0;
        } else {
          var hm = parseInt(numOffset, 10), m = hm % 100, h = (hm - m) / 100;
          return h * 60 + m;
        }
      }
      function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
        if (match) {
          parsedArray = extractFromRFC2822Strings(
            match[4],
            match[3],
            match[2],
            match[5],
            match[6],
            match[7]
          );
          if (!checkWeekday(match[1], parsedArray, config)) {
            return;
          }
          config._a = parsedArray;
          config._tzm = calculateOffset(match[8], match[9], match[10]);
          config._d = createUTCDate.apply(null, config._a);
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
          getParsingFlags(config).rfc2822 = true;
        } else {
          config._isValid = false;
        }
      }
      function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);
        if (matched !== null) {
          config._d = new Date(+matched[1]);
          return;
        }
        configFromISO(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }
        configFromRFC2822(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }
        if (config._strict) {
          config._isValid = false;
        } else {
          hooks.createFromInputFallback(config);
        }
      }
      hooks.createFromInputFallback = deprecate(
        "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
        function(config) {
          config._d = new Date(config._i + (config._useUTC ? " UTC" : ""));
        }
      );
      function defaults(a, b, c) {
        if (a != null) {
          return a;
        }
        if (b != null) {
          return b;
        }
        return c;
      }
      function currentDateArray(config) {
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
          return [
            nowValue.getUTCFullYear(),
            nowValue.getUTCMonth(),
            nowValue.getUTCDate()
          ];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
      }
      function configFromArray(config) {
        var i2, date, input = [], currentDate, expectedWeekday, yearToUse;
        if (config._d) {
          return;
        }
        currentDate = currentDateArray(config);
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
          dayOfYearFromWeekInfo(config);
        }
        if (config._dayOfYear != null) {
          yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
          if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
            getParsingFlags(config)._overflowDayOfYear = true;
          }
          date = createUTCDate(yearToUse, 0, config._dayOfYear);
          config._a[MONTH] = date.getUTCMonth();
          config._a[DATE] = date.getUTCDate();
        }
        for (i2 = 0; i2 < 3 && config._a[i2] == null; ++i2) {
          config._a[i2] = input[i2] = currentDate[i2];
        }
        for (; i2 < 7; i2++) {
          config._a[i2] = input[i2] = config._a[i2] == null ? i2 === 2 ? 1 : 0 : config._a[i2];
        }
        if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
          config._nextDay = true;
          config._a[HOUR] = 0;
        }
        config._d = (config._useUTC ? createUTCDate : createDate).apply(
          null,
          input
        );
        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
        if (config._tzm != null) {
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }
        if (config._nextDay) {
          config._a[HOUR] = 24;
        }
        if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
          getParsingFlags(config).weekdayMismatch = true;
        }
      }
      function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week2, weekday, dow, doy, temp, weekdayOverflow, curWeek;
        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
          dow = 1;
          doy = 4;
          weekYear = defaults(
            w.GG,
            config._a[YEAR],
            weekOfYear(createLocal(), 1, 4).year
          );
          week2 = defaults(w.W, 1);
          weekday = defaults(w.E, 1);
          if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
          }
        } else {
          dow = config._locale._week.dow;
          doy = config._locale._week.doy;
          curWeek = weekOfYear(createLocal(), dow, doy);
          weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);
          week2 = defaults(w.w, curWeek.week);
          if (w.d != null) {
            weekday = w.d;
            if (weekday < 0 || weekday > 6) {
              weekdayOverflow = true;
            }
          } else if (w.e != null) {
            weekday = w.e + dow;
            if (w.e < 0 || w.e > 6) {
              weekdayOverflow = true;
            }
          } else {
            weekday = dow;
          }
        }
        if (week2 < 1 || week2 > weeksInYear(weekYear, dow, doy)) {
          getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
          getParsingFlags(config)._overflowWeekday = true;
        } else {
          temp = dayOfYearFromWeeks(weekYear, week2, weekday, dow, doy);
          config._a[YEAR] = temp.year;
          config._dayOfYear = temp.dayOfYear;
        }
      }
      hooks.ISO_8601 = function() {
      };
      hooks.RFC_2822 = function() {
      };
      function configFromStringAndFormat(config) {
        if (config._f === hooks.ISO_8601) {
          configFromISO(config);
          return;
        }
        if (config._f === hooks.RFC_2822) {
          configFromRFC2822(config);
          return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;
        var string = "" + config._i, i2, parsedInput, tokens2, token2, skipped, stringLength = string.length, totalParsedInputLength = 0, era, tokenLen;
        tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
        tokenLen = tokens2.length;
        for (i2 = 0; i2 < tokenLen; i2++) {
          token2 = tokens2[i2];
          parsedInput = (string.match(getParseRegexForToken(token2, config)) || [])[0];
          if (parsedInput) {
            skipped = string.substr(0, string.indexOf(parsedInput));
            if (skipped.length > 0) {
              getParsingFlags(config).unusedInput.push(skipped);
            }
            string = string.slice(
              string.indexOf(parsedInput) + parsedInput.length
            );
            totalParsedInputLength += parsedInput.length;
          }
          if (formatTokenFunctions[token2]) {
            if (parsedInput) {
              getParsingFlags(config).empty = false;
            } else {
              getParsingFlags(config).unusedTokens.push(token2);
            }
            addTimeToArrayFromToken(token2, parsedInput, config);
          } else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token2);
          }
        }
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
          getParsingFlags(config).unusedInput.push(string);
        }
        if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
          getParsingFlags(config).bigHour = void 0;
        }
        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        config._a[HOUR] = meridiemFixWrap(
          config._locale,
          config._a[HOUR],
          config._meridiem
        );
        era = getParsingFlags(config).era;
        if (era !== null) {
          config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
        }
        configFromArray(config);
        checkOverflow(config);
      }
      function meridiemFixWrap(locale2, hour2, meridiem2) {
        var isPm;
        if (meridiem2 == null) {
          return hour2;
        }
        if (locale2.meridiemHour != null) {
          return locale2.meridiemHour(hour2, meridiem2);
        } else if (locale2.isPM != null) {
          isPm = locale2.isPM(meridiem2);
          if (isPm && hour2 < 12) {
            hour2 += 12;
          }
          if (!isPm && hour2 === 12) {
            hour2 = 0;
          }
          return hour2;
        } else {
          return hour2;
        }
      }
      function configFromStringAndArray(config) {
        var tempConfig, bestMoment, scoreToBeat, i2, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config._f.length;
        if (configfLen === 0) {
          getParsingFlags(config).invalidFormat = true;
          config._d = new Date(NaN);
          return;
        }
        for (i2 = 0; i2 < configfLen; i2++) {
          currentScore = 0;
          validFormatFound = false;
          tempConfig = copyConfig({}, config);
          if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
          }
          tempConfig._f = config._f[i2];
          configFromStringAndFormat(tempConfig);
          if (isValid(tempConfig)) {
            validFormatFound = true;
          }
          currentScore += getParsingFlags(tempConfig).charsLeftOver;
          currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
          getParsingFlags(tempConfig).score = currentScore;
          if (!bestFormatIsValid) {
            if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
              if (validFormatFound) {
                bestFormatIsValid = true;
              }
            }
          } else {
            if (currentScore < scoreToBeat) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
            }
          }
        }
        extend(config, bestMoment || tempConfig);
      }
      function configFromObject(config) {
        if (config._d) {
          return;
        }
        var i2 = normalizeObjectUnits(config._i), dayOrDate = i2.day === void 0 ? i2.date : i2.day;
        config._a = map3(
          [i2.year, i2.month, dayOrDate, i2.hour, i2.minute, i2.second, i2.millisecond],
          function(obj) {
            return obj && parseInt(obj, 10);
          }
        );
        configFromArray(config);
      }
      function createFromConfig(config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
          res.add(1, "d");
          res._nextDay = void 0;
        }
        return res;
      }
      function prepareConfig(config) {
        var input = config._i, format2 = config._f;
        config._locale = config._locale || getLocale(config._l);
        if (input === null || format2 === void 0 && input === "") {
          return createInvalid({ nullInput: true });
        }
        if (typeof input === "string") {
          config._i = input = config._locale.preparse(input);
        }
        if (isMoment(input)) {
          return new Moment(checkOverflow(input));
        } else if (isDate(input)) {
          config._d = input;
        } else if (isArray3(format2)) {
          configFromStringAndArray(config);
        } else if (format2) {
          configFromStringAndFormat(config);
        } else {
          configFromInput(config);
        }
        if (!isValid(config)) {
          config._d = null;
        }
        return config;
      }
      function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
          config._d = new Date(hooks.now());
        } else if (isDate(input)) {
          config._d = new Date(input.valueOf());
        } else if (typeof input === "string") {
          configFromString(config);
        } else if (isArray3(input)) {
          config._a = map3(input.slice(0), function(obj) {
            return parseInt(obj, 10);
          });
          configFromArray(config);
        } else if (isObject2(input)) {
          configFromObject(config);
        } else if (isNumber(input)) {
          config._d = new Date(input);
        } else {
          hooks.createFromInputFallback(config);
        }
      }
      function createLocalOrUTC(input, format2, locale2, strict, isUTC) {
        var c = {};
        if (format2 === true || format2 === false) {
          strict = format2;
          format2 = void 0;
        }
        if (locale2 === true || locale2 === false) {
          strict = locale2;
          locale2 = void 0;
        }
        if (isObject2(input) && isObjectEmpty(input) || isArray3(input) && input.length === 0) {
          input = void 0;
        }
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale2;
        c._i = input;
        c._f = format2;
        c._strict = strict;
        return createFromConfig(c);
      }
      function createLocal(input, format2, locale2, strict) {
        return createLocalOrUTC(input, format2, locale2, strict, false);
      }
      var prototypeMin = deprecate(
        "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
        function() {
          var other = createLocal.apply(null, arguments);
          if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
          } else {
            return createInvalid();
          }
        }
      ), prototypeMax = deprecate(
        "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
        function() {
          var other = createLocal.apply(null, arguments);
          if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
          } else {
            return createInvalid();
          }
        }
      );
      function pickBy(fn, moments) {
        var res, i2;
        if (moments.length === 1 && isArray3(moments[0])) {
          moments = moments[0];
        }
        if (!moments.length) {
          return createLocal();
        }
        res = moments[0];
        for (i2 = 1; i2 < moments.length; ++i2) {
          if (!moments[i2].isValid() || moments[i2][fn](res)) {
            res = moments[i2];
          }
        }
        return res;
      }
      function min3() {
        var args3 = [].slice.call(arguments, 0);
        return pickBy("isBefore", args3);
      }
      function max3() {
        var args3 = [].slice.call(arguments, 0);
        return pickBy("isAfter", args3);
      }
      var now2 = function() {
        return Date.now ? Date.now() : +new Date();
      };
      var ordering = [
        "year",
        "quarter",
        "month",
        "week",
        "day",
        "hour",
        "minute",
        "second",
        "millisecond"
      ];
      function isDurationValid(m) {
        var key, unitHasDecimal = false, i2, orderLen = ordering.length;
        for (key in m) {
          if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
            return false;
          }
        }
        for (i2 = 0; i2 < orderLen; ++i2) {
          if (m[ordering[i2]]) {
            if (unitHasDecimal) {
              return false;
            }
            if (parseFloat(m[ordering[i2]]) !== toInt(m[ordering[i2]])) {
              unitHasDecimal = true;
            }
          }
        }
        return true;
      }
      function isValid$1() {
        return this._isValid;
      }
      function createInvalid$1() {
        return createDuration(NaN);
      }
      function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
        this._isValid = isDurationValid(normalizedInput);
        this._milliseconds = +milliseconds2 + seconds2 * 1e3 + // 1000
        minutes2 * 6e4 + // 1000 * 60
        hours2 * 1e3 * 60 * 60;
        this._days = +days2 + weeks2 * 7;
        this._months = +months2 + quarters * 3 + years2 * 12;
        this._data = {};
        this._locale = getLocale();
        this._bubble();
      }
      function isDuration(obj) {
        return obj instanceof Duration;
      }
      function absRound(number) {
        if (number < 0) {
          return Math.round(-1 * number) * -1;
        } else {
          return Math.round(number);
        }
      }
      function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i2;
        for (i2 = 0; i2 < len; i2++) {
          if (dontConvert && array1[i2] !== array2[i2] || !dontConvert && toInt(array1[i2]) !== toInt(array2[i2])) {
            diffs++;
          }
        }
        return diffs + lengthDiff;
      }
      function offset(token2, separator) {
        addFormatToken(token2, 0, 0, function() {
          var offset2 = this.utcOffset(), sign2 = "+";
          if (offset2 < 0) {
            offset2 = -offset2;
            sign2 = "-";
          }
          return sign2 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
        });
      }
      offset("Z", ":");
      offset("ZZ", "");
      addRegexToken("Z", matchShortOffset);
      addRegexToken("ZZ", matchShortOffset);
      addParseToken(["Z", "ZZ"], function(input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
      });
      var chunkOffset = /([\+\-]|\d\d)/gi;
      function offsetFromString(matcher, string) {
        var matches = (string || "").match(matcher), chunk, parts, minutes2;
        if (matches === null) {
          return null;
        }
        chunk = matches[matches.length - 1] || [];
        parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
        minutes2 = +(parts[1] * 60) + toInt(parts[2]);
        return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
      }
      function cloneWithOffset(input, model) {
        var res, diff2;
        if (model._isUTC) {
          res = model.clone();
          diff2 = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
          res._d.setTime(res._d.valueOf() + diff2);
          hooks.updateOffset(res, false);
          return res;
        } else {
          return createLocal(input).local();
        }
      }
      function getDateOffset(m) {
        return -Math.round(m._d.getTimezoneOffset());
      }
      hooks.updateOffset = function() {
      };
      function getSetOffset(input, keepLocalTime, keepMinutes) {
        var offset2 = this._offset || 0, localAdjust;
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          if (typeof input === "string") {
            input = offsetFromString(matchShortOffset, input);
            if (input === null) {
              return this;
            }
          } else if (Math.abs(input) < 16 && !keepMinutes) {
            input = input * 60;
          }
          if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
          }
          this._offset = input;
          this._isUTC = true;
          if (localAdjust != null) {
            this.add(localAdjust, "m");
          }
          if (offset2 !== input) {
            if (!keepLocalTime || this._changeInProgress) {
              addSubtract(
                this,
                createDuration(input - offset2, "m"),
                1,
                false
              );
            } else if (!this._changeInProgress) {
              this._changeInProgress = true;
              hooks.updateOffset(this, true);
              this._changeInProgress = null;
            }
          }
          return this;
        } else {
          return this._isUTC ? offset2 : getDateOffset(this);
        }
      }
      function getSetZone(input, keepLocalTime) {
        if (input != null) {
          if (typeof input !== "string") {
            input = -input;
          }
          this.utcOffset(input, keepLocalTime);
          return this;
        } else {
          return -this.utcOffset();
        }
      }
      function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
      }
      function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
          this.utcOffset(0, keepLocalTime);
          this._isUTC = false;
          if (keepLocalTime) {
            this.subtract(getDateOffset(this), "m");
          }
        }
        return this;
      }
      function setOffsetToParsedOffset() {
        if (this._tzm != null) {
          this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === "string") {
          var tZone = offsetFromString(matchOffset, this._i);
          if (tZone != null) {
            this.utcOffset(tZone);
          } else {
            this.utcOffset(0, true);
          }
        }
        return this;
      }
      function hasAlignedHourOffset(input) {
        if (!this.isValid()) {
          return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;
        return (this.utcOffset() - input) % 60 === 0;
      }
      function isDaylightSavingTime() {
        return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
      }
      function isDaylightSavingTimeShifted() {
        if (!isUndefined(this._isDSTShifted)) {
          return this._isDSTShifted;
        }
        var c = {}, other;
        copyConfig(c, this);
        c = prepareConfig(c);
        if (c._a) {
          other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
          this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
        } else {
          this._isDSTShifted = false;
        }
        return this._isDSTShifted;
      }
      function isLocal() {
        return this.isValid() ? !this._isUTC : false;
      }
      function isUtcOffset() {
        return this.isValid() ? this._isUTC : false;
      }
      function isUtc() {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
      }
      var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
      function createDuration(input, key) {
        var duration = input, match = null, sign2, ret, diffRes;
        if (isDuration(input)) {
          duration = {
            ms: input._milliseconds,
            d: input._days,
            M: input._months
          };
        } else if (isNumber(input) || !isNaN(+input)) {
          duration = {};
          if (key) {
            duration[key] = +input;
          } else {
            duration.milliseconds = +input;
          }
        } else if (match = aspNetRegex.exec(input)) {
          sign2 = match[1] === "-" ? -1 : 1;
          duration = {
            y: 0,
            d: toInt(match[DATE]) * sign2,
            h: toInt(match[HOUR]) * sign2,
            m: toInt(match[MINUTE]) * sign2,
            s: toInt(match[SECOND]) * sign2,
            ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign2
            // the millisecond decimal point is included in the match
          };
        } else if (match = isoRegex.exec(input)) {
          sign2 = match[1] === "-" ? -1 : 1;
          duration = {
            y: parseIso(match[2], sign2),
            M: parseIso(match[3], sign2),
            w: parseIso(match[4], sign2),
            d: parseIso(match[5], sign2),
            h: parseIso(match[6], sign2),
            m: parseIso(match[7], sign2),
            s: parseIso(match[8], sign2)
          };
        } else if (duration == null) {
          duration = {};
        } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
          diffRes = momentsDifference(
            createLocal(duration.from),
            createLocal(duration.to)
          );
          duration = {};
          duration.ms = diffRes.milliseconds;
          duration.M = diffRes.months;
        }
        ret = new Duration(duration);
        if (isDuration(input) && hasOwnProp(input, "_locale")) {
          ret._locale = input._locale;
        }
        if (isDuration(input) && hasOwnProp(input, "_isValid")) {
          ret._isValid = input._isValid;
        }
        return ret;
      }
      createDuration.fn = Duration.prototype;
      createDuration.invalid = createInvalid$1;
      function parseIso(inp, sign2) {
        var res = inp && parseFloat(inp.replace(",", "."));
        return (isNaN(res) ? 0 : res) * sign2;
      }
      function positiveMomentsDifference(base, other) {
        var res = {};
        res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, "M").isAfter(other)) {
          --res.months;
        }
        res.milliseconds = +other - +base.clone().add(res.months, "M");
        return res;
      }
      function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
          return { milliseconds: 0, months: 0 };
        }
        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
          res = positiveMomentsDifference(base, other);
        } else {
          res = positiveMomentsDifference(other, base);
          res.milliseconds = -res.milliseconds;
          res.months = -res.months;
        }
        return res;
      }
      function createAdder(direction, name) {
        return function(val, period) {
          var dur, tmp;
          if (period !== null && !isNaN(+period)) {
            deprecateSimple(
              name,
              "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
            );
            tmp = val;
            val = period;
            period = tmp;
          }
          dur = createDuration(val, period);
          addSubtract(this, dur, direction);
          return this;
        };
      }
      function addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
        if (!mom.isValid()) {
          return;
        }
        updateOffset = updateOffset == null ? true : updateOffset;
        if (months2) {
          setMonth(mom, get2(mom, "Month") + months2 * isAdding);
        }
        if (days2) {
          set$1(mom, "Date", get2(mom, "Date") + days2 * isAdding);
        }
        if (milliseconds2) {
          mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
        }
        if (updateOffset) {
          hooks.updateOffset(mom, days2 || months2);
        }
      }
      var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
      function isString(input) {
        return typeof input === "string" || input instanceof String;
      }
      function isMomentInput(input) {
        return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
      }
      function isMomentInputObject(input) {
        var objectTest = isObject2(input) && !isObjectEmpty(input), propertyTest = false, properties = [
          "years",
          "year",
          "y",
          "months",
          "month",
          "M",
          "days",
          "day",
          "d",
          "dates",
          "date",
          "D",
          "hours",
          "hour",
          "h",
          "minutes",
          "minute",
          "m",
          "seconds",
          "second",
          "s",
          "milliseconds",
          "millisecond",
          "ms"
        ], i2, property, propertyLen = properties.length;
        for (i2 = 0; i2 < propertyLen; i2 += 1) {
          property = properties[i2];
          propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
      }
      function isNumberOrStringArray(input) {
        var arrayTest = isArray3(input), dataTypeTest = false;
        if (arrayTest) {
          dataTypeTest = input.filter(function(item) {
            return !isNumber(item) && isString(input);
          }).length === 0;
        }
        return arrayTest && dataTypeTest;
      }
      function isCalendarSpec(input) {
        var objectTest = isObject2(input) && !isObjectEmpty(input), propertyTest = false, properties = [
          "sameDay",
          "nextDay",
          "lastDay",
          "nextWeek",
          "lastWeek",
          "sameElse"
        ], i2, property;
        for (i2 = 0; i2 < properties.length; i2 += 1) {
          property = properties[i2];
          propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
      }
      function getCalendarFormat(myMoment, now3) {
        var diff2 = myMoment.diff(now3, "days", true);
        return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
      }
      function calendar$1(time, formats) {
        if (arguments.length === 1) {
          if (!arguments[0]) {
            time = void 0;
            formats = void 0;
          } else if (isMomentInput(arguments[0])) {
            time = arguments[0];
            formats = void 0;
          } else if (isCalendarSpec(arguments[0])) {
            formats = arguments[0];
            time = void 0;
          }
        }
        var now3 = time || createLocal(), sod = cloneWithOffset(now3, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction(formats[format2]) ? formats[format2].call(this, now3) : formats[format2]);
        return this.format(
          output || this.localeData().calendar(format2, this, createLocal(now3))
        );
      }
      function clone() {
        return new Moment(this);
      }
      function isAfter(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() > localInput.valueOf();
        } else {
          return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
      }
      function isBefore(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() < localInput.valueOf();
        } else {
          return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
      }
      function isBetween(from4, to2, units, inclusivity) {
        var localFrom = isMoment(from4) ? from4 : createLocal(from4), localTo = isMoment(to2) ? to2 : createLocal(to2);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
          return false;
        }
        inclusivity = inclusivity || "()";
        return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
      }
      function isSame(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input), inputMs;
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() === localInput.valueOf();
        } else {
          inputMs = localInput.valueOf();
          return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
      }
      function isSameOrAfter(input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
      }
      function isSameOrBefore(input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
      }
      function diff(input, units, asFloat) {
        var that, zoneDelta, output;
        if (!this.isValid()) {
          return NaN;
        }
        that = cloneWithOffset(input, this);
        if (!that.isValid()) {
          return NaN;
        }
        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
        units = normalizeUnits(units);
        switch (units) {
          case "year":
            output = monthDiff(this, that) / 12;
            break;
          case "month":
            output = monthDiff(this, that);
            break;
          case "quarter":
            output = monthDiff(this, that) / 3;
            break;
          case "second":
            output = (this - that) / 1e3;
            break;
          case "minute":
            output = (this - that) / 6e4;
            break;
          case "hour":
            output = (this - that) / 36e5;
            break;
          case "day":
            output = (this - that - zoneDelta) / 864e5;
            break;
          case "week":
            output = (this - that - zoneDelta) / 6048e5;
            break;
          default:
            output = this - that;
        }
        return asFloat ? output : absFloor(output);
      }
      function monthDiff(a, b) {
        if (a.date() < b.date()) {
          return -monthDiff(b, a);
        }
        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
        if (b - anchor < 0) {
          anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
          adjust = (b - anchor) / (anchor - anchor2);
        } else {
          anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
          adjust = (b - anchor) / (anchor2 - anchor);
        }
        return -(wholeMonthDiff + adjust) || 0;
      }
      hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
      hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
      function toString() {
        return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
      }
      function toISOString(keepOffset) {
        if (!this.isValid()) {
          return null;
        }
        var utc = keepOffset !== true, m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
          return formatMoment(
            m,
            utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
          );
        }
        if (isFunction(Date.prototype.toISOString)) {
          if (utc) {
            return this.toDate().toISOString();
          } else {
            return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m, "Z"));
          }
        }
        return formatMoment(
          m,
          utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
        );
      }
      function inspect() {
        if (!this.isValid()) {
          return "moment.invalid(/* " + this._i + " */)";
        }
        var func = "moment", zone = "", prefix, year2, datetime, suffix;
        if (!this.isLocal()) {
          func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
          zone = "Z";
        }
        prefix = "[" + func + '("]';
        year2 = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
        datetime = "-MM-DD[T]HH:mm:ss.SSS";
        suffix = zone + '[")]';
        return this.format(prefix + year2 + datetime + suffix);
      }
      function format(inputString) {
        if (!inputString) {
          inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
      }
      function from3(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      function fromNow(withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
      }
      function to(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      function toNow(withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
      }
      function locale(key) {
        var newLocaleData;
        if (key === void 0) {
          return this._locale._abbr;
        } else {
          newLocaleData = getLocale(key);
          if (newLocaleData != null) {
            this._locale = newLocaleData;
          }
          return this;
        }
      }
      var lang = deprecate(
        "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
        function(key) {
          if (key === void 0) {
            return this.localeData();
          } else {
            return this.locale(key);
          }
        }
      );
      function localeData() {
        return this._locale;
      }
      var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
      function mod$1(dividend, divisor) {
        return (dividend % divisor + divisor) % divisor;
      }
      function localStartOfDate(y, m, d) {
        if (y < 100 && y >= 0) {
          return new Date(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
          return new Date(y, m, d).valueOf();
        }
      }
      function utcStartOfDate(y, m, d) {
        if (y < 100 && y >= 0) {
          return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
          return Date.UTC(y, m, d);
        }
      }
      function startOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === void 0 || units === "millisecond" || !this.isValid()) {
          return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
          case "year":
            time = startOfDate(this.year(), 0, 1);
            break;
          case "quarter":
            time = startOfDate(
              this.year(),
              this.month() - this.month() % 3,
              1
            );
            break;
          case "month":
            time = startOfDate(this.year(), this.month(), 1);
            break;
          case "week":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - this.weekday()
            );
            break;
          case "isoWeek":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - (this.isoWeekday() - 1)
            );
            break;
          case "day":
          case "date":
            time = startOfDate(this.year(), this.month(), this.date());
            break;
          case "hour":
            time = this._d.valueOf();
            time -= mod$1(
              time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
              MS_PER_HOUR
            );
            break;
          case "minute":
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_MINUTE);
            break;
          case "second":
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_SECOND);
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }
      function endOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === void 0 || units === "millisecond" || !this.isValid()) {
          return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
          case "year":
            time = startOfDate(this.year() + 1, 0, 1) - 1;
            break;
          case "quarter":
            time = startOfDate(
              this.year(),
              this.month() - this.month() % 3 + 3,
              1
            ) - 1;
            break;
          case "month":
            time = startOfDate(this.year(), this.month() + 1, 1) - 1;
            break;
          case "week":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - this.weekday() + 7
            ) - 1;
            break;
          case "isoWeek":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - (this.isoWeekday() - 1) + 7
            ) - 1;
            break;
          case "day":
          case "date":
            time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
            break;
          case "hour":
            time = this._d.valueOf();
            time += MS_PER_HOUR - mod$1(
              time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
              MS_PER_HOUR
            ) - 1;
            break;
          case "minute":
            time = this._d.valueOf();
            time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
            break;
          case "second":
            time = this._d.valueOf();
            time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }
      function valueOf() {
        return this._d.valueOf() - (this._offset || 0) * 6e4;
      }
      function unix() {
        return Math.floor(this.valueOf() / 1e3);
      }
      function toDate() {
        return new Date(this.valueOf());
      }
      function toArray() {
        var m = this;
        return [
          m.year(),
          m.month(),
          m.date(),
          m.hour(),
          m.minute(),
          m.second(),
          m.millisecond()
        ];
      }
      function toObject() {
        var m = this;
        return {
          years: m.year(),
          months: m.month(),
          date: m.date(),
          hours: m.hours(),
          minutes: m.minutes(),
          seconds: m.seconds(),
          milliseconds: m.milliseconds()
        };
      }
      function toJSON() {
        return this.isValid() ? this.toISOString() : null;
      }
      function isValid$2() {
        return isValid(this);
      }
      function parsingFlags() {
        return extend({}, getParsingFlags(this));
      }
      function invalidAt() {
        return getParsingFlags(this).overflow;
      }
      function creationData() {
        return {
          input: this._i,
          format: this._f,
          locale: this._locale,
          isUTC: this._isUTC,
          strict: this._strict
        };
      }
      addFormatToken("N", 0, 0, "eraAbbr");
      addFormatToken("NN", 0, 0, "eraAbbr");
      addFormatToken("NNN", 0, 0, "eraAbbr");
      addFormatToken("NNNN", 0, 0, "eraName");
      addFormatToken("NNNNN", 0, 0, "eraNarrow");
      addFormatToken("y", ["y", 1], "yo", "eraYear");
      addFormatToken("y", ["yy", 2], 0, "eraYear");
      addFormatToken("y", ["yyy", 3], 0, "eraYear");
      addFormatToken("y", ["yyyy", 4], 0, "eraYear");
      addRegexToken("N", matchEraAbbr);
      addRegexToken("NN", matchEraAbbr);
      addRegexToken("NNN", matchEraAbbr);
      addRegexToken("NNNN", matchEraName);
      addRegexToken("NNNNN", matchEraNarrow);
      addParseToken(
        ["N", "NN", "NNN", "NNNN", "NNNNN"],
        function(input, array, config, token2) {
          var era = config._locale.erasParse(input, token2, config._strict);
          if (era) {
            getParsingFlags(config).era = era;
          } else {
            getParsingFlags(config).invalidEra = input;
          }
        }
      );
      addRegexToken("y", matchUnsigned);
      addRegexToken("yy", matchUnsigned);
      addRegexToken("yyy", matchUnsigned);
      addRegexToken("yyyy", matchUnsigned);
      addRegexToken("yo", matchEraYearOrdinal);
      addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
      addParseToken(["yo"], function(input, array, config, token2) {
        var match;
        if (config._locale._eraYearOrdinalRegex) {
          match = input.match(config._locale._eraYearOrdinalRegex);
        }
        if (config._locale.eraYearOrdinalParse) {
          array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
        } else {
          array[YEAR] = parseInt(input, 10);
        }
      });
      function localeEras(m, format2) {
        var i2, l, date, eras = this._eras || getLocale("en")._eras;
        for (i2 = 0, l = eras.length; i2 < l; ++i2) {
          switch (typeof eras[i2].since) {
            case "string":
              date = hooks(eras[i2].since).startOf("day");
              eras[i2].since = date.valueOf();
              break;
          }
          switch (typeof eras[i2].until) {
            case "undefined":
              eras[i2].until = Infinity;
              break;
            case "string":
              date = hooks(eras[i2].until).startOf("day").valueOf();
              eras[i2].until = date.valueOf();
              break;
          }
        }
        return eras;
      }
      function localeErasParse(eraName, format2, strict) {
        var i2, l, eras = this.eras(), name, abbr, narrow;
        eraName = eraName.toUpperCase();
        for (i2 = 0, l = eras.length; i2 < l; ++i2) {
          name = eras[i2].name.toUpperCase();
          abbr = eras[i2].abbr.toUpperCase();
          narrow = eras[i2].narrow.toUpperCase();
          if (strict) {
            switch (format2) {
              case "N":
              case "NN":
              case "NNN":
                if (abbr === eraName) {
                  return eras[i2];
                }
                break;
              case "NNNN":
                if (name === eraName) {
                  return eras[i2];
                }
                break;
              case "NNNNN":
                if (narrow === eraName) {
                  return eras[i2];
                }
                break;
            }
          } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
            return eras[i2];
          }
        }
      }
      function localeErasConvertYear(era, year2) {
        var dir = era.since <= era.until ? 1 : -1;
        if (year2 === void 0) {
          return hooks(era.since).year();
        } else {
          return hooks(era.since).year() + (year2 - era.offset) * dir;
        }
      }
      function getEraName() {
        var i2, l, val, eras = this.localeData().eras();
        for (i2 = 0, l = eras.length; i2 < l; ++i2) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i2].since <= val && val <= eras[i2].until) {
            return eras[i2].name;
          }
          if (eras[i2].until <= val && val <= eras[i2].since) {
            return eras[i2].name;
          }
        }
        return "";
      }
      function getEraNarrow() {
        var i2, l, val, eras = this.localeData().eras();
        for (i2 = 0, l = eras.length; i2 < l; ++i2) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i2].since <= val && val <= eras[i2].until) {
            return eras[i2].narrow;
          }
          if (eras[i2].until <= val && val <= eras[i2].since) {
            return eras[i2].narrow;
          }
        }
        return "";
      }
      function getEraAbbr() {
        var i2, l, val, eras = this.localeData().eras();
        for (i2 = 0, l = eras.length; i2 < l; ++i2) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i2].since <= val && val <= eras[i2].until) {
            return eras[i2].abbr;
          }
          if (eras[i2].until <= val && val <= eras[i2].since) {
            return eras[i2].abbr;
          }
        }
        return "";
      }
      function getEraYear() {
        var i2, l, dir, val, eras = this.localeData().eras();
        for (i2 = 0, l = eras.length; i2 < l; ++i2) {
          dir = eras[i2].since <= eras[i2].until ? 1 : -1;
          val = this.clone().startOf("day").valueOf();
          if (eras[i2].since <= val && val <= eras[i2].until || eras[i2].until <= val && val <= eras[i2].since) {
            return (this.year() - hooks(eras[i2].since).year()) * dir + eras[i2].offset;
          }
        }
        return this.year();
      }
      function erasNameRegex(isStrict) {
        if (!hasOwnProp(this, "_erasNameRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasNameRegex : this._erasRegex;
      }
      function erasAbbrRegex(isStrict) {
        if (!hasOwnProp(this, "_erasAbbrRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasAbbrRegex : this._erasRegex;
      }
      function erasNarrowRegex(isStrict) {
        if (!hasOwnProp(this, "_erasNarrowRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasNarrowRegex : this._erasRegex;
      }
      function matchEraAbbr(isStrict, locale2) {
        return locale2.erasAbbrRegex(isStrict);
      }
      function matchEraName(isStrict, locale2) {
        return locale2.erasNameRegex(isStrict);
      }
      function matchEraNarrow(isStrict, locale2) {
        return locale2.erasNarrowRegex(isStrict);
      }
      function matchEraYearOrdinal(isStrict, locale2) {
        return locale2._eraYearOrdinalRegex || matchUnsigned;
      }
      function computeErasParse() {
        var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i2, l, eras = this.eras();
        for (i2 = 0, l = eras.length; i2 < l; ++i2) {
          namePieces.push(regexEscape(eras[i2].name));
          abbrPieces.push(regexEscape(eras[i2].abbr));
          narrowPieces.push(regexEscape(eras[i2].narrow));
          mixedPieces.push(regexEscape(eras[i2].name));
          mixedPieces.push(regexEscape(eras[i2].abbr));
          mixedPieces.push(regexEscape(eras[i2].narrow));
        }
        this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
        this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
        this._erasNarrowRegex = new RegExp(
          "^(" + narrowPieces.join("|") + ")",
          "i"
        );
      }
      addFormatToken(0, ["gg", 2], 0, function() {
        return this.weekYear() % 100;
      });
      addFormatToken(0, ["GG", 2], 0, function() {
        return this.isoWeekYear() % 100;
      });
      function addWeekYearFormatToken(token2, getter) {
        addFormatToken(0, [token2, token2.length], 0, getter);
      }
      addWeekYearFormatToken("gggg", "weekYear");
      addWeekYearFormatToken("ggggg", "weekYear");
      addWeekYearFormatToken("GGGG", "isoWeekYear");
      addWeekYearFormatToken("GGGGG", "isoWeekYear");
      addUnitAlias("weekYear", "gg");
      addUnitAlias("isoWeekYear", "GG");
      addUnitPriority("weekYear", 1);
      addUnitPriority("isoWeekYear", 1);
      addRegexToken("G", matchSigned);
      addRegexToken("g", matchSigned);
      addRegexToken("GG", match1to2, match2);
      addRegexToken("gg", match1to2, match2);
      addRegexToken("GGGG", match1to4, match4);
      addRegexToken("gggg", match1to4, match4);
      addRegexToken("GGGGG", match1to6, match6);
      addRegexToken("ggggg", match1to6, match6);
      addWeekParseToken(
        ["gggg", "ggggg", "GGGG", "GGGGG"],
        function(input, week2, config, token2) {
          week2[token2.substr(0, 2)] = toInt(input);
        }
      );
      addWeekParseToken(["gg", "GG"], function(input, week2, config, token2) {
        week2[token2] = hooks.parseTwoDigitYear(input);
      });
      function getSetWeekYear(input) {
        return getSetWeekYearHelper.call(
          this,
          input,
          this.week(),
          this.weekday(),
          this.localeData()._week.dow,
          this.localeData()._week.doy
        );
      }
      function getSetISOWeekYear(input) {
        return getSetWeekYearHelper.call(
          this,
          input,
          this.isoWeek(),
          this.isoWeekday(),
          1,
          4
        );
      }
      function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
      }
      function getISOWeeksInISOWeekYear() {
        return weeksInYear(this.isoWeekYear(), 1, 4);
      }
      function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
      }
      function getWeeksInWeekYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
      }
      function getSetWeekYearHelper(input, week2, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
          return weekOfYear(this, dow, doy).year;
        } else {
          weeksTarget = weeksInYear(input, dow, doy);
          if (week2 > weeksTarget) {
            week2 = weeksTarget;
          }
          return setWeekAll.call(this, input, week2, weekday, dow, doy);
        }
      }
      function setWeekAll(weekYear, week2, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week2, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
      }
      addFormatToken("Q", 0, "Qo", "quarter");
      addUnitAlias("quarter", "Q");
      addUnitPriority("quarter", 7);
      addRegexToken("Q", match1);
      addParseToken("Q", function(input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
      });
      function getSetQuarter(input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
      }
      addFormatToken("D", ["DD", 2], "Do", "date");
      addUnitAlias("date", "D");
      addUnitPriority("date", 9);
      addRegexToken("D", match1to2);
      addRegexToken("DD", match1to2, match2);
      addRegexToken("Do", function(isStrict, locale2) {
        return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
      });
      addParseToken(["D", "DD"], DATE);
      addParseToken("Do", function(input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
      });
      var getSetDayOfMonth = makeGetSet("Date", true);
      addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
      addUnitAlias("dayOfYear", "DDD");
      addUnitPriority("dayOfYear", 4);
      addRegexToken("DDD", match1to3);
      addRegexToken("DDDD", match3);
      addParseToken(["DDD", "DDDD"], function(input, array, config) {
        config._dayOfYear = toInt(input);
      });
      function getSetDayOfYear(input) {
        var dayOfYear = Math.round(
          (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
        ) + 1;
        return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
      }
      addFormatToken("m", ["mm", 2], 0, "minute");
      addUnitAlias("minute", "m");
      addUnitPriority("minute", 14);
      addRegexToken("m", match1to2);
      addRegexToken("mm", match1to2, match2);
      addParseToken(["m", "mm"], MINUTE);
      var getSetMinute = makeGetSet("Minutes", false);
      addFormatToken("s", ["ss", 2], 0, "second");
      addUnitAlias("second", "s");
      addUnitPriority("second", 15);
      addRegexToken("s", match1to2);
      addRegexToken("ss", match1to2, match2);
      addParseToken(["s", "ss"], SECOND);
      var getSetSecond = makeGetSet("Seconds", false);
      addFormatToken("S", 0, 0, function() {
        return ~~(this.millisecond() / 100);
      });
      addFormatToken(0, ["SS", 2], 0, function() {
        return ~~(this.millisecond() / 10);
      });
      addFormatToken(0, ["SSS", 3], 0, "millisecond");
      addFormatToken(0, ["SSSS", 4], 0, function() {
        return this.millisecond() * 10;
      });
      addFormatToken(0, ["SSSSS", 5], 0, function() {
        return this.millisecond() * 100;
      });
      addFormatToken(0, ["SSSSSS", 6], 0, function() {
        return this.millisecond() * 1e3;
      });
      addFormatToken(0, ["SSSSSSS", 7], 0, function() {
        return this.millisecond() * 1e4;
      });
      addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
        return this.millisecond() * 1e5;
      });
      addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
        return this.millisecond() * 1e6;
      });
      addUnitAlias("millisecond", "ms");
      addUnitPriority("millisecond", 16);
      addRegexToken("S", match1to3, match1);
      addRegexToken("SS", match1to3, match2);
      addRegexToken("SSS", match1to3, match3);
      var token, getSetMillisecond;
      for (token = "SSSS"; token.length <= 9; token += "S") {
        addRegexToken(token, matchUnsigned);
      }
      function parseMs(input, array) {
        array[MILLISECOND] = toInt(("0." + input) * 1e3);
      }
      for (token = "S"; token.length <= 9; token += "S") {
        addParseToken(token, parseMs);
      }
      getSetMillisecond = makeGetSet("Milliseconds", false);
      addFormatToken("z", 0, 0, "zoneAbbr");
      addFormatToken("zz", 0, 0, "zoneName");
      function getZoneAbbr() {
        return this._isUTC ? "UTC" : "";
      }
      function getZoneName() {
        return this._isUTC ? "Coordinated Universal Time" : "";
      }
      var proto = Moment.prototype;
      proto.add = add;
      proto.calendar = calendar$1;
      proto.clone = clone;
      proto.diff = diff;
      proto.endOf = endOf;
      proto.format = format;
      proto.from = from3;
      proto.fromNow = fromNow;
      proto.to = to;
      proto.toNow = toNow;
      proto.get = stringGet;
      proto.invalidAt = invalidAt;
      proto.isAfter = isAfter;
      proto.isBefore = isBefore;
      proto.isBetween = isBetween;
      proto.isSame = isSame;
      proto.isSameOrAfter = isSameOrAfter;
      proto.isSameOrBefore = isSameOrBefore;
      proto.isValid = isValid$2;
      proto.lang = lang;
      proto.locale = locale;
      proto.localeData = localeData;
      proto.max = prototypeMax;
      proto.min = prototypeMin;
      proto.parsingFlags = parsingFlags;
      proto.set = stringSet;
      proto.startOf = startOf;
      proto.subtract = subtract;
      proto.toArray = toArray;
      proto.toObject = toObject;
      proto.toDate = toDate;
      proto.toISOString = toISOString;
      proto.inspect = inspect;
      if (typeof Symbol !== "undefined" && Symbol.for != null) {
        proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
          return "Moment<" + this.format() + ">";
        };
      }
      proto.toJSON = toJSON;
      proto.toString = toString;
      proto.unix = unix;
      proto.valueOf = valueOf;
      proto.creationData = creationData;
      proto.eraName = getEraName;
      proto.eraNarrow = getEraNarrow;
      proto.eraAbbr = getEraAbbr;
      proto.eraYear = getEraYear;
      proto.year = getSetYear;
      proto.isLeapYear = getIsLeapYear;
      proto.weekYear = getSetWeekYear;
      proto.isoWeekYear = getSetISOWeekYear;
      proto.quarter = proto.quarters = getSetQuarter;
      proto.month = getSetMonth;
      proto.daysInMonth = getDaysInMonth;
      proto.week = proto.weeks = getSetWeek;
      proto.isoWeek = proto.isoWeeks = getSetISOWeek;
      proto.weeksInYear = getWeeksInYear;
      proto.weeksInWeekYear = getWeeksInWeekYear;
      proto.isoWeeksInYear = getISOWeeksInYear;
      proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
      proto.date = getSetDayOfMonth;
      proto.day = proto.days = getSetDayOfWeek;
      proto.weekday = getSetLocaleDayOfWeek;
      proto.isoWeekday = getSetISODayOfWeek;
      proto.dayOfYear = getSetDayOfYear;
      proto.hour = proto.hours = getSetHour;
      proto.minute = proto.minutes = getSetMinute;
      proto.second = proto.seconds = getSetSecond;
      proto.millisecond = proto.milliseconds = getSetMillisecond;
      proto.utcOffset = getSetOffset;
      proto.utc = setOffsetToUTC;
      proto.local = setOffsetToLocal;
      proto.parseZone = setOffsetToParsedOffset;
      proto.hasAlignedHourOffset = hasAlignedHourOffset;
      proto.isDST = isDaylightSavingTime;
      proto.isLocal = isLocal;
      proto.isUtcOffset = isUtcOffset;
      proto.isUtc = isUtc;
      proto.isUTC = isUtc;
      proto.zoneAbbr = getZoneAbbr;
      proto.zoneName = getZoneName;
      proto.dates = deprecate(
        "dates accessor is deprecated. Use date instead.",
        getSetDayOfMonth
      );
      proto.months = deprecate(
        "months accessor is deprecated. Use month instead",
        getSetMonth
      );
      proto.years = deprecate(
        "years accessor is deprecated. Use year instead",
        getSetYear
      );
      proto.zone = deprecate(
        "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
        getSetZone
      );
      proto.isDSTShifted = deprecate(
        "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
        isDaylightSavingTimeShifted
      );
      function createUnix(input) {
        return createLocal(input * 1e3);
      }
      function createInZone() {
        return createLocal.apply(null, arguments).parseZone();
      }
      function preParsePostFormat(string) {
        return string;
      }
      var proto$1 = Locale.prototype;
      proto$1.calendar = calendar;
      proto$1.longDateFormat = longDateFormat;
      proto$1.invalidDate = invalidDate;
      proto$1.ordinal = ordinal;
      proto$1.preparse = preParsePostFormat;
      proto$1.postformat = preParsePostFormat;
      proto$1.relativeTime = relativeTime;
      proto$1.pastFuture = pastFuture;
      proto$1.set = set;
      proto$1.eras = localeEras;
      proto$1.erasParse = localeErasParse;
      proto$1.erasConvertYear = localeErasConvertYear;
      proto$1.erasAbbrRegex = erasAbbrRegex;
      proto$1.erasNameRegex = erasNameRegex;
      proto$1.erasNarrowRegex = erasNarrowRegex;
      proto$1.months = localeMonths;
      proto$1.monthsShort = localeMonthsShort;
      proto$1.monthsParse = localeMonthsParse;
      proto$1.monthsRegex = monthsRegex;
      proto$1.monthsShortRegex = monthsShortRegex;
      proto$1.week = localeWeek;
      proto$1.firstDayOfYear = localeFirstDayOfYear;
      proto$1.firstDayOfWeek = localeFirstDayOfWeek;
      proto$1.weekdays = localeWeekdays;
      proto$1.weekdaysMin = localeWeekdaysMin;
      proto$1.weekdaysShort = localeWeekdaysShort;
      proto$1.weekdaysParse = localeWeekdaysParse;
      proto$1.weekdaysRegex = weekdaysRegex;
      proto$1.weekdaysShortRegex = weekdaysShortRegex;
      proto$1.weekdaysMinRegex = weekdaysMinRegex;
      proto$1.isPM = localeIsPM;
      proto$1.meridiem = localeMeridiem;
      function get$1(format2, index, field, setter) {
        var locale2 = getLocale(), utc = createUTC().set(setter, index);
        return locale2[field](utc, format2);
      }
      function listMonthsImpl(format2, index, field) {
        if (isNumber(format2)) {
          index = format2;
          format2 = void 0;
        }
        format2 = format2 || "";
        if (index != null) {
          return get$1(format2, index, field, "month");
        }
        var i2, out = [];
        for (i2 = 0; i2 < 12; i2++) {
          out[i2] = get$1(format2, i2, field, "month");
        }
        return out;
      }
      function listWeekdaysImpl(localeSorted, format2, index, field) {
        if (typeof localeSorted === "boolean") {
          if (isNumber(format2)) {
            index = format2;
            format2 = void 0;
          }
          format2 = format2 || "";
        } else {
          format2 = localeSorted;
          index = format2;
          localeSorted = false;
          if (isNumber(format2)) {
            index = format2;
            format2 = void 0;
          }
          format2 = format2 || "";
        }
        var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i2, out = [];
        if (index != null) {
          return get$1(format2, (index + shift) % 7, field, "day");
        }
        for (i2 = 0; i2 < 7; i2++) {
          out[i2] = get$1(format2, (i2 + shift) % 7, field, "day");
        }
        return out;
      }
      function listMonths(format2, index) {
        return listMonthsImpl(format2, index, "months");
      }
      function listMonthsShort(format2, index) {
        return listMonthsImpl(format2, index, "monthsShort");
      }
      function listWeekdays(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdays");
      }
      function listWeekdaysShort(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdaysShort");
      }
      function listWeekdaysMin(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdaysMin");
      }
      getSetGlobalLocale("en", {
        eras: [
          {
            since: "0001-01-01",
            until: Infinity,
            offset: 1,
            name: "Anno Domini",
            narrow: "AD",
            abbr: "AD"
          },
          {
            since: "0000-12-31",
            until: -Infinity,
            offset: 1,
            name: "Before Christ",
            narrow: "BC",
            abbr: "BC"
          }
        ],
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function(number) {
          var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
          return number + output;
        }
      });
      hooks.lang = deprecate(
        "moment.lang is deprecated. Use moment.locale instead.",
        getSetGlobalLocale
      );
      hooks.langData = deprecate(
        "moment.langData is deprecated. Use moment.localeData instead.",
        getLocale
      );
      var mathAbs = Math.abs;
      function abs2() {
        var data = this._data;
        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);
        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);
        return this;
      }
      function addSubtract$1(duration, input, value, direction) {
        var other = createDuration(input, value);
        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;
        return duration._bubble();
      }
      function add$1(input, value) {
        return addSubtract$1(this, input, value, 1);
      }
      function subtract$1(input, value) {
        return addSubtract$1(this, input, value, -1);
      }
      function absCeil(number) {
        if (number < 0) {
          return Math.floor(number);
        } else {
          return Math.ceil(number);
        }
      }
      function bubble() {
        var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
        if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
          milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
          days2 = 0;
          months2 = 0;
        }
        data.milliseconds = milliseconds2 % 1e3;
        seconds2 = absFloor(milliseconds2 / 1e3);
        data.seconds = seconds2 % 60;
        minutes2 = absFloor(seconds2 / 60);
        data.minutes = minutes2 % 60;
        hours2 = absFloor(minutes2 / 60);
        data.hours = hours2 % 24;
        days2 += absFloor(hours2 / 24);
        monthsFromDays = absFloor(daysToMonths(days2));
        months2 += monthsFromDays;
        days2 -= absCeil(monthsToDays(monthsFromDays));
        years2 = absFloor(months2 / 12);
        months2 %= 12;
        data.days = days2;
        data.months = months2;
        data.years = years2;
        return this;
      }
      function daysToMonths(days2) {
        return days2 * 4800 / 146097;
      }
      function monthsToDays(months2) {
        return months2 * 146097 / 4800;
      }
      function as(units) {
        if (!this.isValid()) {
          return NaN;
        }
        var days2, months2, milliseconds2 = this._milliseconds;
        units = normalizeUnits(units);
        if (units === "month" || units === "quarter" || units === "year") {
          days2 = this._days + milliseconds2 / 864e5;
          months2 = this._months + daysToMonths(days2);
          switch (units) {
            case "month":
              return months2;
            case "quarter":
              return months2 / 3;
            case "year":
              return months2 / 12;
          }
        } else {
          days2 = this._days + Math.round(monthsToDays(this._months));
          switch (units) {
            case "week":
              return days2 / 7 + milliseconds2 / 6048e5;
            case "day":
              return days2 + milliseconds2 / 864e5;
            case "hour":
              return days2 * 24 + milliseconds2 / 36e5;
            case "minute":
              return days2 * 1440 + milliseconds2 / 6e4;
            case "second":
              return days2 * 86400 + milliseconds2 / 1e3;
            case "millisecond":
              return Math.floor(days2 * 864e5) + milliseconds2;
            default:
              throw new Error("Unknown unit " + units);
          }
        }
      }
      function valueOf$1() {
        if (!this.isValid()) {
          return NaN;
        }
        return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
      }
      function makeAs(alias) {
        return function() {
          return this.as(alias);
        };
      }
      var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y");
      function clone$1() {
        return createDuration(this);
      }
      function get$2(units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + "s"]() : NaN;
      }
      function makeGetter(name) {
        return function() {
          return this.isValid() ? this._data[name] : NaN;
        };
      }
      var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
      function weeks() {
        return absFloor(this.days() / 7);
      }
      var round = Math.round, thresholds = {
        ss: 44,
        // a few seconds to seconds
        s: 45,
        // seconds to minute
        m: 45,
        // minutes to hour
        h: 22,
        // hours to day
        d: 26,
        // days to month/week
        w: null,
        // weeks to month
        M: 11
        // months to year
      };
      function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale2) {
        return locale2.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
      }
      function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
        var duration = createDuration(posNegDuration).abs(), seconds2 = round(duration.as("s")), minutes2 = round(duration.as("m")), hours2 = round(duration.as("h")), days2 = round(duration.as("d")), months2 = round(duration.as("M")), weeks2 = round(duration.as("w")), years2 = round(duration.as("y")), a = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
        if (thresholds2.w != null) {
          a = a || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
        }
        a = a || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale2;
        return substituteTimeAgo.apply(null, a);
      }
      function getSetRelativeTimeRounding(roundingFunction) {
        if (roundingFunction === void 0) {
          return round;
        }
        if (typeof roundingFunction === "function") {
          round = roundingFunction;
          return true;
        }
        return false;
      }
      function getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === void 0) {
          return false;
        }
        if (limit === void 0) {
          return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === "s") {
          thresholds.ss = limit - 1;
        }
        return true;
      }
      function humanize(argWithSuffix, argThresholds) {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var withSuffix = false, th = thresholds, locale2, output;
        if (typeof argWithSuffix === "object") {
          argThresholds = argWithSuffix;
          argWithSuffix = false;
        }
        if (typeof argWithSuffix === "boolean") {
          withSuffix = argWithSuffix;
        }
        if (typeof argThresholds === "object") {
          th = Object.assign({}, thresholds, argThresholds);
          if (argThresholds.s != null && argThresholds.ss == null) {
            th.ss = argThresholds.s - 1;
          }
        }
        locale2 = this.localeData();
        output = relativeTime$1(this, !withSuffix, th, locale2);
        if (withSuffix) {
          output = locale2.pastFuture(+this, output);
        }
        return locale2.postformat(output);
      }
      var abs$1 = Math.abs;
      function sign(x) {
        return (x > 0) - (x < 0) || +x;
      }
      function toISOString$1() {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s2, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
        if (!total) {
          return "P0D";
        }
        minutes2 = absFloor(seconds2 / 60);
        hours2 = absFloor(minutes2 / 60);
        seconds2 %= 60;
        minutes2 %= 60;
        years2 = absFloor(months2 / 12);
        months2 %= 12;
        s2 = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
        totalSign = total < 0 ? "-" : "";
        ymSign = sign(this._months) !== sign(total) ? "-" : "";
        daysSign = sign(this._days) !== sign(total) ? "-" : "";
        hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
        return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s2 + "S" : "");
      }
      var proto$2 = Duration.prototype;
      proto$2.isValid = isValid$1;
      proto$2.abs = abs2;
      proto$2.add = add$1;
      proto$2.subtract = subtract$1;
      proto$2.as = as;
      proto$2.asMilliseconds = asMilliseconds;
      proto$2.asSeconds = asSeconds;
      proto$2.asMinutes = asMinutes;
      proto$2.asHours = asHours;
      proto$2.asDays = asDays;
      proto$2.asWeeks = asWeeks;
      proto$2.asMonths = asMonths;
      proto$2.asQuarters = asQuarters;
      proto$2.asYears = asYears;
      proto$2.valueOf = valueOf$1;
      proto$2._bubble = bubble;
      proto$2.clone = clone$1;
      proto$2.get = get$2;
      proto$2.milliseconds = milliseconds;
      proto$2.seconds = seconds;
      proto$2.minutes = minutes;
      proto$2.hours = hours;
      proto$2.days = days;
      proto$2.weeks = weeks;
      proto$2.months = months;
      proto$2.years = years;
      proto$2.humanize = humanize;
      proto$2.toISOString = toISOString$1;
      proto$2.toString = toISOString$1;
      proto$2.toJSON = toISOString$1;
      proto$2.locale = locale;
      proto$2.localeData = localeData;
      proto$2.toIsoString = deprecate(
        "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
        toISOString$1
      );
      proto$2.lang = lang;
      addFormatToken("X", 0, 0, "unix");
      addFormatToken("x", 0, 0, "valueOf");
      addRegexToken("x", matchSigned);
      addRegexToken("X", matchTimestamp);
      addParseToken("X", function(input, array, config) {
        config._d = new Date(parseFloat(input) * 1e3);
      });
      addParseToken("x", function(input, array, config) {
        config._d = new Date(toInt(input));
      });
      hooks.version = "2.29.4";
      setHookCallback(createLocal);
      hooks.fn = proto;
      hooks.min = min3;
      hooks.max = max3;
      hooks.now = now2;
      hooks.utc = createUTC;
      hooks.unix = createUnix;
      hooks.months = listMonths;
      hooks.isDate = isDate;
      hooks.locale = getSetGlobalLocale;
      hooks.invalid = createInvalid;
      hooks.duration = createDuration;
      hooks.isMoment = isMoment;
      hooks.weekdays = listWeekdays;
      hooks.parseZone = createInZone;
      hooks.localeData = getLocale;
      hooks.isDuration = isDuration;
      hooks.monthsShort = listMonthsShort;
      hooks.weekdaysMin = listWeekdaysMin;
      hooks.defineLocale = defineLocale;
      hooks.updateLocale = updateLocale;
      hooks.locales = listLocales;
      hooks.weekdaysShort = listWeekdaysShort;
      hooks.normalizeUnits = normalizeUnits;
      hooks.relativeTimeRounding = getSetRelativeTimeRounding;
      hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
      hooks.calendarFormat = getCalendarFormat;
      hooks.prototype = proto;
      hooks.HTML5_FMT = {
        DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
        // <input type="datetime-local" />
        DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
        // <input type="datetime-local" step="1" />
        DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
        // <input type="datetime-local" step="0.001" />
        DATE: "YYYY-MM-DD",
        // <input type="date" />
        TIME: "HH:mm",
        // <input type="time" />
        TIME_SECONDS: "HH:mm:ss",
        // <input type="time" step="1" />
        TIME_MS: "HH:mm:ss.SSS",
        // <input type="time" step="0.001" />
        WEEK: "GGGG-[W]WW",
        // <input type="week" />
        MONTH: "YYYY-MM"
        // <input type="month" />
      };
      return hooks;
    });
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => Live
});
module.exports = __toCommonJS(main_exports);
var import_obsidian24 = require("obsidian");
var import_obsidian25 = require("obsidian");

// node_modules/lib0/map.js
var create = () => /* @__PURE__ */ new Map();
var copy = (m) => {
  const r = create();
  m.forEach((v, k) => {
    r.set(k, v);
  });
  return r;
};
var setIfUndefined = (map3, key, createT) => {
  let set = map3.get(key);
  if (set === void 0) {
    map3.set(key, set = createT());
  }
  return set;
};
var map = (m, f) => {
  const res = [];
  for (const [key, value] of m) {
    res.push(f(value, key));
  }
  return res;
};
var any = (m, f) => {
  for (const [key, value] of m) {
    if (f(value, key)) {
      return true;
    }
  }
  return false;
};

// node_modules/lib0/set.js
var create2 = () => /* @__PURE__ */ new Set();

// node_modules/lib0/array.js
var last = (arr) => arr[arr.length - 1];
var appendTo = (dest, src) => {
  for (let i2 = 0; i2 < src.length; i2++) {
    dest.push(src[i2]);
  }
};
var from = Array.from;
var isArray = Array.isArray;

// node_modules/lib0/observable.js
var ObservableV2 = class {
  constructor() {
    this._observers = create();
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  on(name, f) {
    setIfUndefined(
      this._observers,
      /** @type {string} */
      name,
      create2
    ).add(f);
    return f;
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  once(name, f) {
    const _f = (...args3) => {
      this.off(
        name,
        /** @type {any} */
        _f
      );
      f(...args3);
    };
    this.on(
      name,
      /** @type {any} */
      _f
    );
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  off(name, f) {
    const observers = this._observers.get(name);
    if (observers !== void 0) {
      observers.delete(f);
      if (observers.size === 0) {
        this._observers.delete(name);
      }
    }
  }
  /**
   * Emit a named event. All registered event listeners that listen to the
   * specified name will receive the event.
   *
   * @todo This should catch exceptions
   *
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name The event name.
   * @param {Parameters<EVENTS[NAME]>} args The arguments that are applied to the event listener.
   */
  emit(name, args3) {
    return from((this._observers.get(name) || create()).values()).forEach((f) => f(...args3));
  }
  destroy() {
    this._observers = create();
  }
};
var Observable = class {
  constructor() {
    this._observers = create();
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  on(name, f) {
    setIfUndefined(this._observers, name, create2).add(f);
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  once(name, f) {
    const _f = (...args3) => {
      this.off(name, _f);
      f(...args3);
    };
    this.on(name, _f);
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  off(name, f) {
    const observers = this._observers.get(name);
    if (observers !== void 0) {
      observers.delete(f);
      if (observers.size === 0) {
        this._observers.delete(name);
      }
    }
  }
  /**
   * Emit a named event. All registered event listeners that listen to the
   * specified name will receive the event.
   *
   * @todo This should catch exceptions
   *
   * @param {N} name The event name.
   * @param {Array<any>} args The arguments that are applied to the event listener.
   */
  emit(name, args3) {
    return from((this._observers.get(name) || create()).values()).forEach((f) => f(...args3));
  }
  destroy() {
    this._observers = create();
  }
};

// node_modules/lib0/math.js
var floor = Math.floor;
var abs = Math.abs;
var min = (a, b) => a < b ? a : b;
var max = (a, b) => a > b ? a : b;
var isNaN2 = Number.isNaN;
var isNegativeZero = (n) => n !== 0 ? n < 0 : 1 / n < 0;

// node_modules/lib0/binary.js
var BIT1 = 1;
var BIT2 = 2;
var BIT3 = 4;
var BIT4 = 8;
var BIT6 = 32;
var BIT7 = 64;
var BIT8 = 128;
var BIT18 = 1 << 17;
var BIT19 = 1 << 18;
var BIT20 = 1 << 19;
var BIT21 = 1 << 20;
var BIT22 = 1 << 21;
var BIT23 = 1 << 22;
var BIT24 = 1 << 23;
var BIT25 = 1 << 24;
var BIT26 = 1 << 25;
var BIT27 = 1 << 26;
var BIT28 = 1 << 27;
var BIT29 = 1 << 28;
var BIT30 = 1 << 29;
var BIT31 = 1 << 30;
var BIT32 = 1 << 31;
var BITS5 = 31;
var BITS6 = 63;
var BITS7 = 127;
var BITS17 = BIT18 - 1;
var BITS18 = BIT19 - 1;
var BITS19 = BIT20 - 1;
var BITS20 = BIT21 - 1;
var BITS21 = BIT22 - 1;
var BITS22 = BIT23 - 1;
var BITS23 = BIT24 - 1;
var BITS24 = BIT25 - 1;
var BITS25 = BIT26 - 1;
var BITS26 = BIT27 - 1;
var BITS27 = BIT28 - 1;
var BITS28 = BIT29 - 1;
var BITS29 = BIT30 - 1;
var BITS30 = BIT31 - 1;
var BITS31 = 2147483647;

// node_modules/lib0/number.js
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;
var MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER;
var LOWEST_INT32 = 1 << 31;
var isInteger = Number.isInteger || ((num) => typeof num === "number" && isFinite(num) && floor(num) === num);
var isNaN3 = Number.isNaN;
var parseInt2 = Number.parseInt;

// node_modules/lib0/string.js
var fromCharCode = String.fromCharCode;
var fromCodePoint = String.fromCodePoint;
var MAX_UTF16_CHARACTER = fromCharCode(65535);
var toLowerCase = (s2) => s2.toLowerCase();
var trimLeftRegex = /^\s*/g;
var trimLeft = (s2) => s2.replace(trimLeftRegex, "");
var fromCamelCaseRegex = /([A-Z])/g;
var fromCamelCase = (s2, separator) => trimLeft(s2.replace(fromCamelCaseRegex, (match) => `${separator}${toLowerCase(match)}`));
var _encodeUtf8Polyfill = (str) => {
  const encodedString = unescape(encodeURIComponent(str));
  const len = encodedString.length;
  const buf = new Uint8Array(len);
  for (let i2 = 0; i2 < len; i2++) {
    buf[i2] = /** @type {number} */
    encodedString.codePointAt(i2);
  }
  return buf;
};
var utf8TextEncoder = (
  /** @type {TextEncoder} */
  typeof TextEncoder !== "undefined" ? new TextEncoder() : null
);
var _encodeUtf8Native = (str) => utf8TextEncoder.encode(str);
var encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill;
var utf8TextDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf-8", { fatal: true, ignoreBOM: true });
if (utf8TextDecoder && utf8TextDecoder.decode(new Uint8Array()).length === 1) {
  utf8TextDecoder = null;
}

// node_modules/lib0/encoding.js
var Encoder = class {
  constructor() {
    this.cpos = 0;
    this.cbuf = new Uint8Array(100);
    this.bufs = [];
  }
};
var createEncoder = () => new Encoder();
var length = (encoder2) => {
  let len = encoder2.cpos;
  for (let i2 = 0; i2 < encoder2.bufs.length; i2++) {
    len += encoder2.bufs[i2].length;
  }
  return len;
};
var toUint8Array = (encoder2) => {
  const uint8arr = new Uint8Array(length(encoder2));
  let curPos = 0;
  for (let i2 = 0; i2 < encoder2.bufs.length; i2++) {
    const d = encoder2.bufs[i2];
    uint8arr.set(d, curPos);
    curPos += d.length;
  }
  uint8arr.set(new Uint8Array(encoder2.cbuf.buffer, 0, encoder2.cpos), curPos);
  return uint8arr;
};
var verifyLen = (encoder2, len) => {
  const bufferLen = encoder2.cbuf.length;
  if (bufferLen - encoder2.cpos < len) {
    encoder2.bufs.push(new Uint8Array(encoder2.cbuf.buffer, 0, encoder2.cpos));
    encoder2.cbuf = new Uint8Array(max(bufferLen, len) * 2);
    encoder2.cpos = 0;
  }
};
var write = (encoder2, num) => {
  const bufferLen = encoder2.cbuf.length;
  if (encoder2.cpos === bufferLen) {
    encoder2.bufs.push(encoder2.cbuf);
    encoder2.cbuf = new Uint8Array(bufferLen * 2);
    encoder2.cpos = 0;
  }
  encoder2.cbuf[encoder2.cpos++] = num;
};
var writeUint8 = write;
var writeVarUint = (encoder2, num) => {
  while (num > BITS7) {
    write(encoder2, BIT8 | BITS7 & num);
    num = floor(num / 128);
  }
  write(encoder2, BITS7 & num);
};
var writeVarInt = (encoder2, num) => {
  const isNegative = isNegativeZero(num);
  if (isNegative) {
    num = -num;
  }
  write(encoder2, (num > BITS6 ? BIT8 : 0) | (isNegative ? BIT7 : 0) | BITS6 & num);
  num = floor(num / 64);
  while (num > 0) {
    write(encoder2, (num > BITS7 ? BIT8 : 0) | BITS7 & num);
    num = floor(num / 128);
  }
};
var _strBuffer = new Uint8Array(3e4);
var _maxStrBSize = _strBuffer.length / 3;
var _writeVarStringNative = (encoder2, str) => {
  if (str.length < _maxStrBSize) {
    const written = utf8TextEncoder.encodeInto(str, _strBuffer).written || 0;
    writeVarUint(encoder2, written);
    for (let i2 = 0; i2 < written; i2++) {
      write(encoder2, _strBuffer[i2]);
    }
  } else {
    writeVarUint8Array(encoder2, encodeUtf8(str));
  }
};
var _writeVarStringPolyfill = (encoder2, str) => {
  const encodedString = unescape(encodeURIComponent(str));
  const len = encodedString.length;
  writeVarUint(encoder2, len);
  for (let i2 = 0; i2 < len; i2++) {
    write(
      encoder2,
      /** @type {number} */
      encodedString.codePointAt(i2)
    );
  }
};
var writeVarString = utf8TextEncoder && /** @type {any} */
utf8TextEncoder.encodeInto ? _writeVarStringNative : _writeVarStringPolyfill;
var writeUint8Array = (encoder2, uint8Array) => {
  const bufferLen = encoder2.cbuf.length;
  const cpos = encoder2.cpos;
  const leftCopyLen = min(bufferLen - cpos, uint8Array.length);
  const rightCopyLen = uint8Array.length - leftCopyLen;
  encoder2.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos);
  encoder2.cpos += leftCopyLen;
  if (rightCopyLen > 0) {
    encoder2.bufs.push(encoder2.cbuf);
    encoder2.cbuf = new Uint8Array(max(bufferLen * 2, rightCopyLen));
    encoder2.cbuf.set(uint8Array.subarray(leftCopyLen));
    encoder2.cpos = rightCopyLen;
  }
};
var writeVarUint8Array = (encoder2, uint8Array) => {
  writeVarUint(encoder2, uint8Array.byteLength);
  writeUint8Array(encoder2, uint8Array);
};
var writeOnDataView = (encoder2, len) => {
  verifyLen(encoder2, len);
  const dview = new DataView(encoder2.cbuf.buffer, encoder2.cpos, len);
  encoder2.cpos += len;
  return dview;
};
var writeFloat32 = (encoder2, num) => writeOnDataView(encoder2, 4).setFloat32(0, num, false);
var writeFloat64 = (encoder2, num) => writeOnDataView(encoder2, 8).setFloat64(0, num, false);
var writeBigInt64 = (encoder2, num) => (
  /** @type {any} */
  writeOnDataView(encoder2, 8).setBigInt64(0, num, false)
);
var floatTestBed = new DataView(new ArrayBuffer(4));
var isFloat32 = (num) => {
  floatTestBed.setFloat32(0, num);
  return floatTestBed.getFloat32(0) === num;
};
var writeAny = (encoder2, data) => {
  switch (typeof data) {
    case "string":
      write(encoder2, 119);
      writeVarString(encoder2, data);
      break;
    case "number":
      if (isInteger(data) && abs(data) <= BITS31) {
        write(encoder2, 125);
        writeVarInt(encoder2, data);
      } else if (isFloat32(data)) {
        write(encoder2, 124);
        writeFloat32(encoder2, data);
      } else {
        write(encoder2, 123);
        writeFloat64(encoder2, data);
      }
      break;
    case "bigint":
      write(encoder2, 122);
      writeBigInt64(encoder2, data);
      break;
    case "object":
      if (data === null) {
        write(encoder2, 126);
      } else if (isArray(data)) {
        write(encoder2, 117);
        writeVarUint(encoder2, data.length);
        for (let i2 = 0; i2 < data.length; i2++) {
          writeAny(encoder2, data[i2]);
        }
      } else if (data instanceof Uint8Array) {
        write(encoder2, 116);
        writeVarUint8Array(encoder2, data);
      } else {
        write(encoder2, 118);
        const keys2 = Object.keys(data);
        writeVarUint(encoder2, keys2.length);
        for (let i2 = 0; i2 < keys2.length; i2++) {
          const key = keys2[i2];
          writeVarString(encoder2, key);
          writeAny(encoder2, data[key]);
        }
      }
      break;
    case "boolean":
      write(encoder2, data ? 120 : 121);
      break;
    default:
      write(encoder2, 127);
  }
};
var RleEncoder = class extends Encoder {
  /**
   * @param {function(Encoder, T):void} writer
   */
  constructor(writer) {
    super();
    this.w = writer;
    this.s = null;
    this.count = 0;
  }
  /**
   * @param {T} v
   */
  write(v) {
    if (this.s === v) {
      this.count++;
    } else {
      if (this.count > 0) {
        writeVarUint(this, this.count - 1);
      }
      this.count = 1;
      this.w(this, v);
      this.s = v;
    }
  }
};
var flushUintOptRleEncoder = (encoder2) => {
  if (encoder2.count > 0) {
    writeVarInt(encoder2.encoder, encoder2.count === 1 ? encoder2.s : -encoder2.s);
    if (encoder2.count > 1) {
      writeVarUint(encoder2.encoder, encoder2.count - 2);
    }
  }
};
var UintOptRleEncoder = class {
  constructor() {
    this.encoder = new Encoder();
    this.s = 0;
    this.count = 0;
  }
  /**
   * @param {number} v
   */
  write(v) {
    if (this.s === v) {
      this.count++;
    } else {
      flushUintOptRleEncoder(this);
      this.count = 1;
      this.s = v;
    }
  }
  /**
   * Flush the encoded state and transform this to a Uint8Array.
   *
   * Note that this should only be called once.
   */
  toUint8Array() {
    flushUintOptRleEncoder(this);
    return toUint8Array(this.encoder);
  }
};
var flushIntDiffOptRleEncoder = (encoder2) => {
  if (encoder2.count > 0) {
    const encodedDiff = encoder2.diff * 2 + (encoder2.count === 1 ? 0 : 1);
    writeVarInt(encoder2.encoder, encodedDiff);
    if (encoder2.count > 1) {
      writeVarUint(encoder2.encoder, encoder2.count - 2);
    }
  }
};
var IntDiffOptRleEncoder = class {
  constructor() {
    this.encoder = new Encoder();
    this.s = 0;
    this.count = 0;
    this.diff = 0;
  }
  /**
   * @param {number} v
   */
  write(v) {
    if (this.diff === v - this.s) {
      this.s = v;
      this.count++;
    } else {
      flushIntDiffOptRleEncoder(this);
      this.count = 1;
      this.diff = v - this.s;
      this.s = v;
    }
  }
  /**
   * Flush the encoded state and transform this to a Uint8Array.
   *
   * Note that this should only be called once.
   */
  toUint8Array() {
    flushIntDiffOptRleEncoder(this);
    return toUint8Array(this.encoder);
  }
};
var StringEncoder = class {
  constructor() {
    this.sarr = [];
    this.s = "";
    this.lensE = new UintOptRleEncoder();
  }
  /**
   * @param {string} string
   */
  write(string) {
    this.s += string;
    if (this.s.length > 19) {
      this.sarr.push(this.s);
      this.s = "";
    }
    this.lensE.write(string.length);
  }
  toUint8Array() {
    const encoder2 = new Encoder();
    this.sarr.push(this.s);
    this.s = "";
    writeVarString(encoder2, this.sarr.join(""));
    writeUint8Array(encoder2, this.lensE.toUint8Array());
    return toUint8Array(encoder2);
  }
};

// node_modules/lib0/error.js
var create3 = (s2) => new Error(s2);
var methodUnimplemented = () => {
  throw create3("Method unimplemented");
};
var unexpectedCase = () => {
  throw create3("Unexpected case");
};

// node_modules/lib0/decoding.js
var errorUnexpectedEndOfArray = create3("Unexpected end of array");
var errorIntegerOutOfRange = create3("Integer out of Range");
var Decoder = class {
  /**
   * @param {Uint8Array} uint8Array Binary data to decode
   */
  constructor(uint8Array) {
    this.arr = uint8Array;
    this.pos = 0;
  }
};
var createDecoder = (uint8Array) => new Decoder(uint8Array);
var hasContent = (decoder2) => decoder2.pos !== decoder2.arr.length;
var readUint8Array = (decoder2, len) => {
  const view = new Uint8Array(decoder2.arr.buffer, decoder2.pos + decoder2.arr.byteOffset, len);
  decoder2.pos += len;
  return view;
};
var readVarUint8Array = (decoder2) => readUint8Array(decoder2, readVarUint(decoder2));
var readUint8 = (decoder2) => decoder2.arr[decoder2.pos++];
var readVarUint = (decoder2) => {
  let num = 0;
  let mult = 1;
  const len = decoder2.arr.length;
  while (decoder2.pos < len) {
    const r = decoder2.arr[decoder2.pos++];
    num = num + (r & BITS7) * mult;
    mult *= 128;
    if (r < BIT8) {
      return num;
    }
    if (num > MAX_SAFE_INTEGER) {
      throw errorIntegerOutOfRange;
    }
  }
  throw errorUnexpectedEndOfArray;
};
var readVarInt = (decoder2) => {
  let r = decoder2.arr[decoder2.pos++];
  let num = r & BITS6;
  let mult = 64;
  const sign = (r & BIT7) > 0 ? -1 : 1;
  if ((r & BIT8) === 0) {
    return sign * num;
  }
  const len = decoder2.arr.length;
  while (decoder2.pos < len) {
    r = decoder2.arr[decoder2.pos++];
    num = num + (r & BITS7) * mult;
    mult *= 128;
    if (r < BIT8) {
      return sign * num;
    }
    if (num > MAX_SAFE_INTEGER) {
      throw errorIntegerOutOfRange;
    }
  }
  throw errorUnexpectedEndOfArray;
};
var _readVarStringPolyfill = (decoder2) => {
  let remainingLen = readVarUint(decoder2);
  if (remainingLen === 0) {
    return "";
  } else {
    let encodedString = String.fromCodePoint(readUint8(decoder2));
    if (--remainingLen < 100) {
      while (remainingLen--) {
        encodedString += String.fromCodePoint(readUint8(decoder2));
      }
    } else {
      while (remainingLen > 0) {
        const nextLen = remainingLen < 1e4 ? remainingLen : 1e4;
        const bytes = decoder2.arr.subarray(decoder2.pos, decoder2.pos + nextLen);
        decoder2.pos += nextLen;
        encodedString += String.fromCodePoint.apply(
          null,
          /** @type {any} */
          bytes
        );
        remainingLen -= nextLen;
      }
    }
    return decodeURIComponent(escape(encodedString));
  }
};
var _readVarStringNative = (decoder2) => (
  /** @type any */
  utf8TextDecoder.decode(readVarUint8Array(decoder2))
);
var readVarString = utf8TextDecoder ? _readVarStringNative : _readVarStringPolyfill;
var readFromDataView = (decoder2, len) => {
  const dv = new DataView(decoder2.arr.buffer, decoder2.arr.byteOffset + decoder2.pos, len);
  decoder2.pos += len;
  return dv;
};
var readFloat32 = (decoder2) => readFromDataView(decoder2, 4).getFloat32(0, false);
var readFloat64 = (decoder2) => readFromDataView(decoder2, 8).getFloat64(0, false);
var readBigInt64 = (decoder2) => (
  /** @type {any} */
  readFromDataView(decoder2, 8).getBigInt64(0, false)
);
var readAnyLookupTable = [
  (decoder2) => void 0,
  // CASE 127: undefined
  (decoder2) => null,
  // CASE 126: null
  readVarInt,
  // CASE 125: integer
  readFloat32,
  // CASE 124: float32
  readFloat64,
  // CASE 123: float64
  readBigInt64,
  // CASE 122: bigint
  (decoder2) => false,
  // CASE 121: boolean (false)
  (decoder2) => true,
  // CASE 120: boolean (true)
  readVarString,
  // CASE 119: string
  (decoder2) => {
    const len = readVarUint(decoder2);
    const obj = {};
    for (let i2 = 0; i2 < len; i2++) {
      const key = readVarString(decoder2);
      obj[key] = readAny(decoder2);
    }
    return obj;
  },
  (decoder2) => {
    const len = readVarUint(decoder2);
    const arr = [];
    for (let i2 = 0; i2 < len; i2++) {
      arr.push(readAny(decoder2));
    }
    return arr;
  },
  readVarUint8Array
  // CASE 116: Uint8Array
];
var readAny = (decoder2) => readAnyLookupTable[127 - readUint8(decoder2)](decoder2);
var RleDecoder = class extends Decoder {
  /**
   * @param {Uint8Array} uint8Array
   * @param {function(Decoder):T} reader
   */
  constructor(uint8Array, reader) {
    super(uint8Array);
    this.reader = reader;
    this.s = null;
    this.count = 0;
  }
  read() {
    if (this.count === 0) {
      this.s = this.reader(this);
      if (hasContent(this)) {
        this.count = readVarUint(this) + 1;
      } else {
        this.count = -1;
      }
    }
    this.count--;
    return (
      /** @type {T} */
      this.s
    );
  }
};
var UintOptRleDecoder = class extends Decoder {
  /**
   * @param {Uint8Array} uint8Array
   */
  constructor(uint8Array) {
    super(uint8Array);
    this.s = 0;
    this.count = 0;
  }
  read() {
    if (this.count === 0) {
      this.s = readVarInt(this);
      const isNegative = isNegativeZero(this.s);
      this.count = 1;
      if (isNegative) {
        this.s = -this.s;
        this.count = readVarUint(this) + 2;
      }
    }
    this.count--;
    return (
      /** @type {number} */
      this.s
    );
  }
};
var IntDiffOptRleDecoder = class extends Decoder {
  /**
   * @param {Uint8Array} uint8Array
   */
  constructor(uint8Array) {
    super(uint8Array);
    this.s = 0;
    this.count = 0;
    this.diff = 0;
  }
  /**
   * @return {number}
   */
  read() {
    if (this.count === 0) {
      const diff = readVarInt(this);
      const hasCount = diff & 1;
      this.diff = floor(diff / 2);
      this.count = 1;
      if (hasCount) {
        this.count = readVarUint(this) + 2;
      }
    }
    this.s += this.diff;
    this.count--;
    return this.s;
  }
};
var StringDecoder = class {
  /**
   * @param {Uint8Array} uint8Array
   */
  constructor(uint8Array) {
    this.decoder = new UintOptRleDecoder(uint8Array);
    this.str = readVarString(this.decoder);
    this.spos = 0;
  }
  /**
   * @return {string}
   */
  read() {
    const end = this.spos + this.decoder.read();
    const res = this.str.slice(this.spos, end);
    this.spos = end;
    return res;
  }
};

// node_modules/lib0/webcrypto.js
var subtle = crypto.subtle;
var getRandomValues = crypto.getRandomValues.bind(crypto);

// node_modules/lib0/random.js
var uint32 = () => getRandomValues(new Uint32Array(1))[0];
var uuidv4Template = [1e7] + -1e3 + -4e3 + -8e3 + -1e11;
var uuidv4 = () => uuidv4Template.replace(
  /[018]/g,
  /** @param {number} c */
  (c) => (c ^ uint32() & 15 >> c / 4).toString(16)
);

// node_modules/lib0/time.js
var getUnixTime = Date.now;

// node_modules/lib0/promise.js
var create4 = (f) => (
  /** @type {Promise<T>} */
  new Promise(f)
);
var all = Promise.all.bind(Promise);

// node_modules/lib0/conditions.js
var undefinedToNull = (v) => v === void 0 ? null : v;

// node_modules/lib0/storage.js
var VarStoragePolyfill = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {string} key
   * @param {any} newValue
   */
  setItem(key, newValue) {
    this.map.set(key, newValue);
  }
  /**
   * @param {string} key
   */
  getItem(key) {
    return this.map.get(key);
  }
};
var _localStorage = new VarStoragePolyfill();
var usePolyfill = true;
try {
  if (typeof localStorage !== "undefined" && localStorage) {
    _localStorage = localStorage;
    usePolyfill = false;
  }
} catch (e2) {
}
var varStorage = _localStorage;

// node_modules/lib0/object.js
var assign = Object.assign;
var keys = Object.keys;
var forEach = (obj, f) => {
  for (const key in obj) {
    f(obj[key], key);
  }
};
var length2 = (obj) => keys(obj).length;
var isEmpty = (obj) => {
  for (const _k in obj) {
    return false;
  }
  return true;
};
var every = (obj, f) => {
  for (const key in obj) {
    if (!f(obj[key], key)) {
      return false;
    }
  }
  return true;
};
var hasProperty = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key);
var equalFlat = (a, b) => a === b || length2(a) === length2(b) && every(a, (val, key) => (val !== void 0 || hasProperty(b, key)) && b[key] === val);

// node_modules/lib0/function.js
var callAll = (fs, args3, i2 = 0) => {
  try {
    for (; i2 < fs.length; i2++) {
      fs[i2](...args3);
    }
  } finally {
    if (i2 < fs.length) {
      callAll(fs, args3, i2 + 1);
    }
  }
};
var id = (a) => a;
var equalityStrict = (a, b) => a === b;
var equalityDeep = (a, b) => {
  if (a == null || b == null) {
    return equalityStrict(a, b);
  }
  if (a.constructor !== b.constructor) {
    return false;
  }
  if (a === b) {
    return true;
  }
  switch (a.constructor) {
    case ArrayBuffer:
      a = new Uint8Array(a);
      b = new Uint8Array(b);
    case Uint8Array: {
      if (a.byteLength !== b.byteLength) {
        return false;
      }
      for (let i2 = 0; i2 < a.length; i2++) {
        if (a[i2] !== b[i2]) {
          return false;
        }
      }
      break;
    }
    case Set: {
      if (a.size !== b.size) {
        return false;
      }
      for (const value of a) {
        if (!b.has(value)) {
          return false;
        }
      }
      break;
    }
    case Map: {
      if (a.size !== b.size) {
        return false;
      }
      for (const key of a.keys()) {
        if (!b.has(key) || !equalityDeep(a.get(key), b.get(key))) {
          return false;
        }
      }
      break;
    }
    case Object:
      if (length2(a) !== length2(b)) {
        return false;
      }
      for (const key in a) {
        if (!hasProperty(a, key) || !equalityDeep(a[key], b[key])) {
          return false;
        }
      }
      break;
    case Array:
      if (a.length !== b.length) {
        return false;
      }
      for (let i2 = 0; i2 < a.length; i2++) {
        if (!equalityDeep(a[i2], b[i2])) {
          return false;
        }
      }
      break;
    default:
      return false;
  }
  return true;
};
var isOneOf = (value, options) => options.includes(value);

// node_modules/lib0/environment.js
var isNode = typeof process !== "undefined" && process.release && /node|io\.js/.test(process.release.name) && Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]";
var isMac = typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
var params;
var args = [];
var computeParams = () => {
  if (params === void 0) {
    if (isNode) {
      params = create();
      const pargs = process.argv;
      let currParamName = null;
      for (let i2 = 0; i2 < pargs.length; i2++) {
        const parg = pargs[i2];
        if (parg[0] === "-") {
          if (currParamName !== null) {
            params.set(currParamName, "");
          }
          currParamName = parg;
        } else {
          if (currParamName !== null) {
            params.set(currParamName, parg);
            currParamName = null;
          } else {
            args.push(parg);
          }
        }
      }
      if (currParamName !== null) {
        params.set(currParamName, "");
      }
    } else if (typeof location === "object") {
      params = create();
      (location.search || "?").slice(1).split("&").forEach((kv) => {
        if (kv.length !== 0) {
          const [key, value] = kv.split("=");
          params.set(`--${fromCamelCase(key, "-")}`, value);
          params.set(`-${fromCamelCase(key, "-")}`, value);
        }
      });
    } else {
      params = create();
    }
  }
  return params;
};
var hasParam = (name) => computeParams().has(name);
var getVariable = (name) => isNode ? undefinedToNull(process.env[name.toUpperCase().replaceAll("-", "_")]) : undefinedToNull(varStorage.getItem(name));
var hasConf = (name) => hasParam("--" + name) || getVariable(name) !== null;
var production = hasConf("production");
var forceColor = isNode && isOneOf(process.env.FORCE_COLOR, ["true", "1", "2"]);
var supportsColor = !hasParam("no-colors") && (!isNode || process.stdout.isTTY || forceColor) && (!isNode || hasParam("color") || forceColor || getVariable("COLORTERM") !== null || (getVariable("TERM") || "").includes("color"));

// node_modules/lib0/buffer.js
var createUint8ArrayFromLen = (len) => new Uint8Array(len);
var copyUint8Array = (uint8Array) => {
  const newBuf = createUint8ArrayFromLen(uint8Array.byteLength);
  newBuf.set(uint8Array);
  return newBuf;
};

// node_modules/lib0/pair.js
var Pair = class {
  /**
   * @param {L} left
   * @param {R} right
   */
  constructor(left, right) {
    this.left = left;
    this.right = right;
  }
};
var create5 = (left, right) => new Pair(left, right);
var forEach2 = (arr, f) => arr.forEach((p) => f(p.left, p.right));

// node_modules/lib0/dom.js
var doc = (
  /** @type {Document} */
  typeof document !== "undefined" ? document : {}
);
var createElement = (name) => doc.createElement(name);
var createDocumentFragment = () => doc.createDocumentFragment();
var createTextNode = (text3) => doc.createTextNode(text3);
var domParser = (
  /** @type {DOMParser} */
  typeof DOMParser !== "undefined" ? new DOMParser() : null
);
var setAttributes = (el, attrs) => {
  forEach2(attrs, (key, value) => {
    if (value === false) {
      el.removeAttribute(key);
    } else if (value === true) {
      el.setAttribute(key, "");
    } else {
      el.setAttribute(key, value);
    }
  });
  return el;
};
var fragment = (children2) => {
  const fragment2 = createDocumentFragment();
  for (let i2 = 0; i2 < children2.length; i2++) {
    appendChild(fragment2, children2[i2]);
  }
  return fragment2;
};
var append = (parent, nodes) => {
  appendChild(parent, fragment(nodes));
  return parent;
};
var element = (name, attrs = [], children2 = []) => append(setAttributes(createElement(name), attrs), children2);
var text = createTextNode;
var mapToStyleString = (m) => map(m, (value, key) => `${key}:${value};`).join("");
var appendChild = (parent, child) => parent.appendChild(child);
var ELEMENT_NODE = doc.ELEMENT_NODE;
var TEXT_NODE = doc.TEXT_NODE;
var CDATA_SECTION_NODE = doc.CDATA_SECTION_NODE;
var COMMENT_NODE = doc.COMMENT_NODE;
var DOCUMENT_NODE = doc.DOCUMENT_NODE;
var DOCUMENT_TYPE_NODE = doc.DOCUMENT_TYPE_NODE;
var DOCUMENT_FRAGMENT_NODE = doc.DOCUMENT_FRAGMENT_NODE;

// node_modules/lib0/symbol.js
var create6 = Symbol;

// node_modules/lib0/logging.common.js
var BOLD = create6();
var UNBOLD = create6();
var BLUE = create6();
var GREY = create6();
var GREEN = create6();
var RED = create6();
var PURPLE = create6();
var ORANGE = create6();
var UNCOLOR = create6();
var computeNoColorLoggingArgs = (args3) => {
  var _a2;
  if (args3.length === 1 && ((_a2 = args3[0]) == null ? void 0 : _a2.constructor) === Function) {
    args3 = /** @type {Array<string|Symbol|Object|number>} */
    /** @type {[function]} */
    args3[0]();
  }
  const strBuilder = [];
  const logArgs = [];
  let i2 = 0;
  for (; i2 < args3.length; i2++) {
    const arg = args3[i2];
    if (arg === void 0) {
      strBuilder.push("undefined");
    } else if (arg.constructor === String || arg.constructor === Number) {
      strBuilder.push(arg);
    } else if (arg.constructor === Object) {
      logArgs.push(JSON.stringify(arg));
    }
  }
  return logArgs;
};
var lastLoggingTime = getUnixTime();

// node_modules/lib0/logging.js
var _browserStyleMap = {
  [BOLD]: create5("font-weight", "bold"),
  [UNBOLD]: create5("font-weight", "normal"),
  [BLUE]: create5("color", "blue"),
  [GREEN]: create5("color", "green"),
  [GREY]: create5("color", "grey"),
  [RED]: create5("color", "red"),
  [PURPLE]: create5("color", "purple"),
  [ORANGE]: create5("color", "orange"),
  // not well supported in chrome when debugging node with inspector - TODO: deprecate
  [UNCOLOR]: create5("color", "black")
};
var computeBrowserLoggingArgs = (args3) => {
  var _a2;
  if (args3.length === 1 && ((_a2 = args3[0]) == null ? void 0 : _a2.constructor) === Function) {
    args3 = /** @type {Array<string|Symbol|Object|number>} */
    /** @type {[function]} */
    args3[0]();
  }
  const strBuilder = [];
  const styles = [];
  const currentStyle = create();
  let logArgs = [];
  let i2 = 0;
  for (; i2 < args3.length; i2++) {
    const arg = args3[i2];
    const style = _browserStyleMap[arg];
    if (style !== void 0) {
      currentStyle.set(style.left, style.right);
    } else {
      if (arg === void 0) {
        break;
      }
      if (arg.constructor === String || arg.constructor === Number) {
        const style2 = mapToStyleString(currentStyle);
        if (i2 > 0 || style2.length > 0) {
          strBuilder.push("%c" + arg);
          styles.push(style2);
        } else {
          strBuilder.push(arg);
        }
      } else {
        break;
      }
    }
  }
  if (i2 > 0) {
    logArgs = styles;
    logArgs.unshift(strBuilder.join(""));
  }
  for (; i2 < args3.length; i2++) {
    const arg = args3[i2];
    if (!(arg instanceof Symbol)) {
      logArgs.push(arg);
    }
  }
  return logArgs;
};
var computeLoggingArgs = supportsColor ? computeBrowserLoggingArgs : computeNoColorLoggingArgs;
var print = (...args3) => {
  console.log(...computeLoggingArgs(args3));
  vconsoles.forEach((vc) => vc.print(args3));
};
var vconsoles = create2();

// node_modules/lib0/iterator.js
var createIterator = (next) => ({
  /**
   * @return {IterableIterator<T>}
   */
  [Symbol.iterator]() {
    return this;
  },
  // @ts-ignore
  next
});
var iteratorFilter = (iterator, filter) => createIterator(() => {
  let res;
  do {
    res = iterator.next();
  } while (!res.done && !filter(res.value));
  return res;
});
var iteratorMap = (iterator, fmap) => createIterator(() => {
  const { done, value } = iterator.next();
  return { done, value: done ? void 0 : fmap(value) };
});

// node_modules/yjs/dist/yjs.mjs
var DeleteItem = class {
  /**
   * @param {number} clock
   * @param {number} len
   */
  constructor(clock, len) {
    this.clock = clock;
    this.len = len;
  }
};
var DeleteSet = class {
  constructor() {
    this.clients = /* @__PURE__ */ new Map();
  }
};
var iterateDeletedStructs = (transaction, ds, f) => ds.clients.forEach((deletes, clientid) => {
  const structs = (
    /** @type {Array<GC|Item>} */
    transaction.doc.store.clients.get(clientid)
  );
  for (let i2 = 0; i2 < deletes.length; i2++) {
    const del2 = deletes[i2];
    iterateStructs(transaction, structs, del2.clock, del2.len, f);
  }
});
var findIndexDS = (dis, clock) => {
  let left = 0;
  let right = dis.length - 1;
  while (left <= right) {
    const midindex = floor((left + right) / 2);
    const mid = dis[midindex];
    const midclock = mid.clock;
    if (midclock <= clock) {
      if (clock < midclock + mid.len) {
        return midindex;
      }
      left = midindex + 1;
    } else {
      right = midindex - 1;
    }
  }
  return null;
};
var isDeleted = (ds, id2) => {
  const dis = ds.clients.get(id2.client);
  return dis !== void 0 && findIndexDS(dis, id2.clock) !== null;
};
var sortAndMergeDeleteSet = (ds) => {
  ds.clients.forEach((dels) => {
    dels.sort((a, b) => a.clock - b.clock);
    let i2, j;
    for (i2 = 1, j = 1; i2 < dels.length; i2++) {
      const left = dels[j - 1];
      const right = dels[i2];
      if (left.clock + left.len >= right.clock) {
        left.len = max(left.len, right.clock + right.len - left.clock);
      } else {
        if (j < i2) {
          dels[j] = right;
        }
        j++;
      }
    }
    dels.length = j;
  });
};
var mergeDeleteSets = (dss) => {
  const merged = new DeleteSet();
  for (let dssI = 0; dssI < dss.length; dssI++) {
    dss[dssI].clients.forEach((delsLeft, client) => {
      if (!merged.clients.has(client)) {
        const dels = delsLeft.slice();
        for (let i2 = dssI + 1; i2 < dss.length; i2++) {
          appendTo(dels, dss[i2].clients.get(client) || []);
        }
        merged.clients.set(client, dels);
      }
    });
  }
  sortAndMergeDeleteSet(merged);
  return merged;
};
var addToDeleteSet = (ds, client, clock, length4) => {
  setIfUndefined(ds.clients, client, () => (
    /** @type {Array<DeleteItem>} */
    []
  )).push(new DeleteItem(clock, length4));
};
var createDeleteSet = () => new DeleteSet();
var createDeleteSetFromStructStore = (ss) => {
  const ds = createDeleteSet();
  ss.clients.forEach((structs, client) => {
    const dsitems = [];
    for (let i2 = 0; i2 < structs.length; i2++) {
      const struct = structs[i2];
      if (struct.deleted) {
        const clock = struct.id.clock;
        let len = struct.length;
        if (i2 + 1 < structs.length) {
          for (let next = structs[i2 + 1]; i2 + 1 < structs.length && next.deleted; next = structs[++i2 + 1]) {
            len += next.length;
          }
        }
        dsitems.push(new DeleteItem(clock, len));
      }
    }
    if (dsitems.length > 0) {
      ds.clients.set(client, dsitems);
    }
  });
  return ds;
};
var writeDeleteSet = (encoder2, ds) => {
  writeVarUint(encoder2.restEncoder, ds.clients.size);
  from(ds.clients.entries()).sort((a, b) => b[0] - a[0]).forEach(([client, dsitems]) => {
    encoder2.resetDsCurVal();
    writeVarUint(encoder2.restEncoder, client);
    const len = dsitems.length;
    writeVarUint(encoder2.restEncoder, len);
    for (let i2 = 0; i2 < len; i2++) {
      const item = dsitems[i2];
      encoder2.writeDsClock(item.clock);
      encoder2.writeDsLen(item.len);
    }
  });
};
var readDeleteSet = (decoder2) => {
  const ds = new DeleteSet();
  const numClients = readVarUint(decoder2.restDecoder);
  for (let i2 = 0; i2 < numClients; i2++) {
    decoder2.resetDsCurVal();
    const client = readVarUint(decoder2.restDecoder);
    const numberOfDeletes = readVarUint(decoder2.restDecoder);
    if (numberOfDeletes > 0) {
      const dsField = setIfUndefined(ds.clients, client, () => (
        /** @type {Array<DeleteItem>} */
        []
      ));
      for (let i3 = 0; i3 < numberOfDeletes; i3++) {
        dsField.push(new DeleteItem(decoder2.readDsClock(), decoder2.readDsLen()));
      }
    }
  }
  return ds;
};
var readAndApplyDeleteSet = (decoder2, transaction, store) => {
  const unappliedDS = new DeleteSet();
  const numClients = readVarUint(decoder2.restDecoder);
  for (let i2 = 0; i2 < numClients; i2++) {
    decoder2.resetDsCurVal();
    const client = readVarUint(decoder2.restDecoder);
    const numberOfDeletes = readVarUint(decoder2.restDecoder);
    const structs = store.clients.get(client) || [];
    const state = getState(store, client);
    for (let i3 = 0; i3 < numberOfDeletes; i3++) {
      const clock = decoder2.readDsClock();
      const clockEnd = clock + decoder2.readDsLen();
      if (clock < state) {
        if (state < clockEnd) {
          addToDeleteSet(unappliedDS, client, state, clockEnd - state);
        }
        let index = findIndexSS(structs, clock);
        let struct = structs[index];
        if (!struct.deleted && struct.id.clock < clock) {
          structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));
          index++;
        }
        while (index < structs.length) {
          struct = structs[index++];
          if (struct.id.clock < clockEnd) {
            if (!struct.deleted) {
              if (clockEnd < struct.id.clock + struct.length) {
                structs.splice(index, 0, splitItem(transaction, struct, clockEnd - struct.id.clock));
              }
              struct.delete(transaction);
            }
          } else {
            break;
          }
        }
      } else {
        addToDeleteSet(unappliedDS, client, clock, clockEnd - clock);
      }
    }
  }
  if (unappliedDS.clients.size > 0) {
    const ds = new UpdateEncoderV2();
    writeVarUint(ds.restEncoder, 0);
    writeDeleteSet(ds, unappliedDS);
    return ds.toUint8Array();
  }
  return null;
};
var generateNewClientId = uint32;
var Doc = class extends ObservableV2 {
  /**
   * @param {DocOpts} opts configuration
   */
  constructor({ guid = uuidv4(), collectionid = null, gc = true, gcFilter = () => true, meta = null, autoLoad = false, shouldLoad = true } = {}) {
    super();
    this.gc = gc;
    this.gcFilter = gcFilter;
    this.clientID = generateNewClientId();
    this.guid = guid;
    this.collectionid = collectionid;
    this.share = /* @__PURE__ */ new Map();
    this.store = new StructStore();
    this._transaction = null;
    this._transactionCleanups = [];
    this.subdocs = /* @__PURE__ */ new Set();
    this._item = null;
    this.shouldLoad = shouldLoad;
    this.autoLoad = autoLoad;
    this.meta = meta;
    this.isLoaded = false;
    this.isSynced = false;
    this.whenLoaded = create4((resolve) => {
      this.on("load", () => {
        this.isLoaded = true;
        resolve(this);
      });
    });
    const provideSyncedPromise = () => create4((resolve) => {
      const eventHandler = (isSynced) => {
        if (isSynced === void 0 || isSynced === true) {
          this.off("sync", eventHandler);
          resolve();
        }
      };
      this.on("sync", eventHandler);
    });
    this.on("sync", (isSynced) => {
      if (isSynced === false && this.isSynced) {
        this.whenSynced = provideSyncedPromise();
      }
      this.isSynced = isSynced === void 0 || isSynced === true;
      if (this.isSynced && !this.isLoaded) {
        this.emit("load", [this]);
      }
    });
    this.whenSynced = provideSyncedPromise();
  }
  /**
   * Notify the parent document that you request to load data into this subdocument (if it is a subdocument).
   *
   * `load()` might be used in the future to request any provider to load the most current data.
   *
   * It is safe to call `load()` multiple times.
   */
  load() {
    const item = this._item;
    if (item !== null && !this.shouldLoad) {
      transact(
        /** @type {any} */
        item.parent.doc,
        (transaction) => {
          transaction.subdocsLoaded.add(this);
        },
        null,
        true
      );
    }
    this.shouldLoad = true;
  }
  getSubdocs() {
    return this.subdocs;
  }
  getSubdocGuids() {
    return new Set(from(this.subdocs).map((doc2) => doc2.guid));
  }
  /**
   * Changes that happen inside of a transaction are bundled. This means that
   * the observer fires _after_ the transaction is finished and that all changes
   * that happened inside of the transaction are sent as one message to the
   * other peers.
   *
   * @template T
   * @param {function(Transaction):T} f The function that should be executed as a transaction
   * @param {any} [origin] Origin of who started the transaction. Will be stored on transaction.origin
   * @return T
   *
   * @public
   */
  transact(f, origin = null) {
    return transact(this, f, origin);
  }
  /**
   * Define a shared data type.
   *
   * Multiple calls of `y.get(name, TypeConstructor)` yield the same result
   * and do not overwrite each other. I.e.
   * `y.define(name, Y.Array) === y.define(name, Y.Array)`
   *
   * After this method is called, the type is also available on `y.share.get(name)`.
   *
   * *Best Practices:*
   * Define all types right after the Yjs instance is created and store them in a separate object.
   * Also use the typed methods `getText(name)`, `getArray(name)`, ..
   *
   * @template {typeof AbstractType<any>} Type
   * @example
   *   const y = new Y(..)
   *   const appState = {
   *     document: y.getText('document')
   *     comments: y.getArray('comments')
   *   }
   *
   * @param {string} name
   * @param {Type} TypeConstructor The constructor of the type definition. E.g. Y.Text, Y.Array, Y.Map, ...
   * @return {InstanceType<Type>} The created type. Constructed with TypeConstructor
   *
   * @public
   */
  get(name, TypeConstructor = (
    /** @type {any} */
    AbstractType
  )) {
    const type = setIfUndefined(this.share, name, () => {
      const t2 = new TypeConstructor();
      t2._integrate(this, null);
      return t2;
    });
    const Constr = type.constructor;
    if (TypeConstructor !== AbstractType && Constr !== TypeConstructor) {
      if (Constr === AbstractType) {
        const t2 = new TypeConstructor();
        t2._map = type._map;
        type._map.forEach(
          /** @param {Item?} n */
          (n) => {
            for (; n !== null; n = n.left) {
              n.parent = t2;
            }
          }
        );
        t2._start = type._start;
        for (let n = t2._start; n !== null; n = n.right) {
          n.parent = t2;
        }
        t2._length = type._length;
        this.share.set(name, t2);
        t2._integrate(this, null);
        return (
          /** @type {InstanceType<Type>} */
          t2
        );
      } else {
        throw new Error(`Type with the name ${name} has already been defined with a different constructor`);
      }
    }
    return (
      /** @type {InstanceType<Type>} */
      type
    );
  }
  /**
   * @template T
   * @param {string} [name]
   * @return {YArray<T>}
   *
   * @public
   */
  getArray(name = "") {
    return (
      /** @type {YArray<T>} */
      this.get(name, YArray)
    );
  }
  /**
   * @param {string} [name]
   * @return {YText}
   *
   * @public
   */
  getText(name = "") {
    return this.get(name, YText);
  }
  /**
   * @template T
   * @param {string} [name]
   * @return {YMap<T>}
   *
   * @public
   */
  getMap(name = "") {
    return (
      /** @type {YMap<T>} */
      this.get(name, YMap)
    );
  }
  /**
   * @param {string} [name]
   * @return {YXmlElement}
   *
   * @public
   */
  getXmlElement(name = "") {
    return (
      /** @type {YXmlElement<{[key:string]:string}>} */
      this.get(name, YXmlElement)
    );
  }
  /**
   * @param {string} [name]
   * @return {YXmlFragment}
   *
   * @public
   */
  getXmlFragment(name = "") {
    return this.get(name, YXmlFragment);
  }
  /**
   * Converts the entire document into a js object, recursively traversing each yjs type
   * Doesn't log types that have not been defined (using ydoc.getType(..)).
   *
   * @deprecated Do not use this method and rather call toJSON directly on the shared types.
   *
   * @return {Object<string, any>}
   */
  toJSON() {
    const doc2 = {};
    this.share.forEach((value, key) => {
      doc2[key] = value.toJSON();
    });
    return doc2;
  }
  /**
   * Emit `destroy` event and unregister all event handlers.
   */
  destroy() {
    from(this.subdocs).forEach((subdoc) => subdoc.destroy());
    const item = this._item;
    if (item !== null) {
      this._item = null;
      const content = (
        /** @type {ContentDoc} */
        item.content
      );
      content.doc = new Doc({ guid: this.guid, ...content.opts, shouldLoad: false });
      content.doc._item = item;
      transact(
        /** @type {any} */
        item.parent.doc,
        (transaction) => {
          const doc2 = content.doc;
          if (!item.deleted) {
            transaction.subdocsAdded.add(doc2);
          }
          transaction.subdocsRemoved.add(this);
        },
        null,
        true
      );
    }
    this.emit("destroyed", [true]);
    this.emit("destroy", [this]);
    super.destroy();
  }
};
var DSDecoderV1 = class {
  /**
   * @param {decoding.Decoder} decoder
   */
  constructor(decoder2) {
    this.restDecoder = decoder2;
  }
  resetDsCurVal() {
  }
  /**
   * @return {number}
   */
  readDsClock() {
    return readVarUint(this.restDecoder);
  }
  /**
   * @return {number}
   */
  readDsLen() {
    return readVarUint(this.restDecoder);
  }
};
var UpdateDecoderV1 = class extends DSDecoderV1 {
  /**
   * @return {ID}
   */
  readLeftID() {
    return createID(readVarUint(this.restDecoder), readVarUint(this.restDecoder));
  }
  /**
   * @return {ID}
   */
  readRightID() {
    return createID(readVarUint(this.restDecoder), readVarUint(this.restDecoder));
  }
  /**
   * Read the next client id.
   * Use this in favor of readID whenever possible to reduce the number of objects created.
   */
  readClient() {
    return readVarUint(this.restDecoder);
  }
  /**
   * @return {number} info An unsigned 8-bit integer
   */
  readInfo() {
    return readUint8(this.restDecoder);
  }
  /**
   * @return {string}
   */
  readString() {
    return readVarString(this.restDecoder);
  }
  /**
   * @return {boolean} isKey
   */
  readParentInfo() {
    return readVarUint(this.restDecoder) === 1;
  }
  /**
   * @return {number} info An unsigned 8-bit integer
   */
  readTypeRef() {
    return readVarUint(this.restDecoder);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @return {number} len
   */
  readLen() {
    return readVarUint(this.restDecoder);
  }
  /**
   * @return {any}
   */
  readAny() {
    return readAny(this.restDecoder);
  }
  /**
   * @return {Uint8Array}
   */
  readBuf() {
    return copyUint8Array(readVarUint8Array(this.restDecoder));
  }
  /**
   * Legacy implementation uses JSON parse. We use any-decoding in v2.
   *
   * @return {any}
   */
  readJSON() {
    return JSON.parse(readVarString(this.restDecoder));
  }
  /**
   * @return {string}
   */
  readKey() {
    return readVarString(this.restDecoder);
  }
};
var DSDecoderV2 = class {
  /**
   * @param {decoding.Decoder} decoder
   */
  constructor(decoder2) {
    this.dsCurrVal = 0;
    this.restDecoder = decoder2;
  }
  resetDsCurVal() {
    this.dsCurrVal = 0;
  }
  /**
   * @return {number}
   */
  readDsClock() {
    this.dsCurrVal += readVarUint(this.restDecoder);
    return this.dsCurrVal;
  }
  /**
   * @return {number}
   */
  readDsLen() {
    const diff = readVarUint(this.restDecoder) + 1;
    this.dsCurrVal += diff;
    return diff;
  }
};
var UpdateDecoderV2 = class extends DSDecoderV2 {
  /**
   * @param {decoding.Decoder} decoder
   */
  constructor(decoder2) {
    super(decoder2);
    this.keys = [];
    readVarUint(decoder2);
    this.keyClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder2));
    this.clientDecoder = new UintOptRleDecoder(readVarUint8Array(decoder2));
    this.leftClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder2));
    this.rightClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder2));
    this.infoDecoder = new RleDecoder(readVarUint8Array(decoder2), readUint8);
    this.stringDecoder = new StringDecoder(readVarUint8Array(decoder2));
    this.parentInfoDecoder = new RleDecoder(readVarUint8Array(decoder2), readUint8);
    this.typeRefDecoder = new UintOptRleDecoder(readVarUint8Array(decoder2));
    this.lenDecoder = new UintOptRleDecoder(readVarUint8Array(decoder2));
  }
  /**
   * @return {ID}
   */
  readLeftID() {
    return new ID(this.clientDecoder.read(), this.leftClockDecoder.read());
  }
  /**
   * @return {ID}
   */
  readRightID() {
    return new ID(this.clientDecoder.read(), this.rightClockDecoder.read());
  }
  /**
   * Read the next client id.
   * Use this in favor of readID whenever possible to reduce the number of objects created.
   */
  readClient() {
    return this.clientDecoder.read();
  }
  /**
   * @return {number} info An unsigned 8-bit integer
   */
  readInfo() {
    return (
      /** @type {number} */
      this.infoDecoder.read()
    );
  }
  /**
   * @return {string}
   */
  readString() {
    return this.stringDecoder.read();
  }
  /**
   * @return {boolean}
   */
  readParentInfo() {
    return this.parentInfoDecoder.read() === 1;
  }
  /**
   * @return {number} An unsigned 8-bit integer
   */
  readTypeRef() {
    return this.typeRefDecoder.read();
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @return {number}
   */
  readLen() {
    return this.lenDecoder.read();
  }
  /**
   * @return {any}
   */
  readAny() {
    return readAny(this.restDecoder);
  }
  /**
   * @return {Uint8Array}
   */
  readBuf() {
    return readVarUint8Array(this.restDecoder);
  }
  /**
   * This is mainly here for legacy purposes.
   *
   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
   *
   * @return {any}
   */
  readJSON() {
    return readAny(this.restDecoder);
  }
  /**
   * @return {string}
   */
  readKey() {
    const keyClock = this.keyClockDecoder.read();
    if (keyClock < this.keys.length) {
      return this.keys[keyClock];
    } else {
      const key = this.stringDecoder.read();
      this.keys.push(key);
      return key;
    }
  }
};
var DSEncoderV1 = class {
  constructor() {
    this.restEncoder = createEncoder();
  }
  toUint8Array() {
    return toUint8Array(this.restEncoder);
  }
  resetDsCurVal() {
  }
  /**
   * @param {number} clock
   */
  writeDsClock(clock) {
    writeVarUint(this.restEncoder, clock);
  }
  /**
   * @param {number} len
   */
  writeDsLen(len) {
    writeVarUint(this.restEncoder, len);
  }
};
var UpdateEncoderV1 = class extends DSEncoderV1 {
  /**
   * @param {ID} id
   */
  writeLeftID(id2) {
    writeVarUint(this.restEncoder, id2.client);
    writeVarUint(this.restEncoder, id2.clock);
  }
  /**
   * @param {ID} id
   */
  writeRightID(id2) {
    writeVarUint(this.restEncoder, id2.client);
    writeVarUint(this.restEncoder, id2.clock);
  }
  /**
   * Use writeClient and writeClock instead of writeID if possible.
   * @param {number} client
   */
  writeClient(client) {
    writeVarUint(this.restEncoder, client);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeInfo(info) {
    writeUint8(this.restEncoder, info);
  }
  /**
   * @param {string} s
   */
  writeString(s2) {
    writeVarString(this.restEncoder, s2);
  }
  /**
   * @param {boolean} isYKey
   */
  writeParentInfo(isYKey) {
    writeVarUint(this.restEncoder, isYKey ? 1 : 0);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeTypeRef(info) {
    writeVarUint(this.restEncoder, info);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */
  writeLen(len) {
    writeVarUint(this.restEncoder, len);
  }
  /**
   * @param {any} any
   */
  writeAny(any2) {
    writeAny(this.restEncoder, any2);
  }
  /**
   * @param {Uint8Array} buf
   */
  writeBuf(buf) {
    writeVarUint8Array(this.restEncoder, buf);
  }
  /**
   * @param {any} embed
   */
  writeJSON(embed) {
    writeVarString(this.restEncoder, JSON.stringify(embed));
  }
  /**
   * @param {string} key
   */
  writeKey(key) {
    writeVarString(this.restEncoder, key);
  }
};
var DSEncoderV2 = class {
  constructor() {
    this.restEncoder = createEncoder();
    this.dsCurrVal = 0;
  }
  toUint8Array() {
    return toUint8Array(this.restEncoder);
  }
  resetDsCurVal() {
    this.dsCurrVal = 0;
  }
  /**
   * @param {number} clock
   */
  writeDsClock(clock) {
    const diff = clock - this.dsCurrVal;
    this.dsCurrVal = clock;
    writeVarUint(this.restEncoder, diff);
  }
  /**
   * @param {number} len
   */
  writeDsLen(len) {
    if (len === 0) {
      unexpectedCase();
    }
    writeVarUint(this.restEncoder, len - 1);
    this.dsCurrVal += len;
  }
};
var UpdateEncoderV2 = class extends DSEncoderV2 {
  constructor() {
    super();
    this.keyMap = /* @__PURE__ */ new Map();
    this.keyClock = 0;
    this.keyClockEncoder = new IntDiffOptRleEncoder();
    this.clientEncoder = new UintOptRleEncoder();
    this.leftClockEncoder = new IntDiffOptRleEncoder();
    this.rightClockEncoder = new IntDiffOptRleEncoder();
    this.infoEncoder = new RleEncoder(writeUint8);
    this.stringEncoder = new StringEncoder();
    this.parentInfoEncoder = new RleEncoder(writeUint8);
    this.typeRefEncoder = new UintOptRleEncoder();
    this.lenEncoder = new UintOptRleEncoder();
  }
  toUint8Array() {
    const encoder2 = createEncoder();
    writeVarUint(encoder2, 0);
    writeVarUint8Array(encoder2, this.keyClockEncoder.toUint8Array());
    writeVarUint8Array(encoder2, this.clientEncoder.toUint8Array());
    writeVarUint8Array(encoder2, this.leftClockEncoder.toUint8Array());
    writeVarUint8Array(encoder2, this.rightClockEncoder.toUint8Array());
    writeVarUint8Array(encoder2, toUint8Array(this.infoEncoder));
    writeVarUint8Array(encoder2, this.stringEncoder.toUint8Array());
    writeVarUint8Array(encoder2, toUint8Array(this.parentInfoEncoder));
    writeVarUint8Array(encoder2, this.typeRefEncoder.toUint8Array());
    writeVarUint8Array(encoder2, this.lenEncoder.toUint8Array());
    writeUint8Array(encoder2, toUint8Array(this.restEncoder));
    return toUint8Array(encoder2);
  }
  /**
   * @param {ID} id
   */
  writeLeftID(id2) {
    this.clientEncoder.write(id2.client);
    this.leftClockEncoder.write(id2.clock);
  }
  /**
   * @param {ID} id
   */
  writeRightID(id2) {
    this.clientEncoder.write(id2.client);
    this.rightClockEncoder.write(id2.clock);
  }
  /**
   * @param {number} client
   */
  writeClient(client) {
    this.clientEncoder.write(client);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeInfo(info) {
    this.infoEncoder.write(info);
  }
  /**
   * @param {string} s
   */
  writeString(s2) {
    this.stringEncoder.write(s2);
  }
  /**
   * @param {boolean} isYKey
   */
  writeParentInfo(isYKey) {
    this.parentInfoEncoder.write(isYKey ? 1 : 0);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeTypeRef(info) {
    this.typeRefEncoder.write(info);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */
  writeLen(len) {
    this.lenEncoder.write(len);
  }
  /**
   * @param {any} any
   */
  writeAny(any2) {
    writeAny(this.restEncoder, any2);
  }
  /**
   * @param {Uint8Array} buf
   */
  writeBuf(buf) {
    writeVarUint8Array(this.restEncoder, buf);
  }
  /**
   * This is mainly here for legacy purposes.
   *
   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
   *
   * @param {any} embed
   */
  writeJSON(embed) {
    writeAny(this.restEncoder, embed);
  }
  /**
   * Property keys are often reused. For example, in y-prosemirror the key `bold` might
   * occur very often. For a 3d application, the key `position` might occur very often.
   *
   * We cache these keys in a Map and refer to them via a unique number.
   *
   * @param {string} key
   */
  writeKey(key) {
    const clock = this.keyMap.get(key);
    if (clock === void 0) {
      this.keyClockEncoder.write(this.keyClock++);
      this.stringEncoder.write(key);
    } else {
      this.keyClockEncoder.write(clock);
    }
  }
};
var writeStructs = (encoder2, structs, client, clock) => {
  clock = max(clock, structs[0].id.clock);
  const startNewStructs = findIndexSS(structs, clock);
  writeVarUint(encoder2.restEncoder, structs.length - startNewStructs);
  encoder2.writeClient(client);
  writeVarUint(encoder2.restEncoder, clock);
  const firstStruct = structs[startNewStructs];
  firstStruct.write(encoder2, clock - firstStruct.id.clock);
  for (let i2 = startNewStructs + 1; i2 < structs.length; i2++) {
    structs[i2].write(encoder2, 0);
  }
};
var writeClientsStructs = (encoder2, store, _sm) => {
  const sm = /* @__PURE__ */ new Map();
  _sm.forEach((clock, client) => {
    if (getState(store, client) > clock) {
      sm.set(client, clock);
    }
  });
  getStateVector(store).forEach((_clock, client) => {
    if (!_sm.has(client)) {
      sm.set(client, 0);
    }
  });
  writeVarUint(encoder2.restEncoder, sm.size);
  from(sm.entries()).sort((a, b) => b[0] - a[0]).forEach(([client, clock]) => {
    writeStructs(
      encoder2,
      /** @type {Array<GC|Item>} */
      store.clients.get(client),
      client,
      clock
    );
  });
};
var readClientsStructRefs = (decoder2, doc2) => {
  const clientRefs = create();
  const numOfStateUpdates = readVarUint(decoder2.restDecoder);
  for (let i2 = 0; i2 < numOfStateUpdates; i2++) {
    const numberOfStructs = readVarUint(decoder2.restDecoder);
    const refs = new Array(numberOfStructs);
    const client = decoder2.readClient();
    let clock = readVarUint(decoder2.restDecoder);
    clientRefs.set(client, { i: 0, refs });
    for (let i3 = 0; i3 < numberOfStructs; i3++) {
      const info = decoder2.readInfo();
      switch (BITS5 & info) {
        case 0: {
          const len = decoder2.readLen();
          refs[i3] = new GC(createID(client, clock), len);
          clock += len;
          break;
        }
        case 10: {
          const len = readVarUint(decoder2.restDecoder);
          refs[i3] = new Skip(createID(client, clock), len);
          clock += len;
          break;
        }
        default: {
          const cantCopyParentInfo = (info & (BIT7 | BIT8)) === 0;
          const struct = new Item(
            createID(client, clock),
            null,
            // leftd
            (info & BIT8) === BIT8 ? decoder2.readLeftID() : null,
            // origin
            null,
            // right
            (info & BIT7) === BIT7 ? decoder2.readRightID() : null,
            // right origin
            cantCopyParentInfo ? decoder2.readParentInfo() ? doc2.get(decoder2.readString()) : decoder2.readLeftID() : null,
            // parent
            cantCopyParentInfo && (info & BIT6) === BIT6 ? decoder2.readString() : null,
            // parentSub
            readItemContent(decoder2, info)
            // item content
          );
          refs[i3] = struct;
          clock += struct.length;
        }
      }
    }
  }
  return clientRefs;
};
var integrateStructs = (transaction, store, clientsStructRefs) => {
  const stack = [];
  let clientsStructRefsIds = from(clientsStructRefs.keys()).sort((a, b) => a - b);
  if (clientsStructRefsIds.length === 0) {
    return null;
  }
  const getNextStructTarget = () => {
    if (clientsStructRefsIds.length === 0) {
      return null;
    }
    let nextStructsTarget = (
      /** @type {{i:number,refs:Array<GC|Item>}} */
      clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1])
    );
    while (nextStructsTarget.refs.length === nextStructsTarget.i) {
      clientsStructRefsIds.pop();
      if (clientsStructRefsIds.length > 0) {
        nextStructsTarget = /** @type {{i:number,refs:Array<GC|Item>}} */
        clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]);
      } else {
        return null;
      }
    }
    return nextStructsTarget;
  };
  let curStructsTarget = getNextStructTarget();
  if (curStructsTarget === null) {
    return null;
  }
  const restStructs = new StructStore();
  const missingSV = /* @__PURE__ */ new Map();
  const updateMissingSv = (client, clock) => {
    const mclock = missingSV.get(client);
    if (mclock == null || mclock > clock) {
      missingSV.set(client, clock);
    }
  };
  let stackHead = (
    /** @type {any} */
    curStructsTarget.refs[
      /** @type {any} */
      curStructsTarget.i++
    ]
  );
  const state = /* @__PURE__ */ new Map();
  const addStackToRestSS = () => {
    for (const item of stack) {
      const client = item.id.client;
      const unapplicableItems = clientsStructRefs.get(client);
      if (unapplicableItems) {
        unapplicableItems.i--;
        restStructs.clients.set(client, unapplicableItems.refs.slice(unapplicableItems.i));
        clientsStructRefs.delete(client);
        unapplicableItems.i = 0;
        unapplicableItems.refs = [];
      } else {
        restStructs.clients.set(client, [item]);
      }
      clientsStructRefsIds = clientsStructRefsIds.filter((c) => c !== client);
    }
    stack.length = 0;
  };
  while (true) {
    if (stackHead.constructor !== Skip) {
      const localClock = setIfUndefined(state, stackHead.id.client, () => getState(store, stackHead.id.client));
      const offset = localClock - stackHead.id.clock;
      if (offset < 0) {
        stack.push(stackHead);
        updateMissingSv(stackHead.id.client, stackHead.id.clock - 1);
        addStackToRestSS();
      } else {
        const missing = stackHead.getMissing(transaction, store);
        if (missing !== null) {
          stack.push(stackHead);
          const structRefs = clientsStructRefs.get(
            /** @type {number} */
            missing
          ) || { refs: [], i: 0 };
          if (structRefs.refs.length === structRefs.i) {
            updateMissingSv(
              /** @type {number} */
              missing,
              getState(store, missing)
            );
            addStackToRestSS();
          } else {
            stackHead = structRefs.refs[structRefs.i++];
            continue;
          }
        } else if (offset === 0 || offset < stackHead.length) {
          stackHead.integrate(transaction, offset);
          state.set(stackHead.id.client, stackHead.id.clock + stackHead.length);
        }
      }
    }
    if (stack.length > 0) {
      stackHead = /** @type {GC|Item} */
      stack.pop();
    } else if (curStructsTarget !== null && curStructsTarget.i < curStructsTarget.refs.length) {
      stackHead = /** @type {GC|Item} */
      curStructsTarget.refs[curStructsTarget.i++];
    } else {
      curStructsTarget = getNextStructTarget();
      if (curStructsTarget === null) {
        break;
      } else {
        stackHead = /** @type {GC|Item} */
        curStructsTarget.refs[curStructsTarget.i++];
      }
    }
  }
  if (restStructs.clients.size > 0) {
    const encoder2 = new UpdateEncoderV2();
    writeClientsStructs(encoder2, restStructs, /* @__PURE__ */ new Map());
    writeVarUint(encoder2.restEncoder, 0);
    return { missing: missingSV, update: encoder2.toUint8Array() };
  }
  return null;
};
var writeStructsFromTransaction = (encoder2, transaction) => writeClientsStructs(encoder2, transaction.doc.store, transaction.beforeState);
var readUpdateV2 = (decoder2, ydoc, transactionOrigin, structDecoder = new UpdateDecoderV2(decoder2)) => transact(ydoc, (transaction) => {
  transaction.local = false;
  let retry = false;
  const doc2 = transaction.doc;
  const store = doc2.store;
  const ss = readClientsStructRefs(structDecoder, doc2);
  const restStructs = integrateStructs(transaction, store, ss);
  const pending = store.pendingStructs;
  if (pending) {
    for (const [client, clock] of pending.missing) {
      if (clock < getState(store, client)) {
        retry = true;
        break;
      }
    }
    if (restStructs) {
      for (const [client, clock] of restStructs.missing) {
        const mclock = pending.missing.get(client);
        if (mclock == null || mclock > clock) {
          pending.missing.set(client, clock);
        }
      }
      pending.update = mergeUpdatesV2([pending.update, restStructs.update]);
    }
  } else {
    store.pendingStructs = restStructs;
  }
  const dsRest = readAndApplyDeleteSet(structDecoder, transaction, store);
  if (store.pendingDs) {
    const pendingDSUpdate = new UpdateDecoderV2(createDecoder(store.pendingDs));
    readVarUint(pendingDSUpdate.restDecoder);
    const dsRest2 = readAndApplyDeleteSet(pendingDSUpdate, transaction, store);
    if (dsRest && dsRest2) {
      store.pendingDs = mergeUpdatesV2([dsRest, dsRest2]);
    } else {
      store.pendingDs = dsRest || dsRest2;
    }
  } else {
    store.pendingDs = dsRest;
  }
  if (retry) {
    const update2 = (
      /** @type {{update: Uint8Array}} */
      store.pendingStructs.update
    );
    store.pendingStructs = null;
    applyUpdateV2(transaction.doc, update2);
  }
}, transactionOrigin, false);
var applyUpdateV2 = (ydoc, update2, transactionOrigin, YDecoder = UpdateDecoderV2) => {
  const decoder2 = createDecoder(update2);
  readUpdateV2(decoder2, ydoc, transactionOrigin, new YDecoder(decoder2));
};
var applyUpdate = (ydoc, update2, transactionOrigin) => applyUpdateV2(ydoc, update2, transactionOrigin, UpdateDecoderV1);
var writeStateAsUpdate = (encoder2, doc2, targetStateVector = /* @__PURE__ */ new Map()) => {
  writeClientsStructs(encoder2, doc2.store, targetStateVector);
  writeDeleteSet(encoder2, createDeleteSetFromStructStore(doc2.store));
};
var encodeStateAsUpdateV2 = (doc2, encodedTargetStateVector = new Uint8Array([0]), encoder2 = new UpdateEncoderV2()) => {
  const targetStateVector = decodeStateVector(encodedTargetStateVector);
  writeStateAsUpdate(encoder2, doc2, targetStateVector);
  const updates = [encoder2.toUint8Array()];
  if (doc2.store.pendingDs) {
    updates.push(doc2.store.pendingDs);
  }
  if (doc2.store.pendingStructs) {
    updates.push(diffUpdateV2(doc2.store.pendingStructs.update, encodedTargetStateVector));
  }
  if (updates.length > 1) {
    if (encoder2.constructor === UpdateEncoderV1) {
      return mergeUpdates(updates.map((update2, i2) => i2 === 0 ? update2 : convertUpdateFormatV2ToV1(update2)));
    } else if (encoder2.constructor === UpdateEncoderV2) {
      return mergeUpdatesV2(updates);
    }
  }
  return updates[0];
};
var encodeStateAsUpdate = (doc2, encodedTargetStateVector) => encodeStateAsUpdateV2(doc2, encodedTargetStateVector, new UpdateEncoderV1());
var readStateVector = (decoder2) => {
  const ss = /* @__PURE__ */ new Map();
  const ssLength = readVarUint(decoder2.restDecoder);
  for (let i2 = 0; i2 < ssLength; i2++) {
    const client = readVarUint(decoder2.restDecoder);
    const clock = readVarUint(decoder2.restDecoder);
    ss.set(client, clock);
  }
  return ss;
};
var decodeStateVector = (decodedState) => readStateVector(new DSDecoderV1(createDecoder(decodedState)));
var writeStateVector = (encoder2, sv) => {
  writeVarUint(encoder2.restEncoder, sv.size);
  from(sv.entries()).sort((a, b) => b[0] - a[0]).forEach(([client, clock]) => {
    writeVarUint(encoder2.restEncoder, client);
    writeVarUint(encoder2.restEncoder, clock);
  });
  return encoder2;
};
var writeDocumentStateVector = (encoder2, doc2) => writeStateVector(encoder2, getStateVector(doc2.store));
var encodeStateVectorV2 = (doc2, encoder2 = new DSEncoderV2()) => {
  if (doc2 instanceof Map) {
    writeStateVector(encoder2, doc2);
  } else {
    writeDocumentStateVector(encoder2, doc2);
  }
  return encoder2.toUint8Array();
};
var encodeStateVector = (doc2) => encodeStateVectorV2(doc2, new DSEncoderV1());
var EventHandler = class {
  constructor() {
    this.l = [];
  }
};
var createEventHandler = () => new EventHandler();
var addEventHandlerListener = (eventHandler, f) => eventHandler.l.push(f);
var removeEventHandlerListener = (eventHandler, f) => {
  const l = eventHandler.l;
  const len = l.length;
  eventHandler.l = l.filter((g) => f !== g);
  if (len === eventHandler.l.length) {
    console.error("[yjs] Tried to remove event handler that doesn't exist.");
  }
};
var callEventHandlerListeners = (eventHandler, arg0, arg1) => callAll(eventHandler.l, [arg0, arg1]);
var ID = class {
  /**
   * @param {number} client client id
   * @param {number} clock unique per client id, continuous number
   */
  constructor(client, clock) {
    this.client = client;
    this.clock = clock;
  }
};
var compareIDs = (a, b) => a === b || a !== null && b !== null && a.client === b.client && a.clock === b.clock;
var createID = (client, clock) => new ID(client, clock);
var findRootTypeKey = (type) => {
  for (const [key, value] of type.doc.share.entries()) {
    if (value === type) {
      return key;
    }
  }
  throw unexpectedCase();
};
var RelativePosition = class {
  /**
   * @param {ID|null} type
   * @param {string|null} tname
   * @param {ID|null} item
   * @param {number} assoc
   */
  constructor(type, tname, item, assoc = 0) {
    this.type = type;
    this.tname = tname;
    this.item = item;
    this.assoc = assoc;
  }
};
var createRelativePositionFromJSON = (json) => new RelativePosition(json.type == null ? null : createID(json.type.client, json.type.clock), json.tname || null, json.item == null ? null : createID(json.item.client, json.item.clock), json.assoc == null ? 0 : json.assoc);
var AbsolutePosition = class {
  /**
   * @param {AbstractType<any>} type
   * @param {number} index
   * @param {number} [assoc]
   */
  constructor(type, index, assoc = 0) {
    this.type = type;
    this.index = index;
    this.assoc = assoc;
  }
};
var createAbsolutePosition = (type, index, assoc = 0) => new AbsolutePosition(type, index, assoc);
var createRelativePosition = (type, item, assoc) => {
  let typeid = null;
  let tname = null;
  if (type._item === null) {
    tname = findRootTypeKey(type);
  } else {
    typeid = createID(type._item.id.client, type._item.id.clock);
  }
  return new RelativePosition(typeid, tname, item, assoc);
};
var createRelativePositionFromTypeIndex = (type, index, assoc = 0) => {
  let t2 = type._start;
  if (assoc < 0) {
    if (index === 0) {
      return createRelativePosition(type, null, assoc);
    }
    index--;
  }
  while (t2 !== null) {
    if (!t2.deleted && t2.countable) {
      if (t2.length > index) {
        return createRelativePosition(type, createID(t2.id.client, t2.id.clock + index), assoc);
      }
      index -= t2.length;
    }
    if (t2.right === null && assoc < 0) {
      return createRelativePosition(type, t2.lastId, assoc);
    }
    t2 = t2.right;
  }
  return createRelativePosition(type, null, assoc);
};
var createAbsolutePositionFromRelativePosition = (rpos, doc2) => {
  const store = doc2.store;
  const rightID = rpos.item;
  const typeID = rpos.type;
  const tname = rpos.tname;
  const assoc = rpos.assoc;
  let type = null;
  let index = 0;
  if (rightID !== null) {
    if (getState(store, rightID.client) <= rightID.clock) {
      return null;
    }
    const res = followRedone(store, rightID);
    const right = res.item;
    if (!(right instanceof Item)) {
      return null;
    }
    type = /** @type {AbstractType<any>} */
    right.parent;
    if (type._item === null || !type._item.deleted) {
      index = right.deleted || !right.countable ? 0 : res.diff + (assoc >= 0 ? 0 : 1);
      let n = right.left;
      while (n !== null) {
        if (!n.deleted && n.countable) {
          index += n.length;
        }
        n = n.left;
      }
    }
  } else {
    if (tname !== null) {
      type = doc2.get(tname);
    } else if (typeID !== null) {
      if (getState(store, typeID.client) <= typeID.clock) {
        return null;
      }
      const { item } = followRedone(store, typeID);
      if (item instanceof Item && item.content instanceof ContentType) {
        type = item.content.type;
      } else {
        return null;
      }
    } else {
      throw unexpectedCase();
    }
    if (assoc >= 0) {
      index = type._length;
    } else {
      index = 0;
    }
  }
  return createAbsolutePosition(type, index, rpos.assoc);
};
var compareRelativePositions = (a, b) => a === b || a !== null && b !== null && a.tname === b.tname && compareIDs(a.item, b.item) && compareIDs(a.type, b.type) && a.assoc === b.assoc;
var Snapshot = class {
  /**
   * @param {DeleteSet} ds
   * @param {Map<number,number>} sv state map
   */
  constructor(ds, sv) {
    this.ds = ds;
    this.sv = sv;
  }
};
var createSnapshot = (ds, sm) => new Snapshot(ds, sm);
var emptySnapshot = createSnapshot(createDeleteSet(), /* @__PURE__ */ new Map());
var isVisible = (item, snapshot) => snapshot === void 0 ? !item.deleted : snapshot.sv.has(item.id.client) && (snapshot.sv.get(item.id.client) || 0) > item.id.clock && !isDeleted(snapshot.ds, item.id);
var splitSnapshotAffectedStructs = (transaction, snapshot) => {
  const meta = setIfUndefined(transaction.meta, splitSnapshotAffectedStructs, create2);
  const store = transaction.doc.store;
  if (!meta.has(snapshot)) {
    snapshot.sv.forEach((clock, client) => {
      if (clock < getState(store, client)) {
        getItemCleanStart(transaction, createID(client, clock));
      }
    });
    iterateDeletedStructs(transaction, snapshot.ds, (_item) => {
    });
    meta.add(snapshot);
  }
};
var StructStore = class {
  constructor() {
    this.clients = /* @__PURE__ */ new Map();
    this.pendingStructs = null;
    this.pendingDs = null;
  }
};
var getStateVector = (store) => {
  const sm = /* @__PURE__ */ new Map();
  store.clients.forEach((structs, client) => {
    const struct = structs[structs.length - 1];
    sm.set(client, struct.id.clock + struct.length);
  });
  return sm;
};
var getState = (store, client) => {
  const structs = store.clients.get(client);
  if (structs === void 0) {
    return 0;
  }
  const lastStruct = structs[structs.length - 1];
  return lastStruct.id.clock + lastStruct.length;
};
var addStruct = (store, struct) => {
  let structs = store.clients.get(struct.id.client);
  if (structs === void 0) {
    structs = [];
    store.clients.set(struct.id.client, structs);
  } else {
    const lastStruct = structs[structs.length - 1];
    if (lastStruct.id.clock + lastStruct.length !== struct.id.clock) {
      throw unexpectedCase();
    }
  }
  structs.push(struct);
};
var findIndexSS = (structs, clock) => {
  let left = 0;
  let right = structs.length - 1;
  let mid = structs[right];
  let midclock = mid.id.clock;
  if (midclock === clock) {
    return right;
  }
  let midindex = floor(clock / (midclock + mid.length - 1) * right);
  while (left <= right) {
    mid = structs[midindex];
    midclock = mid.id.clock;
    if (midclock <= clock) {
      if (clock < midclock + mid.length) {
        return midindex;
      }
      left = midindex + 1;
    } else {
      right = midindex - 1;
    }
    midindex = floor((left + right) / 2);
  }
  throw unexpectedCase();
};
var find = (store, id2) => {
  const structs = store.clients.get(id2.client);
  return structs[findIndexSS(structs, id2.clock)];
};
var getItem = (
  /** @type {function(StructStore,ID):Item} */
  find
);
var findIndexCleanStart = (transaction, structs, clock) => {
  const index = findIndexSS(structs, clock);
  const struct = structs[index];
  if (struct.id.clock < clock && struct instanceof Item) {
    structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));
    return index + 1;
  }
  return index;
};
var getItemCleanStart = (transaction, id2) => {
  const structs = (
    /** @type {Array<Item>} */
    transaction.doc.store.clients.get(id2.client)
  );
  return structs[findIndexCleanStart(transaction, structs, id2.clock)];
};
var getItemCleanEnd = (transaction, store, id2) => {
  const structs = store.clients.get(id2.client);
  const index = findIndexSS(structs, id2.clock);
  const struct = structs[index];
  if (id2.clock !== struct.id.clock + struct.length - 1 && struct.constructor !== GC) {
    structs.splice(index + 1, 0, splitItem(transaction, struct, id2.clock - struct.id.clock + 1));
  }
  return struct;
};
var replaceStruct = (store, struct, newStruct) => {
  const structs = (
    /** @type {Array<GC|Item>} */
    store.clients.get(struct.id.client)
  );
  structs[findIndexSS(structs, struct.id.clock)] = newStruct;
};
var iterateStructs = (transaction, structs, clockStart, len, f) => {
  if (len === 0) {
    return;
  }
  const clockEnd = clockStart + len;
  let index = findIndexCleanStart(transaction, structs, clockStart);
  let struct;
  do {
    struct = structs[index++];
    if (clockEnd < struct.id.clock + struct.length) {
      findIndexCleanStart(transaction, structs, clockEnd);
    }
    f(struct);
  } while (index < structs.length && structs[index].id.clock < clockEnd);
};
var Transaction = class {
  /**
   * @param {Doc} doc
   * @param {any} origin
   * @param {boolean} local
   */
  constructor(doc2, origin, local) {
    this.doc = doc2;
    this.deleteSet = new DeleteSet();
    this.beforeState = getStateVector(doc2.store);
    this.afterState = /* @__PURE__ */ new Map();
    this.changed = /* @__PURE__ */ new Map();
    this.changedParentTypes = /* @__PURE__ */ new Map();
    this._mergeStructs = [];
    this.origin = origin;
    this.meta = /* @__PURE__ */ new Map();
    this.local = local;
    this.subdocsAdded = /* @__PURE__ */ new Set();
    this.subdocsRemoved = /* @__PURE__ */ new Set();
    this.subdocsLoaded = /* @__PURE__ */ new Set();
    this._needFormattingCleanup = false;
  }
};
var writeUpdateMessageFromTransaction = (encoder2, transaction) => {
  if (transaction.deleteSet.clients.size === 0 && !any(transaction.afterState, (clock, client) => transaction.beforeState.get(client) !== clock)) {
    return false;
  }
  sortAndMergeDeleteSet(transaction.deleteSet);
  writeStructsFromTransaction(encoder2, transaction);
  writeDeleteSet(encoder2, transaction.deleteSet);
  return true;
};
var addChangedTypeToTransaction = (transaction, type, parentSub) => {
  const item = type._item;
  if (item === null || item.id.clock < (transaction.beforeState.get(item.id.client) || 0) && !item.deleted) {
    setIfUndefined(transaction.changed, type, create2).add(parentSub);
  }
};
var tryToMergeWithLefts = (structs, pos) => {
  let right = structs[pos];
  let left = structs[pos - 1];
  let i2 = pos;
  for (; i2 > 0; right = left, left = structs[--i2 - 1]) {
    if (left.deleted === right.deleted && left.constructor === right.constructor) {
      if (left.mergeWith(right)) {
        if (right instanceof Item && right.parentSub !== null && /** @type {AbstractType<any>} */
        right.parent._map.get(right.parentSub) === right) {
          right.parent._map.set(
            right.parentSub,
            /** @type {Item} */
            left
          );
        }
        continue;
      }
    }
    break;
  }
  const merged = pos - i2;
  if (merged) {
    structs.splice(pos + 1 - merged, merged);
  }
  return merged;
};
var tryGcDeleteSet = (ds, store, gcFilter) => {
  for (const [client, deleteItems] of ds.clients.entries()) {
    const structs = (
      /** @type {Array<GC|Item>} */
      store.clients.get(client)
    );
    for (let di = deleteItems.length - 1; di >= 0; di--) {
      const deleteItem = deleteItems[di];
      const endDeleteItemClock = deleteItem.clock + deleteItem.len;
      for (let si = findIndexSS(structs, deleteItem.clock), struct = structs[si]; si < structs.length && struct.id.clock < endDeleteItemClock; struct = structs[++si]) {
        const struct2 = structs[si];
        if (deleteItem.clock + deleteItem.len <= struct2.id.clock) {
          break;
        }
        if (struct2 instanceof Item && struct2.deleted && !struct2.keep && gcFilter(struct2)) {
          struct2.gc(store, false);
        }
      }
    }
  }
};
var tryMergeDeleteSet = (ds, store) => {
  ds.clients.forEach((deleteItems, client) => {
    const structs = (
      /** @type {Array<GC|Item>} */
      store.clients.get(client)
    );
    for (let di = deleteItems.length - 1; di >= 0; di--) {
      const deleteItem = deleteItems[di];
      const mostRightIndexToCheck = min(structs.length - 1, 1 + findIndexSS(structs, deleteItem.clock + deleteItem.len - 1));
      for (let si = mostRightIndexToCheck, struct = structs[si]; si > 0 && struct.id.clock >= deleteItem.clock; struct = structs[si]) {
        si -= 1 + tryToMergeWithLefts(structs, si);
      }
    }
  });
};
var cleanupTransactions = (transactionCleanups, i2) => {
  if (i2 < transactionCleanups.length) {
    const transaction = transactionCleanups[i2];
    const doc2 = transaction.doc;
    const store = doc2.store;
    const ds = transaction.deleteSet;
    const mergeStructs = transaction._mergeStructs;
    try {
      sortAndMergeDeleteSet(ds);
      transaction.afterState = getStateVector(transaction.doc.store);
      doc2.emit("beforeObserverCalls", [transaction, doc2]);
      const fs = [];
      transaction.changed.forEach(
        (subs, itemtype) => fs.push(() => {
          if (itemtype._item === null || !itemtype._item.deleted) {
            itemtype._callObserver(transaction, subs);
          }
        })
      );
      fs.push(() => {
        transaction.changedParentTypes.forEach((events, type) => {
          if (type._dEH.l.length > 0 && (type._item === null || !type._item.deleted)) {
            events = events.filter(
              (event) => event.target._item === null || !event.target._item.deleted
            );
            events.forEach((event) => {
              event.currentTarget = type;
              event._path = null;
            });
            events.sort((event1, event2) => event1.path.length - event2.path.length);
            callEventHandlerListeners(type._dEH, events, transaction);
          }
        });
      });
      fs.push(() => doc2.emit("afterTransaction", [transaction, doc2]));
      callAll(fs, []);
      if (transaction._needFormattingCleanup) {
        cleanupYTextAfterTransaction(transaction);
      }
    } finally {
      if (doc2.gc) {
        tryGcDeleteSet(ds, store, doc2.gcFilter);
      }
      tryMergeDeleteSet(ds, store);
      transaction.afterState.forEach((clock, client) => {
        const beforeClock = transaction.beforeState.get(client) || 0;
        if (beforeClock !== clock) {
          const structs = (
            /** @type {Array<GC|Item>} */
            store.clients.get(client)
          );
          const firstChangePos = max(findIndexSS(structs, beforeClock), 1);
          for (let i3 = structs.length - 1; i3 >= firstChangePos; ) {
            i3 -= 1 + tryToMergeWithLefts(structs, i3);
          }
        }
      });
      for (let i3 = mergeStructs.length - 1; i3 >= 0; i3--) {
        const { client, clock } = mergeStructs[i3].id;
        const structs = (
          /** @type {Array<GC|Item>} */
          store.clients.get(client)
        );
        const replacedStructPos = findIndexSS(structs, clock);
        if (replacedStructPos + 1 < structs.length) {
          if (tryToMergeWithLefts(structs, replacedStructPos + 1) > 1) {
            continue;
          }
        }
        if (replacedStructPos > 0) {
          tryToMergeWithLefts(structs, replacedStructPos);
        }
      }
      if (!transaction.local && transaction.afterState.get(doc2.clientID) !== transaction.beforeState.get(doc2.clientID)) {
        print(ORANGE, BOLD, "[yjs] ", UNBOLD, RED, "Changed the client-id because another client seems to be using it.");
        doc2.clientID = generateNewClientId();
      }
      doc2.emit("afterTransactionCleanup", [transaction, doc2]);
      if (doc2._observers.has("update")) {
        const encoder2 = new UpdateEncoderV1();
        const hasContent2 = writeUpdateMessageFromTransaction(encoder2, transaction);
        if (hasContent2) {
          doc2.emit("update", [encoder2.toUint8Array(), transaction.origin, doc2, transaction]);
        }
      }
      if (doc2._observers.has("updateV2")) {
        const encoder2 = new UpdateEncoderV2();
        const hasContent2 = writeUpdateMessageFromTransaction(encoder2, transaction);
        if (hasContent2) {
          doc2.emit("updateV2", [encoder2.toUint8Array(), transaction.origin, doc2, transaction]);
        }
      }
      const { subdocsAdded, subdocsLoaded, subdocsRemoved } = transaction;
      if (subdocsAdded.size > 0 || subdocsRemoved.size > 0 || subdocsLoaded.size > 0) {
        subdocsAdded.forEach((subdoc) => {
          subdoc.clientID = doc2.clientID;
          if (subdoc.collectionid == null) {
            subdoc.collectionid = doc2.collectionid;
          }
          doc2.subdocs.add(subdoc);
        });
        subdocsRemoved.forEach((subdoc) => doc2.subdocs.delete(subdoc));
        doc2.emit("subdocs", [{ loaded: subdocsLoaded, added: subdocsAdded, removed: subdocsRemoved }, doc2, transaction]);
        subdocsRemoved.forEach((subdoc) => subdoc.destroy());
      }
      if (transactionCleanups.length <= i2 + 1) {
        doc2._transactionCleanups = [];
        doc2.emit("afterAllTransactions", [doc2, transactionCleanups]);
      } else {
        cleanupTransactions(transactionCleanups, i2 + 1);
      }
    }
  }
};
var transact = (doc2, f, origin = null, local = true) => {
  const transactionCleanups = doc2._transactionCleanups;
  let initialCall = false;
  let result = null;
  if (doc2._transaction === null) {
    initialCall = true;
    doc2._transaction = new Transaction(doc2, origin, local);
    transactionCleanups.push(doc2._transaction);
    if (transactionCleanups.length === 1) {
      doc2.emit("beforeAllTransactions", [doc2]);
    }
    doc2.emit("beforeTransaction", [doc2._transaction, doc2]);
  }
  try {
    result = f(doc2._transaction);
  } finally {
    if (initialCall) {
      const finishCleanup = doc2._transaction === transactionCleanups[0];
      doc2._transaction = null;
      if (finishCleanup) {
        cleanupTransactions(transactionCleanups, 0);
      }
    }
  }
  return result;
};
function* lazyStructReaderGenerator(decoder2) {
  const numOfStateUpdates = readVarUint(decoder2.restDecoder);
  for (let i2 = 0; i2 < numOfStateUpdates; i2++) {
    const numberOfStructs = readVarUint(decoder2.restDecoder);
    const client = decoder2.readClient();
    let clock = readVarUint(decoder2.restDecoder);
    for (let i3 = 0; i3 < numberOfStructs; i3++) {
      const info = decoder2.readInfo();
      if (info === 10) {
        const len = readVarUint(decoder2.restDecoder);
        yield new Skip(createID(client, clock), len);
        clock += len;
      } else if ((BITS5 & info) !== 0) {
        const cantCopyParentInfo = (info & (BIT7 | BIT8)) === 0;
        const struct = new Item(
          createID(client, clock),
          null,
          // left
          (info & BIT8) === BIT8 ? decoder2.readLeftID() : null,
          // origin
          null,
          // right
          (info & BIT7) === BIT7 ? decoder2.readRightID() : null,
          // right origin
          // @ts-ignore Force writing a string here.
          cantCopyParentInfo ? decoder2.readParentInfo() ? decoder2.readString() : decoder2.readLeftID() : null,
          // parent
          cantCopyParentInfo && (info & BIT6) === BIT6 ? decoder2.readString() : null,
          // parentSub
          readItemContent(decoder2, info)
          // item content
        );
        yield struct;
        clock += struct.length;
      } else {
        const len = decoder2.readLen();
        yield new GC(createID(client, clock), len);
        clock += len;
      }
    }
  }
}
var LazyStructReader = class {
  /**
   * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
   * @param {boolean} filterSkips
   */
  constructor(decoder2, filterSkips) {
    this.gen = lazyStructReaderGenerator(decoder2);
    this.curr = null;
    this.done = false;
    this.filterSkips = filterSkips;
    this.next();
  }
  /**
   * @return {Item | GC | Skip |null}
   */
  next() {
    do {
      this.curr = this.gen.next().value || null;
    } while (this.filterSkips && this.curr !== null && this.curr.constructor === Skip);
    return this.curr;
  }
};
var LazyStructWriter = class {
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  constructor(encoder2) {
    this.currClient = 0;
    this.startClock = 0;
    this.written = 0;
    this.encoder = encoder2;
    this.clientStructs = [];
  }
};
var mergeUpdates = (updates) => mergeUpdatesV2(updates, UpdateDecoderV1, UpdateEncoderV1);
var sliceStruct = (left, diff) => {
  if (left.constructor === GC) {
    const { client, clock } = left.id;
    return new GC(createID(client, clock + diff), left.length - diff);
  } else if (left.constructor === Skip) {
    const { client, clock } = left.id;
    return new Skip(createID(client, clock + diff), left.length - diff);
  } else {
    const leftItem = (
      /** @type {Item} */
      left
    );
    const { client, clock } = leftItem.id;
    return new Item(
      createID(client, clock + diff),
      null,
      createID(client, clock + diff - 1),
      null,
      leftItem.rightOrigin,
      leftItem.parent,
      leftItem.parentSub,
      leftItem.content.splice(diff)
    );
  }
};
var mergeUpdatesV2 = (updates, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {
  if (updates.length === 1) {
    return updates[0];
  }
  const updateDecoders = updates.map((update2) => new YDecoder(createDecoder(update2)));
  let lazyStructDecoders = updateDecoders.map((decoder2) => new LazyStructReader(decoder2, true));
  let currWrite = null;
  const updateEncoder = new YEncoder();
  const lazyStructEncoder = new LazyStructWriter(updateEncoder);
  while (true) {
    lazyStructDecoders = lazyStructDecoders.filter((dec) => dec.curr !== null);
    lazyStructDecoders.sort(
      /** @type {function(any,any):number} */
      (dec1, dec2) => {
        if (dec1.curr.id.client === dec2.curr.id.client) {
          const clockDiff = dec1.curr.id.clock - dec2.curr.id.clock;
          if (clockDiff === 0) {
            return dec1.curr.constructor === dec2.curr.constructor ? 0 : dec1.curr.constructor === Skip ? 1 : -1;
          } else {
            return clockDiff;
          }
        } else {
          return dec2.curr.id.client - dec1.curr.id.client;
        }
      }
    );
    if (lazyStructDecoders.length === 0) {
      break;
    }
    const currDecoder = lazyStructDecoders[0];
    const firstClient = (
      /** @type {Item | GC} */
      currDecoder.curr.id.client
    );
    if (currWrite !== null) {
      let curr = (
        /** @type {Item | GC | null} */
        currDecoder.curr
      );
      let iterated = false;
      while (curr !== null && curr.id.clock + curr.length <= currWrite.struct.id.clock + currWrite.struct.length && curr.id.client >= currWrite.struct.id.client) {
        curr = currDecoder.next();
        iterated = true;
      }
      if (curr === null || // current decoder is empty
      curr.id.client !== firstClient || // check whether there is another decoder that has has updates from `firstClient`
      iterated && curr.id.clock > currWrite.struct.id.clock + currWrite.struct.length) {
        continue;
      }
      if (firstClient !== currWrite.struct.id.client) {
        writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
        currWrite = { struct: curr, offset: 0 };
        currDecoder.next();
      } else {
        if (currWrite.struct.id.clock + currWrite.struct.length < curr.id.clock) {
          if (currWrite.struct.constructor === Skip) {
            currWrite.struct.length = curr.id.clock + curr.length - currWrite.struct.id.clock;
          } else {
            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
            const diff = curr.id.clock - currWrite.struct.id.clock - currWrite.struct.length;
            const struct = new Skip(createID(firstClient, currWrite.struct.id.clock + currWrite.struct.length), diff);
            currWrite = { struct, offset: 0 };
          }
        } else {
          const diff = currWrite.struct.id.clock + currWrite.struct.length - curr.id.clock;
          if (diff > 0) {
            if (currWrite.struct.constructor === Skip) {
              currWrite.struct.length -= diff;
            } else {
              curr = sliceStruct(curr, diff);
            }
          }
          if (!currWrite.struct.mergeWith(
            /** @type {any} */
            curr
          )) {
            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
            currWrite = { struct: curr, offset: 0 };
            currDecoder.next();
          }
        }
      }
    } else {
      currWrite = { struct: (
        /** @type {Item | GC} */
        currDecoder.curr
      ), offset: 0 };
      currDecoder.next();
    }
    for (let next = currDecoder.curr; next !== null && next.id.client === firstClient && next.id.clock === currWrite.struct.id.clock + currWrite.struct.length && next.constructor !== Skip; next = currDecoder.next()) {
      writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
      currWrite = { struct: next, offset: 0 };
    }
  }
  if (currWrite !== null) {
    writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
    currWrite = null;
  }
  finishLazyStructWriting(lazyStructEncoder);
  const dss = updateDecoders.map((decoder2) => readDeleteSet(decoder2));
  const ds = mergeDeleteSets(dss);
  writeDeleteSet(updateEncoder, ds);
  return updateEncoder.toUint8Array();
};
var diffUpdateV2 = (update2, sv, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {
  const state = decodeStateVector(sv);
  const encoder2 = new YEncoder();
  const lazyStructWriter = new LazyStructWriter(encoder2);
  const decoder2 = new YDecoder(createDecoder(update2));
  const reader = new LazyStructReader(decoder2, false);
  while (reader.curr) {
    const curr = reader.curr;
    const currClient = curr.id.client;
    const svClock = state.get(currClient) || 0;
    if (reader.curr.constructor === Skip) {
      reader.next();
      continue;
    }
    if (curr.id.clock + curr.length > svClock) {
      writeStructToLazyStructWriter(lazyStructWriter, curr, max(svClock - curr.id.clock, 0));
      reader.next();
      while (reader.curr && reader.curr.id.client === currClient) {
        writeStructToLazyStructWriter(lazyStructWriter, reader.curr, 0);
        reader.next();
      }
    } else {
      while (reader.curr && reader.curr.id.client === currClient && reader.curr.id.clock + reader.curr.length <= svClock) {
        reader.next();
      }
    }
  }
  finishLazyStructWriting(lazyStructWriter);
  const ds = readDeleteSet(decoder2);
  writeDeleteSet(encoder2, ds);
  return encoder2.toUint8Array();
};
var flushLazyStructWriter = (lazyWriter) => {
  if (lazyWriter.written > 0) {
    lazyWriter.clientStructs.push({ written: lazyWriter.written, restEncoder: toUint8Array(lazyWriter.encoder.restEncoder) });
    lazyWriter.encoder.restEncoder = createEncoder();
    lazyWriter.written = 0;
  }
};
var writeStructToLazyStructWriter = (lazyWriter, struct, offset) => {
  if (lazyWriter.written > 0 && lazyWriter.currClient !== struct.id.client) {
    flushLazyStructWriter(lazyWriter);
  }
  if (lazyWriter.written === 0) {
    lazyWriter.currClient = struct.id.client;
    lazyWriter.encoder.writeClient(struct.id.client);
    writeVarUint(lazyWriter.encoder.restEncoder, struct.id.clock + offset);
  }
  struct.write(lazyWriter.encoder, offset);
  lazyWriter.written++;
};
var finishLazyStructWriting = (lazyWriter) => {
  flushLazyStructWriter(lazyWriter);
  const restEncoder = lazyWriter.encoder.restEncoder;
  writeVarUint(restEncoder, lazyWriter.clientStructs.length);
  for (let i2 = 0; i2 < lazyWriter.clientStructs.length; i2++) {
    const partStructs = lazyWriter.clientStructs[i2];
    writeVarUint(restEncoder, partStructs.written);
    writeUint8Array(restEncoder, partStructs.restEncoder);
  }
};
var convertUpdateFormat = (update2, blockTransformer, YDecoder, YEncoder) => {
  const updateDecoder = new YDecoder(createDecoder(update2));
  const lazyDecoder = new LazyStructReader(updateDecoder, false);
  const updateEncoder = new YEncoder();
  const lazyWriter = new LazyStructWriter(updateEncoder);
  for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {
    writeStructToLazyStructWriter(lazyWriter, blockTransformer(curr), 0);
  }
  finishLazyStructWriting(lazyWriter);
  const ds = readDeleteSet(updateDecoder);
  writeDeleteSet(updateEncoder, ds);
  return updateEncoder.toUint8Array();
};
var convertUpdateFormatV2ToV1 = (update2) => convertUpdateFormat(update2, id, UpdateDecoderV2, UpdateEncoderV1);
var errorComputeChanges = "You must not compute changes after the event-handler fired.";
var YEvent = class {
  /**
   * @param {T} target The changed type.
   * @param {Transaction} transaction
   */
  constructor(target, transaction) {
    this.target = target;
    this.currentTarget = target;
    this.transaction = transaction;
    this._changes = null;
    this._keys = null;
    this._delta = null;
    this._path = null;
  }
  /**
   * Computes the path from `y` to the changed type.
   *
   * @todo v14 should standardize on path: Array<{parent, index}> because that is easier to work with.
   *
   * The following property holds:
   * @example
   *   let type = y
   *   event.path.forEach(dir => {
   *     type = type.get(dir)
   *   })
   *   type === event.target // => true
   */
  get path() {
    return this._path || (this._path = getPathTo(this.currentTarget, this.target));
  }
  /**
   * Check if a struct is deleted by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */
  deletes(struct) {
    return isDeleted(this.transaction.deleteSet, struct.id);
  }
  /**
   * @type {Map<string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }>}
   */
  get keys() {
    if (this._keys === null) {
      if (this.transaction.doc._transactionCleanups.length === 0) {
        throw create3(errorComputeChanges);
      }
      const keys2 = /* @__PURE__ */ new Map();
      const target = this.target;
      const changed = (
        /** @type Set<string|null> */
        this.transaction.changed.get(target)
      );
      changed.forEach((key) => {
        if (key !== null) {
          const item = (
            /** @type {Item} */
            target._map.get(key)
          );
          let action;
          let oldValue;
          if (this.adds(item)) {
            let prev = item.left;
            while (prev !== null && this.adds(prev)) {
              prev = prev.left;
            }
            if (this.deletes(item)) {
              if (prev !== null && this.deletes(prev)) {
                action = "delete";
                oldValue = last(prev.content.getContent());
              } else {
                return;
              }
            } else {
              if (prev !== null && this.deletes(prev)) {
                action = "update";
                oldValue = last(prev.content.getContent());
              } else {
                action = "add";
                oldValue = void 0;
              }
            }
          } else {
            if (this.deletes(item)) {
              action = "delete";
              oldValue = last(
                /** @type {Item} */
                item.content.getContent()
              );
            } else {
              return;
            }
          }
          keys2.set(key, { action, oldValue });
        }
      });
      this._keys = keys2;
    }
    return this._keys;
  }
  /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {Array<{insert?: string | Array<any> | object | AbstractType<any>, retain?: number, delete?: number, attributes?: Object<string, any>}>}
   */
  get delta() {
    return this.changes.delta;
  }
  /**
   * Check if a struct is added by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */
  adds(struct) {
    return struct.id.clock >= (this.transaction.beforeState.get(struct.id.client) || 0);
  }
  /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */
  get changes() {
    let changes = this._changes;
    if (changes === null) {
      if (this.transaction.doc._transactionCleanups.length === 0) {
        throw create3(errorComputeChanges);
      }
      const target = this.target;
      const added = create2();
      const deleted = create2();
      const delta = [];
      changes = {
        added,
        deleted,
        delta,
        keys: this.keys
      };
      const changed = (
        /** @type Set<string|null> */
        this.transaction.changed.get(target)
      );
      if (changed.has(null)) {
        let lastOp = null;
        const packOp = () => {
          if (lastOp) {
            delta.push(lastOp);
          }
        };
        for (let item = target._start; item !== null; item = item.right) {
          if (item.deleted) {
            if (this.deletes(item) && !this.adds(item)) {
              if (lastOp === null || lastOp.delete === void 0) {
                packOp();
                lastOp = { delete: 0 };
              }
              lastOp.delete += item.length;
              deleted.add(item);
            }
          } else {
            if (this.adds(item)) {
              if (lastOp === null || lastOp.insert === void 0) {
                packOp();
                lastOp = { insert: [] };
              }
              lastOp.insert = lastOp.insert.concat(item.content.getContent());
              added.add(item);
            } else {
              if (lastOp === null || lastOp.retain === void 0) {
                packOp();
                lastOp = { retain: 0 };
              }
              lastOp.retain += item.length;
            }
          }
        }
        if (lastOp !== null && lastOp.retain === void 0) {
          packOp();
        }
      }
      this._changes = changes;
    }
    return (
      /** @type {any} */
      changes
    );
  }
};
var getPathTo = (parent, child) => {
  const path2 = [];
  while (child._item !== null && child !== parent) {
    if (child._item.parentSub !== null) {
      path2.unshift(child._item.parentSub);
    } else {
      let i2 = 0;
      let c = (
        /** @type {AbstractType<any>} */
        child._item.parent._start
      );
      while (c !== child._item && c !== null) {
        if (!c.deleted) {
          i2++;
        }
        c = c.right;
      }
      path2.unshift(i2);
    }
    child = /** @type {AbstractType<any>} */
    child._item.parent;
  }
  return path2;
};
var maxSearchMarker = 80;
var globalSearchMarkerTimestamp = 0;
var ArraySearchMarker = class {
  /**
   * @param {Item} p
   * @param {number} index
   */
  constructor(p, index) {
    p.marker = true;
    this.p = p;
    this.index = index;
    this.timestamp = globalSearchMarkerTimestamp++;
  }
};
var refreshMarkerTimestamp = (marker) => {
  marker.timestamp = globalSearchMarkerTimestamp++;
};
var overwriteMarker = (marker, p, index) => {
  marker.p.marker = false;
  marker.p = p;
  p.marker = true;
  marker.index = index;
  marker.timestamp = globalSearchMarkerTimestamp++;
};
var markPosition = (searchMarker, p, index) => {
  if (searchMarker.length >= maxSearchMarker) {
    const marker = searchMarker.reduce((a, b) => a.timestamp < b.timestamp ? a : b);
    overwriteMarker(marker, p, index);
    return marker;
  } else {
    const pm = new ArraySearchMarker(p, index);
    searchMarker.push(pm);
    return pm;
  }
};
var findMarker = (yarray, index) => {
  if (yarray._start === null || index === 0 || yarray._searchMarker === null) {
    return null;
  }
  const marker = yarray._searchMarker.length === 0 ? null : yarray._searchMarker.reduce((a, b) => abs(index - a.index) < abs(index - b.index) ? a : b);
  let p = yarray._start;
  let pindex = 0;
  if (marker !== null) {
    p = marker.p;
    pindex = marker.index;
    refreshMarkerTimestamp(marker);
  }
  while (p.right !== null && pindex < index) {
    if (!p.deleted && p.countable) {
      if (index < pindex + p.length) {
        break;
      }
      pindex += p.length;
    }
    p = p.right;
  }
  while (p.left !== null && pindex > index) {
    p = p.left;
    if (!p.deleted && p.countable) {
      pindex -= p.length;
    }
  }
  while (p.left !== null && p.left.id.client === p.id.client && p.left.id.clock + p.left.length === p.id.clock) {
    p = p.left;
    if (!p.deleted && p.countable) {
      pindex -= p.length;
    }
  }
  if (marker !== null && abs(marker.index - pindex) < /** @type {YText|YArray<any>} */
  p.parent.length / maxSearchMarker) {
    overwriteMarker(marker, p, pindex);
    return marker;
  } else {
    return markPosition(yarray._searchMarker, p, pindex);
  }
};
var updateMarkerChanges = (searchMarker, index, len) => {
  for (let i2 = searchMarker.length - 1; i2 >= 0; i2--) {
    const m = searchMarker[i2];
    if (len > 0) {
      let p = m.p;
      p.marker = false;
      while (p && (p.deleted || !p.countable)) {
        p = p.left;
        if (p && !p.deleted && p.countable) {
          m.index -= p.length;
        }
      }
      if (p === null || p.marker === true) {
        searchMarker.splice(i2, 1);
        continue;
      }
      m.p = p;
      p.marker = true;
    }
    if (index < m.index || len > 0 && index === m.index) {
      m.index = max(index, m.index + len);
    }
  }
};
var callTypeObservers = (type, transaction, event) => {
  const changedType = type;
  const changedParentTypes = transaction.changedParentTypes;
  while (true) {
    setIfUndefined(changedParentTypes, type, () => []).push(event);
    if (type._item === null) {
      break;
    }
    type = /** @type {AbstractType<any>} */
    type._item.parent;
  }
  callEventHandlerListeners(changedType._eH, event, transaction);
};
var AbstractType = class {
  constructor() {
    this._item = null;
    this._map = /* @__PURE__ */ new Map();
    this._start = null;
    this.doc = null;
    this._length = 0;
    this._eH = createEventHandler();
    this._dEH = createEventHandler();
    this._searchMarker = null;
  }
  /**
   * @return {AbstractType<any>|null}
   */
  get parent() {
    return this._item ? (
      /** @type {AbstractType<any>} */
      this._item.parent
    ) : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item|null} item
   */
  _integrate(y, item) {
    this.doc = y;
    this._item = item;
  }
  /**
   * @return {AbstractType<EventType>}
   */
  _copy() {
    throw methodUnimplemented();
  }
  /**
   * @return {AbstractType<EventType>}
   */
  clone() {
    throw methodUnimplemented();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} _encoder
   */
  _write(_encoder) {
  }
  /**
   * The first non-deleted item
   */
  get _first() {
    let n = this._start;
    while (n !== null && n.deleted) {
      n = n.right;
    }
    return n;
  }
  /**
   * Creates YEvent and calls all type observers.
   * Must be implemented by each type.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} _parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, _parentSubs) {
    if (!transaction.local && this._searchMarker) {
      this._searchMarker.length = 0;
    }
  }
  /**
   * Observe all events that are created on this type.
   *
   * @param {function(EventType, Transaction):void} f Observer function
   */
  observe(f) {
    addEventHandlerListener(this._eH, f);
  }
  /**
   * Observe all events that are created by this type and its children.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */
  observeDeep(f) {
    addEventHandlerListener(this._dEH, f);
  }
  /**
   * Unregister an observer function.
   *
   * @param {function(EventType,Transaction):void} f Observer function
   */
  unobserve(f) {
    removeEventHandlerListener(this._eH, f);
  }
  /**
   * Unregister an observer function.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */
  unobserveDeep(f) {
    removeEventHandlerListener(this._dEH, f);
  }
  /**
   * @abstract
   * @return {any}
   */
  toJSON() {
  }
};
var typeListSlice = (type, start, end) => {
  if (start < 0) {
    start = type._length + start;
  }
  if (end < 0) {
    end = type._length + end;
  }
  let len = end - start;
  const cs = [];
  let n = type._start;
  while (n !== null && len > 0) {
    if (n.countable && !n.deleted) {
      const c = n.content.getContent();
      if (c.length <= start) {
        start -= c.length;
      } else {
        for (let i2 = start; i2 < c.length && len > 0; i2++) {
          cs.push(c[i2]);
          len--;
        }
        start = 0;
      }
    }
    n = n.right;
  }
  return cs;
};
var typeListToArray = (type) => {
  const cs = [];
  let n = type._start;
  while (n !== null) {
    if (n.countable && !n.deleted) {
      const c = n.content.getContent();
      for (let i2 = 0; i2 < c.length; i2++) {
        cs.push(c[i2]);
      }
    }
    n = n.right;
  }
  return cs;
};
var typeListForEach = (type, f) => {
  let index = 0;
  let n = type._start;
  while (n !== null) {
    if (n.countable && !n.deleted) {
      const c = n.content.getContent();
      for (let i2 = 0; i2 < c.length; i2++) {
        f(c[i2], index++, type);
      }
    }
    n = n.right;
  }
};
var typeListMap = (type, f) => {
  const result = [];
  typeListForEach(type, (c, i2) => {
    result.push(f(c, i2, type));
  });
  return result;
};
var typeListCreateIterator = (type) => {
  let n = type._start;
  let currentContent = null;
  let currentContentIndex = 0;
  return {
    [Symbol.iterator]() {
      return this;
    },
    next: () => {
      if (currentContent === null) {
        while (n !== null && n.deleted) {
          n = n.right;
        }
        if (n === null) {
          return {
            done: true,
            value: void 0
          };
        }
        currentContent = n.content.getContent();
        currentContentIndex = 0;
        n = n.right;
      }
      const value = currentContent[currentContentIndex++];
      if (currentContent.length <= currentContentIndex) {
        currentContent = null;
      }
      return {
        done: false,
        value
      };
    }
  };
};
var typeListGet = (type, index) => {
  const marker = findMarker(type, index);
  let n = type._start;
  if (marker !== null) {
    n = marker.p;
    index -= marker.index;
  }
  for (; n !== null; n = n.right) {
    if (!n.deleted && n.countable) {
      if (index < n.length) {
        return n.content.getContent()[index];
      }
      index -= n.length;
    }
  }
};
var typeListInsertGenericsAfter = (transaction, parent, referenceItem, content) => {
  let left = referenceItem;
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  const store = doc2.store;
  const right = referenceItem === null ? parent._start : referenceItem.right;
  let jsonContent = [];
  const packJsonContent = () => {
    if (jsonContent.length > 0) {
      left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentAny(jsonContent));
      left.integrate(transaction, 0);
      jsonContent = [];
    }
  };
  content.forEach((c) => {
    if (c === null) {
      jsonContent.push(c);
    } else {
      switch (c.constructor) {
        case Number:
        case Object:
        case Boolean:
        case Array:
        case String:
          jsonContent.push(c);
          break;
        default:
          packJsonContent();
          switch (c.constructor) {
            case Uint8Array:
            case ArrayBuffer:
              left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentBinary(new Uint8Array(
                /** @type {Uint8Array} */
                c
              )));
              left.integrate(transaction, 0);
              break;
            case Doc:
              left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentDoc(
                /** @type {Doc} */
                c
              ));
              left.integrate(transaction, 0);
              break;
            default:
              if (c instanceof AbstractType) {
                left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentType(c));
                left.integrate(transaction, 0);
              } else {
                throw new Error("Unexpected content type in insert operation");
              }
          }
      }
    }
  });
  packJsonContent();
};
var lengthExceeded = () => create3("Length exceeded!");
var typeListInsertGenerics = (transaction, parent, index, content) => {
  if (index > parent._length) {
    throw lengthExceeded();
  }
  if (index === 0) {
    if (parent._searchMarker) {
      updateMarkerChanges(parent._searchMarker, index, content.length);
    }
    return typeListInsertGenericsAfter(transaction, parent, null, content);
  }
  const startIndex = index;
  const marker = findMarker(parent, index);
  let n = parent._start;
  if (marker !== null) {
    n = marker.p;
    index -= marker.index;
    if (index === 0) {
      n = n.prev;
      index += n && n.countable && !n.deleted ? n.length : 0;
    }
  }
  for (; n !== null; n = n.right) {
    if (!n.deleted && n.countable) {
      if (index <= n.length) {
        if (index < n.length) {
          getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index));
        }
        break;
      }
      index -= n.length;
    }
  }
  if (parent._searchMarker) {
    updateMarkerChanges(parent._searchMarker, startIndex, content.length);
  }
  return typeListInsertGenericsAfter(transaction, parent, n, content);
};
var typeListPushGenerics = (transaction, parent, content) => {
  const marker = (parent._searchMarker || []).reduce((maxMarker, currMarker) => currMarker.index > maxMarker.index ? currMarker : maxMarker, { index: 0, p: parent._start });
  let n = marker.p;
  if (n) {
    while (n.right) {
      n = n.right;
    }
  }
  return typeListInsertGenericsAfter(transaction, parent, n, content);
};
var typeListDelete = (transaction, parent, index, length4) => {
  if (length4 === 0) {
    return;
  }
  const startIndex = index;
  const startLength = length4;
  const marker = findMarker(parent, index);
  let n = parent._start;
  if (marker !== null) {
    n = marker.p;
    index -= marker.index;
  }
  for (; n !== null && index > 0; n = n.right) {
    if (!n.deleted && n.countable) {
      if (index < n.length) {
        getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index));
      }
      index -= n.length;
    }
  }
  while (length4 > 0 && n !== null) {
    if (!n.deleted) {
      if (length4 < n.length) {
        getItemCleanStart(transaction, createID(n.id.client, n.id.clock + length4));
      }
      n.delete(transaction);
      length4 -= n.length;
    }
    n = n.right;
  }
  if (length4 > 0) {
    throw lengthExceeded();
  }
  if (parent._searchMarker) {
    updateMarkerChanges(
      parent._searchMarker,
      startIndex,
      -startLength + length4
      /* in case we remove the above exception */
    );
  }
};
var typeMapDelete = (transaction, parent, key) => {
  const c = parent._map.get(key);
  if (c !== void 0) {
    c.delete(transaction);
  }
};
var typeMapSet = (transaction, parent, key, value) => {
  const left = parent._map.get(key) || null;
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  let content;
  if (value == null) {
    content = new ContentAny([value]);
  } else {
    switch (value.constructor) {
      case Number:
      case Object:
      case Boolean:
      case Array:
      case String:
        content = new ContentAny([value]);
        break;
      case Uint8Array:
        content = new ContentBinary(
          /** @type {Uint8Array} */
          value
        );
        break;
      case Doc:
        content = new ContentDoc(
          /** @type {Doc} */
          value
        );
        break;
      default:
        if (value instanceof AbstractType) {
          content = new ContentType(value);
        } else {
          throw new Error("Unexpected content type");
        }
    }
  }
  new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, null, null, parent, key, content).integrate(transaction, 0);
};
var typeMapGet = (parent, key) => {
  const val = parent._map.get(key);
  return val !== void 0 && !val.deleted ? val.content.getContent()[val.length - 1] : void 0;
};
var typeMapGetAll = (parent) => {
  const res = {};
  parent._map.forEach((value, key) => {
    if (!value.deleted) {
      res[key] = value.content.getContent()[value.length - 1];
    }
  });
  return res;
};
var typeMapHas = (parent, key) => {
  const val = parent._map.get(key);
  return val !== void 0 && !val.deleted;
};
var typeMapGetAllSnapshot = (parent, snapshot) => {
  const res = {};
  parent._map.forEach((value, key) => {
    let v = value;
    while (v !== null && (!snapshot.sv.has(v.id.client) || v.id.clock >= (snapshot.sv.get(v.id.client) || 0))) {
      v = v.left;
    }
    if (v !== null && isVisible(v, snapshot)) {
      res[key] = v.content.getContent()[v.length - 1];
    }
  });
  return res;
};
var createMapIterator = (map3) => iteratorFilter(
  map3.entries(),
  /** @param {any} entry */
  (entry) => !entry[1].deleted
);
var YArrayEvent = class extends YEvent {
  /**
   * @param {YArray<T>} yarray The changed type
   * @param {Transaction} transaction The transaction object
   */
  constructor(yarray, transaction) {
    super(yarray, transaction);
    this._transaction = transaction;
  }
};
var YArray = class extends AbstractType {
  constructor() {
    super();
    this._prelimContent = [];
    this._searchMarker = [];
  }
  /**
   * Construct a new YArray containing the specified items.
   * @template {Object<string,any>|Array<any>|number|null|string|Uint8Array} T
   * @param {Array<T>} items
   * @return {YArray<T>}
   */
  static from(items) {
    const a = new YArray();
    a.push(items);
    return a;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(y, item) {
    super._integrate(y, item);
    this.insert(
      0,
      /** @type {Array<any>} */
      this._prelimContent
    );
    this._prelimContent = null;
  }
  /**
   * @return {YArray<T>}
   */
  _copy() {
    return new YArray();
  }
  /**
   * @return {YArray<T>}
   */
  clone() {
    const arr = new YArray();
    arr.insert(0, this.toArray().map(
      (el) => el instanceof AbstractType ? (
        /** @type {typeof el} */
        el.clone()
      ) : el
    ));
    return arr;
  }
  get length() {
    return this._prelimContent === null ? this._length : this._prelimContent.length;
  }
  /**
   * Creates YArrayEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, parentSubs) {
    super._callObserver(transaction, parentSubs);
    callTypeObservers(this, transaction, new YArrayEvent(this, transaction));
  }
  /**
   * Inserts new content at an index.
   *
   * Important: This function expects an array of content. Not just a content
   * object. The reason for this "weirdness" is that inserting several elements
   * is very efficient when it is done as a single operation.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  yarray.insert(0, ['a'])
   *  // Insert numbers 1, 2 at position 1
   *  yarray.insert(1, [1, 2])
   *
   * @param {number} index The index to insert content at.
   * @param {Array<T>} content The array of content
   */
  insert(index, content) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListInsertGenerics(
          transaction,
          this,
          index,
          /** @type {any} */
          content
        );
      });
    } else {
      this._prelimContent.splice(index, 0, ...content);
    }
  }
  /**
   * Appends content to this YArray.
   *
   * @param {Array<T>} content Array of content to append.
   *
   * @todo Use the following implementation in all types.
   */
  push(content) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListPushGenerics(
          transaction,
          this,
          /** @type {any} */
          content
        );
      });
    } else {
      this._prelimContent.push(...content);
    }
  }
  /**
   * Preppends content to this YArray.
   *
   * @param {Array<T>} content Array of content to preppend.
   */
  unshift(content) {
    this.insert(0, content);
  }
  /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} length The number of elements to remove. Defaults to 1.
   */
  delete(index, length4 = 1) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListDelete(transaction, this, index, length4);
      });
    } else {
      this._prelimContent.splice(index, length4);
    }
  }
  /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {T}
   */
  get(index) {
    return typeListGet(this, index);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<T>}
   */
  toArray() {
    return typeListToArray(this);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<T>}
   */
  slice(start = 0, end = this.length) {
    return typeListSlice(this, start, end);
  }
  /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Array<any>}
   */
  toJSON() {
    return this.map((c) => c instanceof AbstractType ? c.toJSON() : c);
  }
  /**
   * Returns an Array with the result of calling a provided function on every
   * element of this YArray.
   *
   * @template M
   * @param {function(T,number,YArray<T>):M} f Function that produces an element of the new Array
   * @return {Array<M>} A new array with each element being the result of the
   *                 callback function
   */
  map(f) {
    return typeListMap(
      this,
      /** @type {any} */
      f
    );
  }
  /**
   * Executes a provided function once on overy element of this YArray.
   *
   * @param {function(T,number,YArray<T>):void} f A function to execute on every element of this YArray.
   */
  forEach(f) {
    typeListForEach(this, f);
  }
  /**
   * @return {IterableIterator<T>}
   */
  [Symbol.iterator]() {
    return typeListCreateIterator(this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(encoder2) {
    encoder2.writeTypeRef(YArrayRefID);
  }
};
var readYArray = (_decoder) => new YArray();
var YMapEvent = class extends YEvent {
  /**
   * @param {YMap<T>} ymap The YArray that changed.
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed.
   */
  constructor(ymap, transaction, subs) {
    super(ymap, transaction);
    this.keysChanged = subs;
  }
};
var YMap = class extends AbstractType {
  /**
   *
   * @param {Iterable<readonly [string, any]>=} entries - an optional iterable to initialize the YMap
   */
  constructor(entries) {
    super();
    this._prelimContent = null;
    if (entries === void 0) {
      this._prelimContent = /* @__PURE__ */ new Map();
    } else {
      this._prelimContent = new Map(entries);
    }
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(y, item) {
    super._integrate(y, item);
    this._prelimContent.forEach((value, key) => {
      this.set(key, value);
    });
    this._prelimContent = null;
  }
  /**
   * @return {YMap<MapType>}
   */
  _copy() {
    return new YMap();
  }
  /**
   * @return {YMap<MapType>}
   */
  clone() {
    const map3 = new YMap();
    this.forEach((value, key) => {
      map3.set(key, value instanceof AbstractType ? (
        /** @type {typeof value} */
        value.clone()
      ) : value);
    });
    return map3;
  }
  /**
   * Creates YMapEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, parentSubs) {
    callTypeObservers(this, transaction, new YMapEvent(this, transaction, parentSubs));
  }
  /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Object<string,any>}
   */
  toJSON() {
    const map3 = {};
    this._map.forEach((item, key) => {
      if (!item.deleted) {
        const v = item.content.getContent()[item.length - 1];
        map3[key] = v instanceof AbstractType ? v.toJSON() : v;
      }
    });
    return map3;
  }
  /**
   * Returns the size of the YMap (count of key/value pairs)
   *
   * @return {number}
   */
  get size() {
    return [...createMapIterator(this._map)].length;
  }
  /**
   * Returns the keys for each element in the YMap Type.
   *
   * @return {IterableIterator<string>}
   */
  keys() {
    return iteratorMap(
      createMapIterator(this._map),
      /** @param {any} v */
      (v) => v[0]
    );
  }
  /**
   * Returns the values for each element in the YMap Type.
   *
   * @return {IterableIterator<MapType>}
   */
  values() {
    return iteratorMap(
      createMapIterator(this._map),
      /** @param {any} v */
      (v) => v[1].content.getContent()[v[1].length - 1]
    );
  }
  /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<[string, MapType]>}
   */
  entries() {
    return iteratorMap(
      createMapIterator(this._map),
      /** @param {any} v */
      (v) => (
        /** @type {any} */
        [v[0], v[1].content.getContent()[v[1].length - 1]]
      )
    );
  }
  /**
   * Executes a provided function on once on every key-value pair.
   *
   * @param {function(MapType,string,YMap<MapType>):void} f A function to execute on every element of this YArray.
   */
  forEach(f) {
    this._map.forEach((item, key) => {
      if (!item.deleted) {
        f(item.content.getContent()[item.length - 1], key, this);
      }
    });
  }
  /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<[string, MapType]>}
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * Remove a specified element from this YMap.
   *
   * @param {string} key The key of the element to remove.
   */
  delete(key) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapDelete(transaction, this, key);
      });
    } else {
      this._prelimContent.delete(key);
    }
  }
  /**
   * Adds or updates an element with a specified key and value.
   * @template {MapType} VAL
   *
   * @param {string} key The key of the element to add to this YMap
   * @param {VAL} value The value of the element to add
   * @return {VAL}
   */
  set(key, value) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapSet(
          transaction,
          this,
          key,
          /** @type {any} */
          value
        );
      });
    } else {
      this._prelimContent.set(key, value);
    }
    return value;
  }
  /**
   * Returns a specified element from this YMap.
   *
   * @param {string} key
   * @return {MapType|undefined}
   */
  get(key) {
    return (
      /** @type {any} */
      typeMapGet(this, key)
    );
  }
  /**
   * Returns a boolean indicating whether the specified key exists or not.
   *
   * @param {string} key The key to test.
   * @return {boolean}
   */
  has(key) {
    return typeMapHas(this, key);
  }
  /**
   * Removes all elements from this YMap.
   */
  clear() {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        this.forEach(function(_value, key, map3) {
          typeMapDelete(transaction, map3, key);
        });
      });
    } else {
      this._prelimContent.clear();
    }
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(encoder2) {
    encoder2.writeTypeRef(YMapRefID);
  }
};
var readYMap = (_decoder) => new YMap();
var equalAttrs = (a, b) => a === b || typeof a === "object" && typeof b === "object" && a && b && equalFlat(a, b);
var ItemTextListPosition = class {
  /**
   * @param {Item|null} left
   * @param {Item|null} right
   * @param {number} index
   * @param {Map<string,any>} currentAttributes
   */
  constructor(left, right, index, currentAttributes) {
    this.left = left;
    this.right = right;
    this.index = index;
    this.currentAttributes = currentAttributes;
  }
  /**
   * Only call this if you know that this.right is defined
   */
  forward() {
    if (this.right === null) {
      unexpectedCase();
    }
    switch (this.right.content.constructor) {
      case ContentFormat:
        if (!this.right.deleted) {
          updateCurrentAttributes(
            this.currentAttributes,
            /** @type {ContentFormat} */
            this.right.content
          );
        }
        break;
      default:
        if (!this.right.deleted) {
          this.index += this.right.length;
        }
        break;
    }
    this.left = this.right;
    this.right = this.right.right;
  }
};
var findNextPosition = (transaction, pos, count2) => {
  while (pos.right !== null && count2 > 0) {
    switch (pos.right.content.constructor) {
      case ContentFormat:
        if (!pos.right.deleted) {
          updateCurrentAttributes(
            pos.currentAttributes,
            /** @type {ContentFormat} */
            pos.right.content
          );
        }
        break;
      default:
        if (!pos.right.deleted) {
          if (count2 < pos.right.length) {
            getItemCleanStart(transaction, createID(pos.right.id.client, pos.right.id.clock + count2));
          }
          pos.index += pos.right.length;
          count2 -= pos.right.length;
        }
        break;
    }
    pos.left = pos.right;
    pos.right = pos.right.right;
  }
  return pos;
};
var findPosition = (transaction, parent, index, useSearchMarker) => {
  const currentAttributes = /* @__PURE__ */ new Map();
  const marker = useSearchMarker ? findMarker(parent, index) : null;
  if (marker) {
    const pos = new ItemTextListPosition(marker.p.left, marker.p, marker.index, currentAttributes);
    return findNextPosition(transaction, pos, index - marker.index);
  } else {
    const pos = new ItemTextListPosition(null, parent._start, 0, currentAttributes);
    return findNextPosition(transaction, pos, index);
  }
};
var insertNegatedAttributes = (transaction, parent, currPos, negatedAttributes) => {
  while (currPos.right !== null && (currPos.right.deleted === true || currPos.right.content.constructor === ContentFormat && equalAttrs(
    negatedAttributes.get(
      /** @type {ContentFormat} */
      currPos.right.content.key
    ),
    /** @type {ContentFormat} */
    currPos.right.content.value
  ))) {
    if (!currPos.right.deleted) {
      negatedAttributes.delete(
        /** @type {ContentFormat} */
        currPos.right.content.key
      );
    }
    currPos.forward();
  }
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  negatedAttributes.forEach((val, key) => {
    const left = currPos.left;
    const right = currPos.right;
    const nextFormat = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));
    nextFormat.integrate(transaction, 0);
    currPos.right = nextFormat;
    currPos.forward();
  });
};
var updateCurrentAttributes = (currentAttributes, format) => {
  const { key, value } = format;
  if (value === null) {
    currentAttributes.delete(key);
  } else {
    currentAttributes.set(key, value);
  }
};
var minimizeAttributeChanges = (currPos, attributes) => {
  var _a2;
  while (true) {
    if (currPos.right === null) {
      break;
    } else if (currPos.right.deleted || currPos.right.content.constructor === ContentFormat && equalAttrs(
      (_a2 = attributes[
        /** @type {ContentFormat} */
        currPos.right.content.key
      ]) != null ? _a2 : null,
      /** @type {ContentFormat} */
      currPos.right.content.value
    ))
      ;
    else {
      break;
    }
    currPos.forward();
  }
};
var insertAttributes = (transaction, parent, currPos, attributes) => {
  var _a2;
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  const negatedAttributes = /* @__PURE__ */ new Map();
  for (const key in attributes) {
    const val = attributes[key];
    const currentVal = (_a2 = currPos.currentAttributes.get(key)) != null ? _a2 : null;
    if (!equalAttrs(currentVal, val)) {
      negatedAttributes.set(key, currentVal);
      const { left, right } = currPos;
      currPos.right = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));
      currPos.right.integrate(transaction, 0);
      currPos.forward();
    }
  }
  return negatedAttributes;
};
var insertText = (transaction, parent, currPos, text3, attributes) => {
  currPos.currentAttributes.forEach((_val, key) => {
    if (attributes[key] === void 0) {
      attributes[key] = null;
    }
  });
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  minimizeAttributeChanges(currPos, attributes);
  const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);
  const content = text3.constructor === String ? new ContentString(
    /** @type {string} */
    text3
  ) : text3 instanceof AbstractType ? new ContentType(text3) : new ContentEmbed(text3);
  let { left, right, index } = currPos;
  if (parent._searchMarker) {
    updateMarkerChanges(parent._searchMarker, currPos.index, content.getLength());
  }
  right = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, content);
  right.integrate(transaction, 0);
  currPos.right = right;
  currPos.index = index;
  currPos.forward();
  insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);
};
var formatText = (transaction, parent, currPos, length4, attributes) => {
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  minimizeAttributeChanges(currPos, attributes);
  const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);
  iterationLoop:
    while (currPos.right !== null && (length4 > 0 || negatedAttributes.size > 0 && (currPos.right.deleted || currPos.right.content.constructor === ContentFormat))) {
      if (!currPos.right.deleted) {
        switch (currPos.right.content.constructor) {
          case ContentFormat: {
            const { key, value } = (
              /** @type {ContentFormat} */
              currPos.right.content
            );
            const attr2 = attributes[key];
            if (attr2 !== void 0) {
              if (equalAttrs(attr2, value)) {
                negatedAttributes.delete(key);
              } else {
                if (length4 === 0) {
                  break iterationLoop;
                }
                negatedAttributes.set(key, value);
              }
              currPos.right.delete(transaction);
            } else {
              currPos.currentAttributes.set(key, value);
            }
            break;
          }
          default:
            if (length4 < currPos.right.length) {
              getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length4));
            }
            length4 -= currPos.right.length;
            break;
        }
      }
      currPos.forward();
    }
  if (length4 > 0) {
    let newlines = "";
    for (; length4 > 0; length4--) {
      newlines += "\n";
    }
    currPos.right = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), currPos.left, currPos.left && currPos.left.lastId, currPos.right, currPos.right && currPos.right.id, parent, null, new ContentString(newlines));
    currPos.right.integrate(transaction, 0);
    currPos.forward();
  }
  insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);
};
var cleanupFormattingGap = (transaction, start, curr, startAttributes, currAttributes) => {
  var _a2, _b2;
  let end = start;
  const endFormats = create();
  while (end && (!end.countable || end.deleted)) {
    if (!end.deleted && end.content.constructor === ContentFormat) {
      const cf = (
        /** @type {ContentFormat} */
        end.content
      );
      endFormats.set(cf.key, cf);
    }
    end = end.right;
  }
  let cleanups = 0;
  let reachedCurr = false;
  while (start !== end) {
    if (curr === start) {
      reachedCurr = true;
    }
    if (!start.deleted) {
      const content = start.content;
      switch (content.constructor) {
        case ContentFormat: {
          const { key, value } = (
            /** @type {ContentFormat} */
            content
          );
          const startAttrValue = (_a2 = startAttributes.get(key)) != null ? _a2 : null;
          if (endFormats.get(key) !== content || startAttrValue === value) {
            start.delete(transaction);
            cleanups++;
            if (!reachedCurr && ((_b2 = currAttributes.get(key)) != null ? _b2 : null) === value && startAttrValue !== value) {
              if (startAttrValue === null) {
                currAttributes.delete(key);
              } else {
                currAttributes.set(key, startAttrValue);
              }
            }
          }
          if (!reachedCurr && !start.deleted) {
            updateCurrentAttributes(
              currAttributes,
              /** @type {ContentFormat} */
              content
            );
          }
          break;
        }
      }
    }
    start = /** @type {Item} */
    start.right;
  }
  return cleanups;
};
var cleanupContextlessFormattingGap = (transaction, item) => {
  while (item && item.right && (item.right.deleted || !item.right.countable)) {
    item = item.right;
  }
  const attrs = /* @__PURE__ */ new Set();
  while (item && (item.deleted || !item.countable)) {
    if (!item.deleted && item.content.constructor === ContentFormat) {
      const key = (
        /** @type {ContentFormat} */
        item.content.key
      );
      if (attrs.has(key)) {
        item.delete(transaction);
      } else {
        attrs.add(key);
      }
    }
    item = item.left;
  }
};
var cleanupYTextFormatting = (type) => {
  let res = 0;
  transact(
    /** @type {Doc} */
    type.doc,
    (transaction) => {
      let start = (
        /** @type {Item} */
        type._start
      );
      let end = type._start;
      let startAttributes = create();
      const currentAttributes = copy(startAttributes);
      while (end) {
        if (end.deleted === false) {
          switch (end.content.constructor) {
            case ContentFormat:
              updateCurrentAttributes(
                currentAttributes,
                /** @type {ContentFormat} */
                end.content
              );
              break;
            default:
              res += cleanupFormattingGap(transaction, start, end, startAttributes, currentAttributes);
              startAttributes = copy(currentAttributes);
              start = end;
              break;
          }
        }
        end = end.right;
      }
    }
  );
  return res;
};
var cleanupYTextAfterTransaction = (transaction) => {
  const needFullCleanup = /* @__PURE__ */ new Set();
  const doc2 = transaction.doc;
  for (const [client, afterClock] of transaction.afterState.entries()) {
    const clock = transaction.beforeState.get(client) || 0;
    if (afterClock === clock) {
      continue;
    }
    iterateStructs(
      transaction,
      /** @type {Array<Item|GC>} */
      doc2.store.clients.get(client),
      clock,
      afterClock,
      (item) => {
        if (!item.deleted && /** @type {Item} */
        item.content.constructor === ContentFormat && item.constructor !== GC) {
          needFullCleanup.add(
            /** @type {any} */
            item.parent
          );
        }
      }
    );
  }
  transact(doc2, (t2) => {
    iterateDeletedStructs(transaction, transaction.deleteSet, (item) => {
      if (item instanceof GC || !/** @type {YText} */
      item.parent._hasFormatting || needFullCleanup.has(
        /** @type {YText} */
        item.parent
      )) {
        return;
      }
      const parent = (
        /** @type {YText} */
        item.parent
      );
      if (item.content.constructor === ContentFormat) {
        needFullCleanup.add(parent);
      } else {
        cleanupContextlessFormattingGap(t2, item);
      }
    });
    for (const yText of needFullCleanup) {
      cleanupYTextFormatting(yText);
    }
  });
};
var deleteText = (transaction, currPos, length4) => {
  const startLength = length4;
  const startAttrs = copy(currPos.currentAttributes);
  const start = currPos.right;
  while (length4 > 0 && currPos.right !== null) {
    if (currPos.right.deleted === false) {
      switch (currPos.right.content.constructor) {
        case ContentType:
        case ContentEmbed:
        case ContentString:
          if (length4 < currPos.right.length) {
            getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length4));
          }
          length4 -= currPos.right.length;
          currPos.right.delete(transaction);
          break;
      }
    }
    currPos.forward();
  }
  if (start) {
    cleanupFormattingGap(transaction, start, currPos.right, startAttrs, currPos.currentAttributes);
  }
  const parent = (
    /** @type {AbstractType<any>} */
    /** @type {Item} */
    (currPos.left || currPos.right).parent
  );
  if (parent._searchMarker) {
    updateMarkerChanges(parent._searchMarker, currPos.index, -startLength + length4);
  }
  return currPos;
};
var YTextEvent = class extends YEvent {
  /**
   * @param {YText} ytext
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed
   */
  constructor(ytext, transaction, subs) {
    super(ytext, transaction);
    this.childListChanged = false;
    this.keysChanged = /* @__PURE__ */ new Set();
    subs.forEach((sub) => {
      if (sub === null) {
        this.childListChanged = true;
      } else {
        this.keysChanged.add(sub);
      }
    });
  }
  /**
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */
  get changes() {
    if (this._changes === null) {
      const changes = {
        keys: this.keys,
        delta: this.delta,
        added: /* @__PURE__ */ new Set(),
        deleted: /* @__PURE__ */ new Set()
      };
      this._changes = changes;
    }
    return (
      /** @type {any} */
      this._changes
    );
  }
  /**
   * Compute the changes in the delta format.
   * A {@link https://quilljs.com/docs/delta/|Quill Delta}) that represents the changes on the document.
   *
   * @type {Array<{insert?:string|object|AbstractType<any>, delete?:number, retain?:number, attributes?: Object<string,any>}>}
   *
   * @public
   */
  get delta() {
    if (this._delta === null) {
      const y = (
        /** @type {Doc} */
        this.target.doc
      );
      const delta = [];
      transact(y, (transaction) => {
        var _a2, _b2, _c;
        const currentAttributes = /* @__PURE__ */ new Map();
        const oldAttributes = /* @__PURE__ */ new Map();
        let item = this.target._start;
        let action = null;
        const attributes = {};
        let insert2 = "";
        let retain = 0;
        let deleteLen = 0;
        const addOp = () => {
          if (action !== null) {
            let op = null;
            switch (action) {
              case "delete":
                if (deleteLen > 0) {
                  op = { delete: deleteLen };
                }
                deleteLen = 0;
                break;
              case "insert":
                if (typeof insert2 === "object" || insert2.length > 0) {
                  op = { insert: insert2 };
                  if (currentAttributes.size > 0) {
                    op.attributes = {};
                    currentAttributes.forEach((value, key) => {
                      if (value !== null) {
                        op.attributes[key] = value;
                      }
                    });
                  }
                }
                insert2 = "";
                break;
              case "retain":
                if (retain > 0) {
                  op = { retain };
                  if (!isEmpty(attributes)) {
                    op.attributes = assign({}, attributes);
                  }
                }
                retain = 0;
                break;
            }
            if (op)
              delta.push(op);
            action = null;
          }
        };
        while (item !== null) {
          switch (item.content.constructor) {
            case ContentType:
            case ContentEmbed:
              if (this.adds(item)) {
                if (!this.deletes(item)) {
                  addOp();
                  action = "insert";
                  insert2 = item.content.getContent()[0];
                  addOp();
                }
              } else if (this.deletes(item)) {
                if (action !== "delete") {
                  addOp();
                  action = "delete";
                }
                deleteLen += 1;
              } else if (!item.deleted) {
                if (action !== "retain") {
                  addOp();
                  action = "retain";
                }
                retain += 1;
              }
              break;
            case ContentString:
              if (this.adds(item)) {
                if (!this.deletes(item)) {
                  if (action !== "insert") {
                    addOp();
                    action = "insert";
                  }
                  insert2 += /** @type {ContentString} */
                  item.content.str;
                }
              } else if (this.deletes(item)) {
                if (action !== "delete") {
                  addOp();
                  action = "delete";
                }
                deleteLen += item.length;
              } else if (!item.deleted) {
                if (action !== "retain") {
                  addOp();
                  action = "retain";
                }
                retain += item.length;
              }
              break;
            case ContentFormat: {
              const { key, value } = (
                /** @type {ContentFormat} */
                item.content
              );
              if (this.adds(item)) {
                if (!this.deletes(item)) {
                  const curVal = (_a2 = currentAttributes.get(key)) != null ? _a2 : null;
                  if (!equalAttrs(curVal, value)) {
                    if (action === "retain") {
                      addOp();
                    }
                    if (equalAttrs(value, (_b2 = oldAttributes.get(key)) != null ? _b2 : null)) {
                      delete attributes[key];
                    } else {
                      attributes[key] = value;
                    }
                  } else if (value !== null) {
                    item.delete(transaction);
                  }
                }
              } else if (this.deletes(item)) {
                oldAttributes.set(key, value);
                const curVal = (_c = currentAttributes.get(key)) != null ? _c : null;
                if (!equalAttrs(curVal, value)) {
                  if (action === "retain") {
                    addOp();
                  }
                  attributes[key] = curVal;
                }
              } else if (!item.deleted) {
                oldAttributes.set(key, value);
                const attr2 = attributes[key];
                if (attr2 !== void 0) {
                  if (!equalAttrs(attr2, value)) {
                    if (action === "retain") {
                      addOp();
                    }
                    if (value === null) {
                      delete attributes[key];
                    } else {
                      attributes[key] = value;
                    }
                  } else if (attr2 !== null) {
                    item.delete(transaction);
                  }
                }
              }
              if (!item.deleted) {
                if (action === "insert") {
                  addOp();
                }
                updateCurrentAttributes(
                  currentAttributes,
                  /** @type {ContentFormat} */
                  item.content
                );
              }
              break;
            }
          }
          item = item.right;
        }
        addOp();
        while (delta.length > 0) {
          const lastOp = delta[delta.length - 1];
          if (lastOp.retain !== void 0 && lastOp.attributes === void 0) {
            delta.pop();
          } else {
            break;
          }
        }
      });
      this._delta = delta;
    }
    return (
      /** @type {any} */
      this._delta
    );
  }
};
var YText = class extends AbstractType {
  /**
   * @param {String} [string] The initial value of the YText.
   */
  constructor(string) {
    super();
    this._pending = string !== void 0 ? [() => this.insert(0, string)] : [];
    this._searchMarker = [];
    this._hasFormatting = false;
  }
  /**
   * Number of characters of this text type.
   *
   * @type {number}
   */
  get length() {
    return this._length;
  }
  /**
   * @param {Doc} y
   * @param {Item} item
   */
  _integrate(y, item) {
    super._integrate(y, item);
    try {
      this._pending.forEach((f) => f());
    } catch (e2) {
      console.error(e2);
    }
    this._pending = null;
  }
  _copy() {
    return new YText();
  }
  /**
   * @return {YText}
   */
  clone() {
    const text3 = new YText();
    text3.applyDelta(this.toDelta());
    return text3;
  }
  /**
   * Creates YTextEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, parentSubs) {
    super._callObserver(transaction, parentSubs);
    const event = new YTextEvent(this, transaction, parentSubs);
    callTypeObservers(this, transaction, event);
    if (!transaction.local && this._hasFormatting) {
      transaction._needFormattingCleanup = true;
    }
  }
  /**
   * Returns the unformatted string representation of this YText type.
   *
   * @public
   */
  toString() {
    let str = "";
    let n = this._start;
    while (n !== null) {
      if (!n.deleted && n.countable && n.content.constructor === ContentString) {
        str += /** @type {ContentString} */
        n.content.str;
      }
      n = n.right;
    }
    return str;
  }
  /**
   * Returns the unformatted string representation of this YText type.
   *
   * @return {string}
   * @public
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Apply a {@link Delta} on this shared YText type.
   *
   * @param {any} delta The changes to apply on this element.
   * @param {object}  opts
   * @param {boolean} [opts.sanitize] Sanitize input delta. Removes ending newlines if set to true.
   *
   *
   * @public
   */
  applyDelta(delta, { sanitize = true } = {}) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        const currPos = new ItemTextListPosition(null, this._start, 0, /* @__PURE__ */ new Map());
        for (let i2 = 0; i2 < delta.length; i2++) {
          const op = delta[i2];
          if (op.insert !== void 0) {
            const ins = !sanitize && typeof op.insert === "string" && i2 === delta.length - 1 && currPos.right === null && op.insert.slice(-1) === "\n" ? op.insert.slice(0, -1) : op.insert;
            if (typeof ins !== "string" || ins.length > 0) {
              insertText(transaction, this, currPos, ins, op.attributes || {});
            }
          } else if (op.retain !== void 0) {
            formatText(transaction, this, currPos, op.retain, op.attributes || {});
          } else if (op.delete !== void 0) {
            deleteText(transaction, currPos, op.delete);
          }
        }
      });
    } else {
      this._pending.push(() => this.applyDelta(delta));
    }
  }
  /**
   * Returns the Delta representation of this YText type.
   *
   * @param {Snapshot} [snapshot]
   * @param {Snapshot} [prevSnapshot]
   * @param {function('removed' | 'added', ID):any} [computeYChange]
   * @return {any} The Delta representation of this type.
   *
   * @public
   */
  toDelta(snapshot, prevSnapshot, computeYChange) {
    const ops = [];
    const currentAttributes = /* @__PURE__ */ new Map();
    const doc2 = (
      /** @type {Doc} */
      this.doc
    );
    let str = "";
    let n = this._start;
    function packStr() {
      if (str.length > 0) {
        const attributes = {};
        let addAttributes = false;
        currentAttributes.forEach((value, key) => {
          addAttributes = true;
          attributes[key] = value;
        });
        const op = { insert: str };
        if (addAttributes) {
          op.attributes = attributes;
        }
        ops.push(op);
        str = "";
      }
    }
    const computeDelta = () => {
      while (n !== null) {
        if (isVisible(n, snapshot) || prevSnapshot !== void 0 && isVisible(n, prevSnapshot)) {
          switch (n.content.constructor) {
            case ContentString: {
              const cur = currentAttributes.get("ychange");
              if (snapshot !== void 0 && !isVisible(n, snapshot)) {
                if (cur === void 0 || cur.user !== n.id.client || cur.type !== "removed") {
                  packStr();
                  currentAttributes.set("ychange", computeYChange ? computeYChange("removed", n.id) : { type: "removed" });
                }
              } else if (prevSnapshot !== void 0 && !isVisible(n, prevSnapshot)) {
                if (cur === void 0 || cur.user !== n.id.client || cur.type !== "added") {
                  packStr();
                  currentAttributes.set("ychange", computeYChange ? computeYChange("added", n.id) : { type: "added" });
                }
              } else if (cur !== void 0) {
                packStr();
                currentAttributes.delete("ychange");
              }
              str += /** @type {ContentString} */
              n.content.str;
              break;
            }
            case ContentType:
            case ContentEmbed: {
              packStr();
              const op = {
                insert: n.content.getContent()[0]
              };
              if (currentAttributes.size > 0) {
                const attrs = (
                  /** @type {Object<string,any>} */
                  {}
                );
                op.attributes = attrs;
                currentAttributes.forEach((value, key) => {
                  attrs[key] = value;
                });
              }
              ops.push(op);
              break;
            }
            case ContentFormat:
              if (isVisible(n, snapshot)) {
                packStr();
                updateCurrentAttributes(
                  currentAttributes,
                  /** @type {ContentFormat} */
                  n.content
                );
              }
              break;
          }
        }
        n = n.right;
      }
      packStr();
    };
    if (snapshot || prevSnapshot) {
      transact(doc2, (transaction) => {
        if (snapshot) {
          splitSnapshotAffectedStructs(transaction, snapshot);
        }
        if (prevSnapshot) {
          splitSnapshotAffectedStructs(transaction, prevSnapshot);
        }
        computeDelta();
      }, "cleanup");
    } else {
      computeDelta();
    }
    return ops;
  }
  /**
   * Insert text at a given index.
   *
   * @param {number} index The index at which to start inserting.
   * @param {String} text The text to insert at the specified position.
   * @param {TextAttributes} [attributes] Optionally define some formatting
   *                                    information to apply on the inserted
   *                                    Text.
   * @public
   */
  insert(index, text3, attributes) {
    if (text3.length <= 0) {
      return;
    }
    const y = this.doc;
    if (y !== null) {
      transact(y, (transaction) => {
        const pos = findPosition(transaction, this, index, !attributes);
        if (!attributes) {
          attributes = {};
          pos.currentAttributes.forEach((v, k) => {
            attributes[k] = v;
          });
        }
        insertText(transaction, this, pos, text3, attributes);
      });
    } else {
      this._pending.push(() => this.insert(index, text3, attributes));
    }
  }
  /**
   * Inserts an embed at a index.
   *
   * @param {number} index The index to insert the embed at.
   * @param {Object | AbstractType<any>} embed The Object that represents the embed.
   * @param {TextAttributes} [attributes] Attribute information to apply on the
   *                                    embed
   *
   * @public
   */
  insertEmbed(index, embed, attributes) {
    const y = this.doc;
    if (y !== null) {
      transact(y, (transaction) => {
        const pos = findPosition(transaction, this, index, !attributes);
        insertText(transaction, this, pos, embed, attributes || {});
      });
    } else {
      this._pending.push(() => this.insertEmbed(index, embed, attributes || {}));
    }
  }
  /**
   * Deletes text starting from an index.
   *
   * @param {number} index Index at which to start deleting.
   * @param {number} length The number of characters to remove. Defaults to 1.
   *
   * @public
   */
  delete(index, length4) {
    if (length4 === 0) {
      return;
    }
    const y = this.doc;
    if (y !== null) {
      transact(y, (transaction) => {
        deleteText(transaction, findPosition(transaction, this, index, true), length4);
      });
    } else {
      this._pending.push(() => this.delete(index, length4));
    }
  }
  /**
   * Assigns properties to a range of text.
   *
   * @param {number} index The position where to start formatting.
   * @param {number} length The amount of characters to assign properties to.
   * @param {TextAttributes} attributes Attribute information to apply on the
   *                                    text.
   *
   * @public
   */
  format(index, length4, attributes) {
    if (length4 === 0) {
      return;
    }
    const y = this.doc;
    if (y !== null) {
      transact(y, (transaction) => {
        const pos = findPosition(transaction, this, index, false);
        if (pos.right === null) {
          return;
        }
        formatText(transaction, this, pos, length4, attributes);
      });
    } else {
      this._pending.push(() => this.format(index, length4, attributes));
    }
  }
  /**
   * Removes an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be removed.
   *
   * @public
   */
  removeAttribute(attributeName) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapDelete(transaction, this, attributeName);
      });
    } else {
      this._pending.push(() => this.removeAttribute(attributeName));
    }
  }
  /**
   * Sets or updates an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be set.
   * @param {any} attributeValue The attribute value that is to be set.
   *
   * @public
   */
  setAttribute(attributeName, attributeValue) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapSet(transaction, this, attributeName, attributeValue);
      });
    } else {
      this._pending.push(() => this.setAttribute(attributeName, attributeValue));
    }
  }
  /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {any} The queried attribute value.
   *
   * @public
   */
  getAttribute(attributeName) {
    return (
      /** @type {any} */
      typeMapGet(this, attributeName)
    );
  }
  /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @return {Object<string, any>} A JSON Object that describes the attributes.
   *
   * @public
   */
  getAttributes() {
    return typeMapGetAll(this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(encoder2) {
    encoder2.writeTypeRef(YTextRefID);
  }
};
var readYText = (_decoder) => new YText();
var YXmlTreeWalker = class {
  /**
   * @param {YXmlFragment | YXmlElement} root
   * @param {function(AbstractType<any>):boolean} [f]
   */
  constructor(root, f = () => true) {
    this._filter = f;
    this._root = root;
    this._currentNode = /** @type {Item} */
    root._start;
    this._firstCall = true;
  }
  [Symbol.iterator]() {
    return this;
  }
  /**
   * Get the next node.
   *
   * @return {IteratorResult<YXmlElement|YXmlText|YXmlHook>} The next node.
   *
   * @public
   */
  next() {
    let n = this._currentNode;
    let type = n && n.content && /** @type {any} */
    n.content.type;
    if (n !== null && (!this._firstCall || n.deleted || !this._filter(type))) {
      do {
        type = /** @type {any} */
        n.content.type;
        if (!n.deleted && (type.constructor === YXmlElement || type.constructor === YXmlFragment) && type._start !== null) {
          n = type._start;
        } else {
          while (n !== null) {
            if (n.right !== null) {
              n = n.right;
              break;
            } else if (n.parent === this._root) {
              n = null;
            } else {
              n = /** @type {AbstractType<any>} */
              n.parent._item;
            }
          }
        }
      } while (n !== null && (n.deleted || !this._filter(
        /** @type {ContentType} */
        n.content.type
      )));
    }
    this._firstCall = false;
    if (n === null) {
      return { value: void 0, done: true };
    }
    this._currentNode = n;
    return { value: (
      /** @type {any} */
      n.content.type
    ), done: false };
  }
};
var YXmlFragment = class extends AbstractType {
  constructor() {
    super();
    this._prelimContent = [];
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get firstChild() {
    const first = this._first;
    return first ? first.content.getContent()[0] : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(y, item) {
    super._integrate(y, item);
    this.insert(
      0,
      /** @type {Array<any>} */
      this._prelimContent
    );
    this._prelimContent = null;
  }
  _copy() {
    return new YXmlFragment();
  }
  /**
   * @return {YXmlFragment}
   */
  clone() {
    const el = new YXmlFragment();
    el.insert(0, this.toArray().map((item) => item instanceof AbstractType ? item.clone() : item));
    return el;
  }
  get length() {
    return this._prelimContent === null ? this._length : this._prelimContent.length;
  }
  /**
   * Create a subtree of childNodes.
   *
   * @example
   * const walker = elem.createTreeWalker(dom => dom.nodeName === 'div')
   * for (let node in walker) {
   *   // `node` is a div node
   *   nop(node)
   * }
   *
   * @param {function(AbstractType<any>):boolean} filter Function that is called on each child element and
   *                          returns a Boolean indicating whether the child
   *                          is to be included in the subtree.
   * @return {YXmlTreeWalker} A subtree and a position within it.
   *
   * @public
   */
  createTreeWalker(filter) {
    return new YXmlTreeWalker(this, filter);
  }
  /**
   * Returns the first YXmlElement that matches the query.
   * Similar to DOM's {@link querySelector}.
   *
   * Query support:
   *   - tagname
   * TODO:
   *   - id
   *   - attribute
   *
   * @param {CSS_Selector} query The query on the children.
   * @return {YXmlElement|YXmlText|YXmlHook|null} The first element that matches the query or null.
   *
   * @public
   */
  querySelector(query) {
    query = query.toUpperCase();
    const iterator = new YXmlTreeWalker(this, (element3) => element3.nodeName && element3.nodeName.toUpperCase() === query);
    const next = iterator.next();
    if (next.done) {
      return null;
    } else {
      return next.value;
    }
  }
  /**
   * Returns all YXmlElements that match the query.
   * Similar to Dom's {@link querySelectorAll}.
   *
   * @todo Does not yet support all queries. Currently only query by tagName.
   *
   * @param {CSS_Selector} query The query on the children
   * @return {Array<YXmlElement|YXmlText|YXmlHook|null>} The elements that match this query.
   *
   * @public
   */
  querySelectorAll(query) {
    query = query.toUpperCase();
    return from(new YXmlTreeWalker(this, (element3) => element3.nodeName && element3.nodeName.toUpperCase() === query));
  }
  /**
   * Creates YXmlEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, parentSubs) {
    callTypeObservers(this, transaction, new YXmlEvent(this, parentSubs, transaction));
  }
  /**
   * Get the string representation of all the children of this YXmlFragment.
   *
   * @return {string} The string representation of all children.
   */
  toString() {
    return typeListMap(this, (xml) => xml.toString()).join("");
  }
  /**
   * @return {string}
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(_document = document, hooks = {}, binding) {
    const fragment2 = _document.createDocumentFragment();
    if (binding !== void 0) {
      binding._createAssociation(fragment2, this);
    }
    typeListForEach(this, (xmlType) => {
      fragment2.insertBefore(xmlType.toDOM(_document, hooks, binding), null);
    });
    return fragment2;
  }
  /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {number} index The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */
  insert(index, content) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListInsertGenerics(transaction, this, index, content);
      });
    } else {
      this._prelimContent.splice(index, 0, ...content);
    }
  }
  /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {null|Item|YXmlElement|YXmlText} ref The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */
  insertAfter(ref, content) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        const refItem = ref && ref instanceof AbstractType ? ref._item : ref;
        typeListInsertGenericsAfter(transaction, this, refItem, content);
      });
    } else {
      const pc = (
        /** @type {Array<any>} */
        this._prelimContent
      );
      const index = ref === null ? 0 : pc.findIndex((el) => el === ref) + 1;
      if (index === 0 && ref !== null) {
        throw create3("Reference item not found");
      }
      pc.splice(index, 0, ...content);
    }
  }
  /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} [length=1] The number of elements to remove. Defaults to 1.
   */
  delete(index, length4 = 1) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListDelete(transaction, this, index, length4);
      });
    } else {
      this._prelimContent.splice(index, length4);
    }
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<YXmlElement|YXmlText|YXmlHook>}
   */
  toArray() {
    return typeListToArray(this);
  }
  /**
   * Appends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to append.
   */
  push(content) {
    this.insert(this.length, content);
  }
  /**
   * Preppends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to preppend.
   */
  unshift(content) {
    this.insert(0, content);
  }
  /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {YXmlElement|YXmlText}
   */
  get(index) {
    return typeListGet(this, index);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<YXmlElement|YXmlText>}
   */
  slice(start = 0, end = this.length) {
    return typeListSlice(this, start, end);
  }
  /**
   * Executes a provided function on once on overy child element.
   *
   * @param {function(YXmlElement|YXmlText,number, typeof self):void} f A function to execute on every element of this YArray.
   */
  forEach(f) {
    typeListForEach(this, f);
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(encoder2) {
    encoder2.writeTypeRef(YXmlFragmentRefID);
  }
};
var readYXmlFragment = (_decoder) => new YXmlFragment();
var YXmlElement = class extends YXmlFragment {
  constructor(nodeName = "UNDEFINED") {
    super();
    this.nodeName = nodeName;
    this._prelimAttrs = /* @__PURE__ */ new Map();
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get nextSibling() {
    const n = this._item ? this._item.next : null;
    return n ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      n.content.type
    ) : null;
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get prevSibling() {
    const n = this._item ? this._item.prev : null;
    return n ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      n.content.type
    ) : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(y, item) {
    super._integrate(y, item);
    /** @type {Map<string, any>} */
    this._prelimAttrs.forEach((value, key) => {
      this.setAttribute(key, value);
    });
    this._prelimAttrs = null;
  }
  /**
   * Creates an Item with the same effect as this Item (without position effect)
   *
   * @return {YXmlElement}
   */
  _copy() {
    return new YXmlElement(this.nodeName);
  }
  /**
   * @return {YXmlElement<KV>}
   */
  clone() {
    const el = new YXmlElement(this.nodeName);
    const attrs = this.getAttributes();
    forEach(attrs, (value, key) => {
      if (typeof value === "string") {
        el.setAttribute(key, value);
      }
    });
    el.insert(0, this.toArray().map((item) => item instanceof AbstractType ? item.clone() : item));
    return el;
  }
  /**
   * Returns the XML serialization of this YXmlElement.
   * The attributes are ordered by attribute-name, so you can easily use this
   * method to compare YXmlElements
   *
   * @return {string} The string representation of this type.
   *
   * @public
   */
  toString() {
    const attrs = this.getAttributes();
    const stringBuilder = [];
    const keys2 = [];
    for (const key in attrs) {
      keys2.push(key);
    }
    keys2.sort();
    const keysLen = keys2.length;
    for (let i2 = 0; i2 < keysLen; i2++) {
      const key = keys2[i2];
      stringBuilder.push(key + '="' + attrs[key] + '"');
    }
    const nodeName = this.nodeName.toLocaleLowerCase();
    const attrsString = stringBuilder.length > 0 ? " " + stringBuilder.join(" ") : "";
    return `<${nodeName}${attrsString}>${super.toString()}</${nodeName}>`;
  }
  /**
   * Removes an attribute from this YXmlElement.
   *
   * @param {string} attributeName The attribute name that is to be removed.
   *
   * @public
   */
  removeAttribute(attributeName) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapDelete(transaction, this, attributeName);
      });
    } else {
      this._prelimAttrs.delete(attributeName);
    }
  }
  /**
   * Sets or updates an attribute.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that is to be set.
   * @param {KV[KEY]} attributeValue The attribute value that is to be set.
   *
   * @public
   */
  setAttribute(attributeName, attributeValue) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapSet(transaction, this, attributeName, attributeValue);
      });
    } else {
      this._prelimAttrs.set(attributeName, attributeValue);
    }
  }
  /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {KV[KEY]|undefined} The queried attribute value.
   *
   * @public
   */
  getAttribute(attributeName) {
    return (
      /** @type {any} */
      typeMapGet(this, attributeName)
    );
  }
  /**
   * Returns whether an attribute exists
   *
   * @param {string} attributeName The attribute name to check for existence.
   * @return {boolean} whether the attribute exists.
   *
   * @public
   */
  hasAttribute(attributeName) {
    return (
      /** @type {any} */
      typeMapHas(this, attributeName)
    );
  }
  /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @param {Snapshot} [snapshot]
   * @return {{ [Key in Extract<keyof KV,string>]?: KV[Key]}} A JSON Object that describes the attributes.
   *
   * @public
   */
  getAttributes(snapshot) {
    return (
      /** @type {any} */
      snapshot ? typeMapGetAllSnapshot(this, snapshot) : typeMapGetAll(this)
    );
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(_document = document, hooks = {}, binding) {
    const dom = _document.createElement(this.nodeName);
    const attrs = this.getAttributes();
    for (const key in attrs) {
      const value = attrs[key];
      if (typeof value === "string") {
        dom.setAttribute(key, value);
      }
    }
    typeListForEach(this, (yxml) => {
      dom.appendChild(yxml.toDOM(_document, hooks, binding));
    });
    if (binding !== void 0) {
      binding._createAssociation(dom, this);
    }
    return dom;
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(encoder2) {
    encoder2.writeTypeRef(YXmlElementRefID);
    encoder2.writeKey(this.nodeName);
  }
};
var readYXmlElement = (decoder2) => new YXmlElement(decoder2.readKey());
var YXmlEvent = class extends YEvent {
  /**
   * @param {YXmlElement|YXmlText|YXmlFragment} target The target on which the event is created.
   * @param {Set<string|null>} subs The set of changed attributes. `null` is included if the
   *                   child list changed.
   * @param {Transaction} transaction The transaction instance with wich the
   *                                  change was created.
   */
  constructor(target, subs, transaction) {
    super(target, transaction);
    this.childListChanged = false;
    this.attributesChanged = /* @__PURE__ */ new Set();
    subs.forEach((sub) => {
      if (sub === null) {
        this.childListChanged = true;
      } else {
        this.attributesChanged.add(sub);
      }
    });
  }
};
var YXmlHook = class extends YMap {
  /**
   * @param {string} hookName nodeName of the Dom Node.
   */
  constructor(hookName) {
    super();
    this.hookName = hookName;
  }
  /**
   * Creates an Item with the same effect as this Item (without position effect)
   */
  _copy() {
    return new YXmlHook(this.hookName);
  }
  /**
   * @return {YXmlHook}
   */
  clone() {
    const el = new YXmlHook(this.hookName);
    this.forEach((value, key) => {
      el.set(key, value);
    });
    return el;
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object.<string, any>} [hooks] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type
   * @return {Element} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(_document = document, hooks = {}, binding) {
    const hook = hooks[this.hookName];
    let dom;
    if (hook !== void 0) {
      dom = hook.createDom(this);
    } else {
      dom = document.createElement(this.hookName);
    }
    dom.setAttribute("data-yjs-hook", this.hookName);
    if (binding !== void 0) {
      binding._createAssociation(dom, this);
    }
    return dom;
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(encoder2) {
    encoder2.writeTypeRef(YXmlHookRefID);
    encoder2.writeKey(this.hookName);
  }
};
var readYXmlHook = (decoder2) => new YXmlHook(decoder2.readKey());
var YXmlText = class extends YText {
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get nextSibling() {
    const n = this._item ? this._item.next : null;
    return n ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      n.content.type
    ) : null;
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get prevSibling() {
    const n = this._item ? this._item.prev : null;
    return n ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      n.content.type
    ) : null;
  }
  _copy() {
    return new YXmlText();
  }
  /**
   * @return {YXmlText}
   */
  clone() {
    const text3 = new YXmlText();
    text3.applyDelta(this.toDelta());
    return text3;
  }
  /**
   * Creates a Dom Element that mirrors this YXmlText.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Text} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(_document = document, hooks, binding) {
    const dom = _document.createTextNode(this.toString());
    if (binding !== void 0) {
      binding._createAssociation(dom, this);
    }
    return dom;
  }
  toString() {
    return this.toDelta().map((delta) => {
      const nestedNodes = [];
      for (const nodeName in delta.attributes) {
        const attrs = [];
        for (const key in delta.attributes[nodeName]) {
          attrs.push({ key, value: delta.attributes[nodeName][key] });
        }
        attrs.sort((a, b) => a.key < b.key ? -1 : 1);
        nestedNodes.push({ nodeName, attrs });
      }
      nestedNodes.sort((a, b) => a.nodeName < b.nodeName ? -1 : 1);
      let str = "";
      for (let i2 = 0; i2 < nestedNodes.length; i2++) {
        const node = nestedNodes[i2];
        str += `<${node.nodeName}`;
        for (let j = 0; j < node.attrs.length; j++) {
          const attr2 = node.attrs[j];
          str += ` ${attr2.key}="${attr2.value}"`;
        }
        str += ">";
      }
      str += delta.insert;
      for (let i2 = nestedNodes.length - 1; i2 >= 0; i2--) {
        str += `</${nestedNodes[i2].nodeName}>`;
      }
      return str;
    }).join("");
  }
  /**
   * @return {string}
   */
  toJSON() {
    return this.toString();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(encoder2) {
    encoder2.writeTypeRef(YXmlTextRefID);
  }
};
var readYXmlText = (decoder2) => new YXmlText();
var AbstractStruct = class {
  /**
   * @param {ID} id
   * @param {number} length
   */
  constructor(id2, length4) {
    this.id = id2;
    this.length = length4;
  }
  /**
   * @type {boolean}
   */
  get deleted() {
    throw methodUnimplemented();
  }
  /**
   * Merge this struct with the item to the right.
   * This method is already assuming that `this.id.clock + this.length === this.id.clock`.
   * Also this method does *not* remove right from StructStore!
   * @param {AbstractStruct} right
   * @return {boolean} wether this merged with right
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   * @param {number} encodingRef
   */
  write(encoder2, offset, encodingRef) {
    throw methodUnimplemented();
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(transaction, offset) {
    throw methodUnimplemented();
  }
};
var structGCRefNumber = 0;
var GC = class extends AbstractStruct {
  get deleted() {
    return true;
  }
  delete() {
  }
  /**
   * @param {GC} right
   * @return {boolean}
   */
  mergeWith(right) {
    if (this.constructor !== right.constructor) {
      return false;
    }
    this.length += right.length;
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(transaction, offset) {
    if (offset > 0) {
      this.id.clock += offset;
      this.length -= offset;
    }
    addStruct(transaction.doc.store, this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder2, offset) {
    encoder2.writeInfo(structGCRefNumber);
    encoder2.writeLen(this.length - offset);
  }
  /**
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(transaction, store) {
    return null;
  }
};
var ContentBinary = class {
  /**
   * @param {Uint8Array} content
   */
  constructor(content) {
    this.content = content;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.content];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentBinary}
   */
  copy() {
    return new ContentBinary(this.content);
  }
  /**
   * @param {number} offset
   * @return {ContentBinary}
   */
  splice(offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentBinary} right
   * @return {boolean}
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder2, offset) {
    encoder2.writeBuf(this.content);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 3;
  }
};
var readContentBinary = (decoder2) => new ContentBinary(decoder2.readBuf());
var ContentDeleted = class {
  /**
   * @param {number} len
   */
  constructor(len) {
    this.len = len;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.len;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return false;
  }
  /**
   * @return {ContentDeleted}
   */
  copy() {
    return new ContentDeleted(this.len);
  }
  /**
   * @param {number} offset
   * @return {ContentDeleted}
   */
  splice(offset) {
    const right = new ContentDeleted(this.len - offset);
    this.len = offset;
    return right;
  }
  /**
   * @param {ContentDeleted} right
   * @return {boolean}
   */
  mergeWith(right) {
    this.len += right.len;
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
    addToDeleteSet(transaction.deleteSet, item.id.client, item.id.clock, this.len);
    item.markDeleted();
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder2, offset) {
    encoder2.writeLen(this.len - offset);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 1;
  }
};
var readContentDeleted = (decoder2) => new ContentDeleted(decoder2.readLen());
var createDocFromOpts = (guid, opts) => new Doc({ guid, ...opts, shouldLoad: opts.shouldLoad || opts.autoLoad || false });
var ContentDoc = class {
  /**
   * @param {Doc} doc
   */
  constructor(doc2) {
    if (doc2._item) {
      console.error("This document was already integrated as a sub-document. You should create a second instance instead with the same guid.");
    }
    this.doc = doc2;
    const opts = {};
    this.opts = opts;
    if (!doc2.gc) {
      opts.gc = false;
    }
    if (doc2.autoLoad) {
      opts.autoLoad = true;
    }
    if (doc2.meta !== null) {
      opts.meta = doc2.meta;
    }
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.doc];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentDoc}
   */
  copy() {
    return new ContentDoc(createDocFromOpts(this.doc.guid, this.opts));
  }
  /**
   * @param {number} offset
   * @return {ContentDoc}
   */
  splice(offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentDoc} right
   * @return {boolean}
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
    this.doc._item = item;
    transaction.subdocsAdded.add(this.doc);
    if (this.doc.shouldLoad) {
      transaction.subdocsLoaded.add(this.doc);
    }
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
    if (transaction.subdocsAdded.has(this.doc)) {
      transaction.subdocsAdded.delete(this.doc);
    } else {
      transaction.subdocsRemoved.add(this.doc);
    }
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder2, offset) {
    encoder2.writeString(this.doc.guid);
    encoder2.writeAny(this.opts);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 9;
  }
};
var readContentDoc = (decoder2) => new ContentDoc(createDocFromOpts(decoder2.readString(), decoder2.readAny()));
var ContentEmbed = class {
  /**
   * @param {Object} embed
   */
  constructor(embed) {
    this.embed = embed;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.embed];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentEmbed}
   */
  copy() {
    return new ContentEmbed(this.embed);
  }
  /**
   * @param {number} offset
   * @return {ContentEmbed}
   */
  splice(offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentEmbed} right
   * @return {boolean}
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder2, offset) {
    encoder2.writeJSON(this.embed);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 5;
  }
};
var readContentEmbed = (decoder2) => new ContentEmbed(decoder2.readJSON());
var ContentFormat = class {
  /**
   * @param {string} key
   * @param {Object} value
   */
  constructor(key, value) {
    this.key = key;
    this.value = value;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return false;
  }
  /**
   * @return {ContentFormat}
   */
  copy() {
    return new ContentFormat(this.key, this.value);
  }
  /**
   * @param {number} _offset
   * @return {ContentFormat}
   */
  splice(_offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentFormat} _right
   * @return {boolean}
   */
  mergeWith(_right) {
    return false;
  }
  /**
   * @param {Transaction} _transaction
   * @param {Item} item
   */
  integrate(_transaction, item) {
    const p = (
      /** @type {YText} */
      item.parent
    );
    p._searchMarker = null;
    p._hasFormatting = true;
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder2, offset) {
    encoder2.writeKey(this.key);
    encoder2.writeJSON(this.value);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 6;
  }
};
var readContentFormat = (decoder2) => new ContentFormat(decoder2.readKey(), decoder2.readJSON());
var ContentJSON = class {
  /**
   * @param {Array<any>} arr
   */
  constructor(arr) {
    this.arr = arr;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.arr.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.arr;
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentJSON}
   */
  copy() {
    return new ContentJSON(this.arr);
  }
  /**
   * @param {number} offset
   * @return {ContentJSON}
   */
  splice(offset) {
    const right = new ContentJSON(this.arr.slice(offset));
    this.arr = this.arr.slice(0, offset);
    return right;
  }
  /**
   * @param {ContentJSON} right
   * @return {boolean}
   */
  mergeWith(right) {
    this.arr = this.arr.concat(right.arr);
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder2, offset) {
    const len = this.arr.length;
    encoder2.writeLen(len - offset);
    for (let i2 = offset; i2 < len; i2++) {
      const c = this.arr[i2];
      encoder2.writeString(c === void 0 ? "undefined" : JSON.stringify(c));
    }
  }
  /**
   * @return {number}
   */
  getRef() {
    return 2;
  }
};
var readContentJSON = (decoder2) => {
  const len = decoder2.readLen();
  const cs = [];
  for (let i2 = 0; i2 < len; i2++) {
    const c = decoder2.readString();
    if (c === "undefined") {
      cs.push(void 0);
    } else {
      cs.push(JSON.parse(c));
    }
  }
  return new ContentJSON(cs);
};
var ContentAny = class {
  /**
   * @param {Array<any>} arr
   */
  constructor(arr) {
    this.arr = arr;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.arr.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.arr;
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentAny}
   */
  copy() {
    return new ContentAny(this.arr);
  }
  /**
   * @param {number} offset
   * @return {ContentAny}
   */
  splice(offset) {
    const right = new ContentAny(this.arr.slice(offset));
    this.arr = this.arr.slice(0, offset);
    return right;
  }
  /**
   * @param {ContentAny} right
   * @return {boolean}
   */
  mergeWith(right) {
    this.arr = this.arr.concat(right.arr);
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder2, offset) {
    const len = this.arr.length;
    encoder2.writeLen(len - offset);
    for (let i2 = offset; i2 < len; i2++) {
      const c = this.arr[i2];
      encoder2.writeAny(c);
    }
  }
  /**
   * @return {number}
   */
  getRef() {
    return 8;
  }
};
var readContentAny = (decoder2) => {
  const len = decoder2.readLen();
  const cs = [];
  for (let i2 = 0; i2 < len; i2++) {
    cs.push(decoder2.readAny());
  }
  return new ContentAny(cs);
};
var ContentString = class {
  /**
   * @param {string} str
   */
  constructor(str) {
    this.str = str;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.str.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.str.split("");
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentString}
   */
  copy() {
    return new ContentString(this.str);
  }
  /**
   * @param {number} offset
   * @return {ContentString}
   */
  splice(offset) {
    const right = new ContentString(this.str.slice(offset));
    this.str = this.str.slice(0, offset);
    const firstCharCode = this.str.charCodeAt(offset - 1);
    if (firstCharCode >= 55296 && firstCharCode <= 56319) {
      this.str = this.str.slice(0, offset - 1) + "\uFFFD";
      right.str = "\uFFFD" + right.str.slice(1);
    }
    return right;
  }
  /**
   * @param {ContentString} right
   * @return {boolean}
   */
  mergeWith(right) {
    this.str += right.str;
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder2, offset) {
    encoder2.writeString(offset === 0 ? this.str : this.str.slice(offset));
  }
  /**
   * @return {number}
   */
  getRef() {
    return 4;
  }
};
var readContentString = (decoder2) => new ContentString(decoder2.readString());
var typeRefs = [
  readYArray,
  readYMap,
  readYText,
  readYXmlElement,
  readYXmlFragment,
  readYXmlHook,
  readYXmlText
];
var YArrayRefID = 0;
var YMapRefID = 1;
var YTextRefID = 2;
var YXmlElementRefID = 3;
var YXmlFragmentRefID = 4;
var YXmlHookRefID = 5;
var YXmlTextRefID = 6;
var ContentType = class {
  /**
   * @param {AbstractType<any>} type
   */
  constructor(type) {
    this.type = type;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.type];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentType}
   */
  copy() {
    return new ContentType(this.type._copy());
  }
  /**
   * @param {number} offset
   * @return {ContentType}
   */
  splice(offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentType} right
   * @return {boolean}
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
    this.type._integrate(transaction.doc, item);
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
    let item = this.type._start;
    while (item !== null) {
      if (!item.deleted) {
        item.delete(transaction);
      } else if (item.id.clock < (transaction.beforeState.get(item.id.client) || 0)) {
        transaction._mergeStructs.push(item);
      }
      item = item.right;
    }
    this.type._map.forEach((item2) => {
      if (!item2.deleted) {
        item2.delete(transaction);
      } else if (item2.id.clock < (transaction.beforeState.get(item2.id.client) || 0)) {
        transaction._mergeStructs.push(item2);
      }
    });
    transaction.changed.delete(this.type);
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
    let item = this.type._start;
    while (item !== null) {
      item.gc(store, true);
      item = item.right;
    }
    this.type._start = null;
    this.type._map.forEach(
      /** @param {Item | null} item */
      (item2) => {
        while (item2 !== null) {
          item2.gc(store, true);
          item2 = item2.left;
        }
      }
    );
    this.type._map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder2, offset) {
    this.type._write(encoder2);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 7;
  }
};
var readContentType = (decoder2) => new ContentType(typeRefs[decoder2.readTypeRef()](decoder2));
var followRedone = (store, id2) => {
  let nextID = id2;
  let diff = 0;
  let item;
  do {
    if (diff > 0) {
      nextID = createID(nextID.client, nextID.clock + diff);
    }
    item = getItem(store, nextID);
    diff = nextID.clock - item.id.clock;
    nextID = item.redone;
  } while (nextID !== null && item instanceof Item);
  return {
    item,
    diff
  };
};
var splitItem = (transaction, leftItem, diff) => {
  const { client, clock } = leftItem.id;
  const rightItem = new Item(
    createID(client, clock + diff),
    leftItem,
    createID(client, clock + diff - 1),
    leftItem.right,
    leftItem.rightOrigin,
    leftItem.parent,
    leftItem.parentSub,
    leftItem.content.splice(diff)
  );
  if (leftItem.deleted) {
    rightItem.markDeleted();
  }
  if (leftItem.keep) {
    rightItem.keep = true;
  }
  if (leftItem.redone !== null) {
    rightItem.redone = createID(leftItem.redone.client, leftItem.redone.clock + diff);
  }
  leftItem.right = rightItem;
  if (rightItem.right !== null) {
    rightItem.right.left = rightItem;
  }
  transaction._mergeStructs.push(rightItem);
  if (rightItem.parentSub !== null && rightItem.right === null) {
    rightItem.parent._map.set(rightItem.parentSub, rightItem);
  }
  leftItem.length = diff;
  return rightItem;
};
var Item = class extends AbstractStruct {
  /**
   * @param {ID} id
   * @param {Item | null} left
   * @param {ID | null} origin
   * @param {Item | null} right
   * @param {ID | null} rightOrigin
   * @param {AbstractType<any>|ID|null} parent Is a type if integrated, is null if it is possible to copy parent from left or right, is ID before integration to search for it.
   * @param {string | null} parentSub
   * @param {AbstractContent} content
   */
  constructor(id2, left, origin, right, rightOrigin, parent, parentSub, content) {
    super(id2, content.getLength());
    this.origin = origin;
    this.left = left;
    this.right = right;
    this.rightOrigin = rightOrigin;
    this.parent = parent;
    this.parentSub = parentSub;
    this.redone = null;
    this.content = content;
    this.info = this.content.isCountable() ? BIT2 : 0;
  }
  /**
   * This is used to mark the item as an indexed fast-search marker
   *
   * @type {boolean}
   */
  set marker(isMarked) {
    if ((this.info & BIT4) > 0 !== isMarked) {
      this.info ^= BIT4;
    }
  }
  get marker() {
    return (this.info & BIT4) > 0;
  }
  /**
   * If true, do not garbage collect this Item.
   */
  get keep() {
    return (this.info & BIT1) > 0;
  }
  set keep(doKeep) {
    if (this.keep !== doKeep) {
      this.info ^= BIT1;
    }
  }
  get countable() {
    return (this.info & BIT2) > 0;
  }
  /**
   * Whether this item was deleted or not.
   * @type {Boolean}
   */
  get deleted() {
    return (this.info & BIT3) > 0;
  }
  set deleted(doDelete) {
    if (this.deleted !== doDelete) {
      this.info ^= BIT3;
    }
  }
  markDeleted() {
    this.info |= BIT3;
  }
  /**
   * Return the creator clientID of the missing op or define missing items and return null.
   *
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(transaction, store) {
    if (this.origin && this.origin.client !== this.id.client && this.origin.clock >= getState(store, this.origin.client)) {
      return this.origin.client;
    }
    if (this.rightOrigin && this.rightOrigin.client !== this.id.client && this.rightOrigin.clock >= getState(store, this.rightOrigin.client)) {
      return this.rightOrigin.client;
    }
    if (this.parent && this.parent.constructor === ID && this.id.client !== this.parent.client && this.parent.clock >= getState(store, this.parent.client)) {
      return this.parent.client;
    }
    if (this.origin) {
      this.left = getItemCleanEnd(transaction, store, this.origin);
      this.origin = this.left.lastId;
    }
    if (this.rightOrigin) {
      this.right = getItemCleanStart(transaction, this.rightOrigin);
      this.rightOrigin = this.right.id;
    }
    if (this.left && this.left.constructor === GC || this.right && this.right.constructor === GC) {
      this.parent = null;
    } else if (!this.parent) {
      if (this.left && this.left.constructor === Item) {
        this.parent = this.left.parent;
        this.parentSub = this.left.parentSub;
      }
      if (this.right && this.right.constructor === Item) {
        this.parent = this.right.parent;
        this.parentSub = this.right.parentSub;
      }
    } else if (this.parent.constructor === ID) {
      const parentItem = getItem(store, this.parent);
      if (parentItem.constructor === GC) {
        this.parent = null;
      } else {
        this.parent = /** @type {ContentType} */
        parentItem.content.type;
      }
    }
    return null;
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(transaction, offset) {
    if (offset > 0) {
      this.id.clock += offset;
      this.left = getItemCleanEnd(transaction, transaction.doc.store, createID(this.id.client, this.id.clock - 1));
      this.origin = this.left.lastId;
      this.content = this.content.splice(offset);
      this.length -= offset;
    }
    if (this.parent) {
      if (!this.left && (!this.right || this.right.left !== null) || this.left && this.left.right !== this.right) {
        let left = this.left;
        let o;
        if (left !== null) {
          o = left.right;
        } else if (this.parentSub !== null) {
          o = /** @type {AbstractType<any>} */
          this.parent._map.get(this.parentSub) || null;
          while (o !== null && o.left !== null) {
            o = o.left;
          }
        } else {
          o = /** @type {AbstractType<any>} */
          this.parent._start;
        }
        const conflictingItems = /* @__PURE__ */ new Set();
        const itemsBeforeOrigin = /* @__PURE__ */ new Set();
        while (o !== null && o !== this.right) {
          itemsBeforeOrigin.add(o);
          conflictingItems.add(o);
          if (compareIDs(this.origin, o.origin)) {
            if (o.id.client < this.id.client) {
              left = o;
              conflictingItems.clear();
            } else if (compareIDs(this.rightOrigin, o.rightOrigin)) {
              break;
            }
          } else if (o.origin !== null && itemsBeforeOrigin.has(getItem(transaction.doc.store, o.origin))) {
            if (!conflictingItems.has(getItem(transaction.doc.store, o.origin))) {
              left = o;
              conflictingItems.clear();
            }
          } else {
            break;
          }
          o = o.right;
        }
        this.left = left;
      }
      if (this.left !== null) {
        const right = this.left.right;
        this.right = right;
        this.left.right = this;
      } else {
        let r;
        if (this.parentSub !== null) {
          r = /** @type {AbstractType<any>} */
          this.parent._map.get(this.parentSub) || null;
          while (r !== null && r.left !== null) {
            r = r.left;
          }
        } else {
          r = /** @type {AbstractType<any>} */
          this.parent._start;
          this.parent._start = this;
        }
        this.right = r;
      }
      if (this.right !== null) {
        this.right.left = this;
      } else if (this.parentSub !== null) {
        this.parent._map.set(this.parentSub, this);
        if (this.left !== null) {
          this.left.delete(transaction);
        }
      }
      if (this.parentSub === null && this.countable && !this.deleted) {
        this.parent._length += this.length;
      }
      addStruct(transaction.doc.store, this);
      this.content.integrate(transaction, this);
      addChangedTypeToTransaction(
        transaction,
        /** @type {AbstractType<any>} */
        this.parent,
        this.parentSub
      );
      if (
        /** @type {AbstractType<any>} */
        this.parent._item !== null && /** @type {AbstractType<any>} */
        this.parent._item.deleted || this.parentSub !== null && this.right !== null
      ) {
        this.delete(transaction);
      }
    } else {
      new GC(this.id, this.length).integrate(transaction, 0);
    }
  }
  /**
   * Returns the next non-deleted item
   */
  get next() {
    let n = this.right;
    while (n !== null && n.deleted) {
      n = n.right;
    }
    return n;
  }
  /**
   * Returns the previous non-deleted item
   */
  get prev() {
    let n = this.left;
    while (n !== null && n.deleted) {
      n = n.left;
    }
    return n;
  }
  /**
   * Computes the last content address of this Item.
   */
  get lastId() {
    return this.length === 1 ? this.id : createID(this.id.client, this.id.clock + this.length - 1);
  }
  /**
   * Try to merge two items
   *
   * @param {Item} right
   * @return {boolean}
   */
  mergeWith(right) {
    if (this.constructor === right.constructor && compareIDs(right.origin, this.lastId) && this.right === right && compareIDs(this.rightOrigin, right.rightOrigin) && this.id.client === right.id.client && this.id.clock + this.length === right.id.clock && this.deleted === right.deleted && this.redone === null && right.redone === null && this.content.constructor === right.content.constructor && this.content.mergeWith(right.content)) {
      const searchMarker = (
        /** @type {AbstractType<any>} */
        this.parent._searchMarker
      );
      if (searchMarker) {
        searchMarker.forEach((marker) => {
          if (marker.p === right) {
            marker.p = this;
            if (!this.deleted && this.countable) {
              marker.index -= this.length;
            }
          }
        });
      }
      if (right.keep) {
        this.keep = true;
      }
      this.right = right.right;
      if (this.right !== null) {
        this.right.left = this;
      }
      this.length += right.length;
      return true;
    }
    return false;
  }
  /**
   * Mark this Item as deleted.
   *
   * @param {Transaction} transaction
   */
  delete(transaction) {
    if (!this.deleted) {
      const parent = (
        /** @type {AbstractType<any>} */
        this.parent
      );
      if (this.countable && this.parentSub === null) {
        parent._length -= this.length;
      }
      this.markDeleted();
      addToDeleteSet(transaction.deleteSet, this.id.client, this.id.clock, this.length);
      addChangedTypeToTransaction(transaction, parent, this.parentSub);
      this.content.delete(transaction);
    }
  }
  /**
   * @param {StructStore} store
   * @param {boolean} parentGCd
   */
  gc(store, parentGCd) {
    if (!this.deleted) {
      throw unexpectedCase();
    }
    this.content.gc(store);
    if (parentGCd) {
      replaceStruct(store, this, new GC(this.id, this.length));
    } else {
      this.content = new ContentDeleted(this.length);
    }
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   */
  write(encoder2, offset) {
    const origin = offset > 0 ? createID(this.id.client, this.id.clock + offset - 1) : this.origin;
    const rightOrigin = this.rightOrigin;
    const parentSub = this.parentSub;
    const info = this.content.getRef() & BITS5 | (origin === null ? 0 : BIT8) | // origin is defined
    (rightOrigin === null ? 0 : BIT7) | // right origin is defined
    (parentSub === null ? 0 : BIT6);
    encoder2.writeInfo(info);
    if (origin !== null) {
      encoder2.writeLeftID(origin);
    }
    if (rightOrigin !== null) {
      encoder2.writeRightID(rightOrigin);
    }
    if (origin === null && rightOrigin === null) {
      const parent = (
        /** @type {AbstractType<any>} */
        this.parent
      );
      if (parent._item !== void 0) {
        const parentItem = parent._item;
        if (parentItem === null) {
          const ykey = findRootTypeKey(parent);
          encoder2.writeParentInfo(true);
          encoder2.writeString(ykey);
        } else {
          encoder2.writeParentInfo(false);
          encoder2.writeLeftID(parentItem.id);
        }
      } else if (parent.constructor === String) {
        encoder2.writeParentInfo(true);
        encoder2.writeString(parent);
      } else if (parent.constructor === ID) {
        encoder2.writeParentInfo(false);
        encoder2.writeLeftID(parent);
      } else {
        unexpectedCase();
      }
      if (parentSub !== null) {
        encoder2.writeString(parentSub);
      }
    }
    this.content.write(encoder2, offset);
  }
};
var readItemContent = (decoder2, info) => contentRefs[info & BITS5](decoder2);
var contentRefs = [
  () => {
    unexpectedCase();
  },
  // GC is not ItemContent
  readContentDeleted,
  // 1
  readContentJSON,
  // 2
  readContentBinary,
  // 3
  readContentString,
  // 4
  readContentEmbed,
  // 5
  readContentFormat,
  // 6
  readContentType,
  // 7
  readContentAny,
  // 8
  readContentDoc,
  // 9
  () => {
    unexpectedCase();
  }
  // 10 - Skip is not ItemContent
];
var structSkipRefNumber = 10;
var Skip = class extends AbstractStruct {
  get deleted() {
    return true;
  }
  delete() {
  }
  /**
   * @param {Skip} right
   * @return {boolean}
   */
  mergeWith(right) {
    if (this.constructor !== right.constructor) {
      return false;
    }
    this.length += right.length;
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(transaction, offset) {
    unexpectedCase();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder2, offset) {
    encoder2.writeInfo(structSkipRefNumber);
    writeVarUint(encoder2.restEncoder, this.length - offset);
  }
  /**
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(transaction, store) {
    return null;
  }
};
var glo = (
  /** @type {any} */
  typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {}
);
var importIdentifier = "__ $YJS$ __";
if (glo[importIdentifier] === true) {
  console.error("Yjs was already imported. This breaks constructor checks and will lead to issues! - https://github.com/yjs/yjs/issues/438");
}
glo[importIdentifier] = true;

// src/SharedFolder.ts
var import_obsidian3 = require("obsidian");

// node_modules/lib0/indexeddb.js
var rtop = (request) => create4((resolve, reject) => {
  request.onerror = (event) => reject(new Error(event.target.error));
  request.onsuccess = (event) => resolve(event.target.result);
});
var openDB = (name, initDB) => create4((resolve, reject) => {
  const request = indexedDB.open(name);
  request.onupgradeneeded = (event) => initDB(event.target.result);
  request.onerror = (event) => reject(create3(event.target.error));
  request.onsuccess = (event) => {
    const db = event.target.result;
    db.onversionchange = () => {
      db.close();
    };
    resolve(db);
  };
});
var deleteDB = (name) => rtop(indexedDB.deleteDatabase(name));
var createStores = (db, definitions) => definitions.forEach(
  (d) => (
    // @ts-ignore
    db.createObjectStore.apply(db, d)
  )
);
var transact2 = (db, stores, access = "readwrite") => {
  const transaction = db.transaction(stores, access);
  return stores.map((store) => getStore(transaction, store));
};
var count = (store, range) => rtop(store.count(range));
var get = (store, key) => rtop(store.get(key));
var del = (store, key) => rtop(store.delete(key));
var put = (store, item, key) => rtop(store.put(item, key));
var addAutoKey = (store, item) => rtop(store.add(item));
var getAll = (store, range, limit) => rtop(store.getAll(range, limit));
var queryFirst = (store, query, direction) => {
  let first = null;
  return iterateKeys(store, query, (key) => {
    first = key;
    return false;
  }, direction).then(() => first);
};
var getLastKey = (store, range = null) => queryFirst(store, range, "prev");
var iterateOnRequest = (request, f) => create4((resolve, reject) => {
  request.onerror = reject;
  request.onsuccess = async (event) => {
    const cursor = event.target.result;
    if (cursor === null || await f(cursor) === false) {
      return resolve();
    }
    cursor.continue();
  };
});
var iterateKeys = (store, keyrange, f, direction = "next") => iterateOnRequest(store.openKeyCursor(keyrange, direction), (cursor) => f(cursor.key));
var getStore = (t2, store) => t2.objectStore(store);
var createIDBKeyRangeUpperBound = (upper, upperOpen) => IDBKeyRange.upperBound(upper, upperOpen);
var createIDBKeyRangeLowerBound = (lower, lowerOpen) => IDBKeyRange.lowerBound(lower, lowerOpen);

// node_modules/y-indexeddb/src/y-indexeddb.js
var customStoreName = "custom";
var updatesStoreName = "updates";
var PREFERRED_TRIM_SIZE = 500;
var fetchUpdates = (idbPersistence, beforeApplyUpdatesCallback = () => {
}, afterApplyUpdatesCallback = () => {
}) => {
  const [updatesStore] = transact2(
    /** @type {IDBDatabase} */
    idbPersistence.db,
    [updatesStoreName]
  );
  return getAll(updatesStore, createIDBKeyRangeLowerBound(idbPersistence._dbref, false)).then((updates) => {
    if (!idbPersistence._destroyed) {
      beforeApplyUpdatesCallback(updatesStore);
      transact(idbPersistence.doc, () => {
        updates.forEach((val) => applyUpdate(idbPersistence.doc, val));
      }, idbPersistence, false);
      afterApplyUpdatesCallback(updatesStore);
    }
  }).then(() => getLastKey(updatesStore).then((lastKey) => {
    idbPersistence._dbref = lastKey + 1;
  })).then(() => count(updatesStore).then((cnt) => {
    idbPersistence._dbsize = cnt;
  })).then(() => updatesStore);
};
var storeState = (idbPersistence, forceStore = true) => fetchUpdates(idbPersistence).then((updatesStore) => {
  if (forceStore || idbPersistence._dbsize >= PREFERRED_TRIM_SIZE) {
    addAutoKey(updatesStore, encodeStateAsUpdate(idbPersistence.doc)).then(() => del(updatesStore, createIDBKeyRangeUpperBound(idbPersistence._dbref, true))).then(() => count(updatesStore).then((cnt) => {
      idbPersistence._dbsize = cnt;
    }));
  }
});
var IndexeddbPersistence = class extends Observable {
  /**
   * @param {string} name
   * @param {Y.Doc} doc
   */
  constructor(name, doc2) {
    super();
    this.doc = doc2;
    this.name = name;
    this._dbref = 0;
    this._dbsize = 0;
    this._destroyed = false;
    this.db = null;
    this.synced = false;
    this._db = openDB(
      name,
      (db) => createStores(db, [
        ["updates", { autoIncrement: true }],
        ["custom"]
      ])
    );
    this.whenSynced = create4((resolve) => this.on("synced", () => resolve(this)));
    this._db.then((db) => {
      this.db = db;
      const beforeApplyUpdatesCallback = (updatesStore) => addAutoKey(updatesStore, encodeStateAsUpdate(doc2));
      const afterApplyUpdatesCallback = () => {
        if (this._destroyed)
          return this;
        this.synced = true;
        this.emit("synced", [this]);
      };
      fetchUpdates(this, beforeApplyUpdatesCallback, afterApplyUpdatesCallback);
    });
    this._storeTimeout = 1e3;
    this._storeTimeoutId = null;
    this._storeUpdate = (update2, origin) => {
      if (this.db && origin !== this) {
        const [updatesStore] = transact2(
          /** @type {IDBDatabase} */
          this.db,
          [updatesStoreName]
        );
        addAutoKey(updatesStore, update2);
        if (++this._dbsize >= PREFERRED_TRIM_SIZE) {
          if (this._storeTimeoutId !== null) {
            clearTimeout(this._storeTimeoutId);
          }
          this._storeTimeoutId = setTimeout(() => {
            storeState(this, false);
            this._storeTimeoutId = null;
          }, this._storeTimeout);
        }
      }
    };
    doc2.on("update", this._storeUpdate);
    this.destroy = this.destroy.bind(this);
    doc2.on("destroy", this.destroy);
  }
  destroy() {
    if (this._storeTimeoutId) {
      clearTimeout(this._storeTimeoutId);
    }
    this.doc.off("update", this._storeUpdate);
    this.doc.off("destroy", this.destroy);
    this._destroyed = true;
    return this._db.then((db) => {
      db.close();
    });
  }
  /**
   * Destroys this instance and removes all data from indexeddb.
   *
   * @return {Promise<void>}
   */
  clearData() {
    return this.destroy().then(() => {
      deleteDB(this.name);
    });
  }
  /**
   * @param {String | number | ArrayBuffer | Date} key
   * @return {Promise<String | number | ArrayBuffer | Date | any>}
   */
  get(key) {
    return this._db.then((db) => {
      const [custom] = transact2(db, [customStoreName], "readonly");
      return get(custom, key);
    });
  }
  /**
   * @param {String | number | ArrayBuffer | Date} key
   * @param {String | number | ArrayBuffer | Date} value
   * @return {Promise<String | number | ArrayBuffer | Date>}
   */
  set(key, value) {
    return this._db.then((db) => {
      const [custom] = transact2(db, [customStoreName]);
      return put(custom, value, key);
    });
  }
  /**
   * @param {String | number | ArrayBuffer | Date} key
   * @return {Promise<undefined>}
   */
  del(key) {
    return this._db.then((db) => {
      const [custom] = transact2(db, [customStoreName]);
      return del(custom, key);
    });
  }
};

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues2;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues2) {
    getRandomValues2 = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues2) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues2(rnds8);
}

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i2 = 0; i2 < 256; ++i2) {
  byteToHex.push((i2 + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}

// node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i2 = 0; i2 < 16; ++i2) {
      buf[offset + i2] = rnds[i2];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// src/SharedFolder.ts
var import_path_browserify = __toESM(require_path_browserify());

// node_modules/y-protocols/sync.js
var messageYjsSyncStep1 = 0;
var messageYjsSyncStep2 = 1;
var messageYjsUpdate = 2;
var writeSyncStep1 = (encoder2, doc2) => {
  writeVarUint(encoder2, messageYjsSyncStep1);
  const sv = encodeStateVector(doc2);
  writeVarUint8Array(encoder2, sv);
};
var writeSyncStep2 = (encoder2, doc2, encodedStateVector) => {
  writeVarUint(encoder2, messageYjsSyncStep2);
  writeVarUint8Array(encoder2, encodeStateAsUpdate(doc2, encodedStateVector));
};
var readSyncStep1 = (decoder2, encoder2, doc2) => writeSyncStep2(encoder2, doc2, readVarUint8Array(decoder2));
var readSyncStep2 = (decoder2, doc2, transactionOrigin) => {
  try {
    applyUpdate(doc2, readVarUint8Array(decoder2), transactionOrigin);
  } catch (error) {
    console.error("Caught error while handling a Yjs update", error);
  }
};
var writeUpdate = (encoder2, update2) => {
  writeVarUint(encoder2, messageYjsUpdate);
  writeVarUint8Array(encoder2, update2);
};
var readUpdate = readSyncStep2;
var readSyncMessage = (decoder2, encoder2, doc2, transactionOrigin) => {
  const messageType = readVarUint(decoder2);
  switch (messageType) {
    case messageYjsSyncStep1:
      readSyncStep1(decoder2, encoder2, doc2);
      break;
    case messageYjsSyncStep2:
      readSyncStep2(decoder2, doc2, transactionOrigin);
      break;
    case messageYjsUpdate:
      readUpdate(decoder2, doc2, transactionOrigin);
      break;
    default:
      throw new Error("Unknown message type");
  }
  return messageType;
};

// node_modules/y-protocols/auth.js
var messagePermissionDenied = 0;
var readAuthMessage = (decoder2, y, permissionDeniedHandler2) => {
  switch (readVarUint(decoder2)) {
    case messagePermissionDenied:
      permissionDeniedHandler2(y, readVarString(decoder2));
  }
};

// node_modules/y-protocols/awareness.js
var outdatedTimeout = 3e4;
var Awareness = class extends Observable {
  /**
   * @param {Y.Doc} doc
   */
  constructor(doc2) {
    super();
    this.doc = doc2;
    this.clientID = doc2.clientID;
    this.states = /* @__PURE__ */ new Map();
    this.meta = /* @__PURE__ */ new Map();
    this._checkInterval = /** @type {any} */
    setInterval(() => {
      const now2 = getUnixTime();
      if (this.getLocalState() !== null && outdatedTimeout / 2 <= now2 - /** @type {{lastUpdated:number}} */
      this.meta.get(this.clientID).lastUpdated) {
        this.setLocalState(this.getLocalState());
      }
      const remove = [];
      this.meta.forEach((meta, clientid) => {
        if (clientid !== this.clientID && outdatedTimeout <= now2 - meta.lastUpdated && this.states.has(clientid)) {
          remove.push(clientid);
        }
      });
      if (remove.length > 0) {
        removeAwarenessStates(this, remove, "timeout");
      }
    }, floor(outdatedTimeout / 10));
    doc2.on("destroy", () => {
      this.destroy();
    });
    this.setLocalState({});
  }
  destroy() {
    this.emit("destroy", [this]);
    this.setLocalState(null);
    super.destroy();
    clearInterval(this._checkInterval);
  }
  /**
   * @return {Object<string,any>|null}
   */
  getLocalState() {
    return this.states.get(this.clientID) || null;
  }
  /**
   * @param {Object<string,any>|null} state
   */
  setLocalState(state) {
    const clientID = this.clientID;
    const currLocalMeta = this.meta.get(clientID);
    const clock = currLocalMeta === void 0 ? 0 : currLocalMeta.clock + 1;
    const prevState = this.states.get(clientID);
    if (state === null) {
      this.states.delete(clientID);
    } else {
      this.states.set(clientID, state);
    }
    this.meta.set(clientID, {
      clock,
      lastUpdated: getUnixTime()
    });
    const added = [];
    const updated = [];
    const filteredUpdated = [];
    const removed = [];
    if (state === null) {
      removed.push(clientID);
    } else if (prevState == null) {
      if (state != null) {
        added.push(clientID);
      }
    } else {
      updated.push(clientID);
      if (!equalityDeep(prevState, state)) {
        filteredUpdated.push(clientID);
      }
    }
    if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {
      this.emit("change", [{ added, updated: filteredUpdated, removed }, "local"]);
    }
    this.emit("update", [{ added, updated, removed }, "local"]);
  }
  /**
   * @param {string} field
   * @param {any} value
   */
  setLocalStateField(field, value) {
    const state = this.getLocalState();
    if (state !== null) {
      this.setLocalState({
        ...state,
        [field]: value
      });
    }
  }
  /**
   * @return {Map<number,Object<string,any>>}
   */
  getStates() {
    return this.states;
  }
};
var removeAwarenessStates = (awareness, clients, origin) => {
  const removed = [];
  for (let i2 = 0; i2 < clients.length; i2++) {
    const clientID = clients[i2];
    if (awareness.states.has(clientID)) {
      awareness.states.delete(clientID);
      if (clientID === awareness.clientID) {
        const curMeta = (
          /** @type {MetaClientState} */
          awareness.meta.get(clientID)
        );
        awareness.meta.set(clientID, {
          clock: curMeta.clock + 1,
          lastUpdated: getUnixTime()
        });
      }
      removed.push(clientID);
    }
  }
  if (removed.length > 0) {
    awareness.emit("change", [{ added: [], updated: [], removed }, origin]);
    awareness.emit("update", [{ added: [], updated: [], removed }, origin]);
  }
};
var encodeAwarenessUpdate = (awareness, clients, states = awareness.states) => {
  const len = clients.length;
  const encoder2 = createEncoder();
  writeVarUint(encoder2, len);
  for (let i2 = 0; i2 < len; i2++) {
    const clientID = clients[i2];
    const state = states.get(clientID) || null;
    const clock = (
      /** @type {MetaClientState} */
      awareness.meta.get(clientID).clock
    );
    writeVarUint(encoder2, clientID);
    writeVarUint(encoder2, clock);
    writeVarString(encoder2, JSON.stringify(state));
  }
  return toUint8Array(encoder2);
};
var applyAwarenessUpdate = (awareness, update2, origin) => {
  const decoder2 = createDecoder(update2);
  const timestamp = getUnixTime();
  const added = [];
  const updated = [];
  const filteredUpdated = [];
  const removed = [];
  const len = readVarUint(decoder2);
  for (let i2 = 0; i2 < len; i2++) {
    const clientID = readVarUint(decoder2);
    let clock = readVarUint(decoder2);
    const state = JSON.parse(readVarString(decoder2));
    const clientMeta = awareness.meta.get(clientID);
    const prevState = awareness.states.get(clientID);
    const currClock = clientMeta === void 0 ? 0 : clientMeta.clock;
    if (currClock < clock || currClock === clock && state === null && awareness.states.has(clientID)) {
      if (state === null) {
        if (clientID === awareness.clientID && awareness.getLocalState() != null) {
          clock++;
        } else {
          awareness.states.delete(clientID);
        }
      } else {
        awareness.states.set(clientID, state);
      }
      awareness.meta.set(clientID, {
        clock,
        lastUpdated: timestamp
      });
      if (clientMeta === void 0 && state !== null) {
        added.push(clientID);
      } else if (clientMeta !== void 0 && state === null) {
        removed.push(clientID);
      } else if (state !== null) {
        if (!equalityDeep(state, prevState)) {
          filteredUpdated.push(clientID);
        }
        updated.push(clientID);
      }
    }
  }
  if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {
    awareness.emit("change", [{
      added,
      updated: filteredUpdated,
      removed
    }, origin]);
  }
  if (added.length > 0 || updated.length > 0 || removed.length > 0) {
    awareness.emit("update", [{
      added,
      updated,
      removed
    }, origin]);
  }
};

// node_modules/@y-sweet/client/dist/main.mjs
var create7 = () => /* @__PURE__ */ new Map();
var setIfUndefined2 = (map22, key, createT) => {
  let set = map22.get(key);
  if (set === void 0) {
    map22.set(key, set = createT());
  }
  return set;
};
var create22 = () => /* @__PURE__ */ new Set();
var from2 = Array.from;
var isArray2 = Array.isArray;
var fromCharCode2 = String.fromCharCode;
var fromCodePoint2 = String.fromCodePoint;
var MAX_UTF16_CHARACTER2 = fromCharCode2(65535);
var toLowerCase2 = (s2) => s2.toLowerCase();
var trimLeftRegex2 = /^\s*/g;
var trimLeft2 = (s2) => s2.replace(trimLeftRegex2, "");
var fromCamelCaseRegex2 = /([A-Z])/g;
var fromCamelCase2 = (s2, separator) => trimLeft2(s2.replace(fromCamelCaseRegex2, (match) => `${separator}${toLowerCase2(match)}`));
var _encodeUtf8Polyfill2 = (str) => {
  const encodedString = unescape(encodeURIComponent(str));
  const len = encodedString.length;
  const buf = new Uint8Array(len);
  for (let i2 = 0; i2 < len; i2++) {
    buf[i2] = /** @type {number} */
    encodedString.codePointAt(i2);
  }
  return buf;
};
var utf8TextEncoder2 = (
  /** @type {TextEncoder} */
  typeof TextEncoder !== "undefined" ? new TextEncoder() : null
);
var _encodeUtf8Native2 = (str) => utf8TextEncoder2.encode(str);
var encodeUtf82 = utf8TextEncoder2 ? _encodeUtf8Native2 : _encodeUtf8Polyfill2;
var utf8TextDecoder2 = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf-8", { fatal: true, ignoreBOM: true });
if (utf8TextDecoder2 && utf8TextDecoder2.decode(new Uint8Array()).length === 1) {
  utf8TextDecoder2 = null;
}
var undefinedToNull2 = (v) => v === void 0 ? null : v;
var VarStoragePolyfill2 = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {string} key
   * @param {any} newValue
   */
  setItem(key, newValue) {
    this.map.set(key, newValue);
  }
  /**
   * @param {string} key
   */
  getItem(key) {
    return this.map.get(key);
  }
};
var _localStorage2 = new VarStoragePolyfill2();
var usePolyfill2 = true;
try {
  if (typeof localStorage !== "undefined") {
    _localStorage2 = localStorage;
    usePolyfill2 = false;
  }
} catch (e2) {
}
var varStorage2 = _localStorage2;
var onChange = (eventHandler) => usePolyfill2 || addEventListener(
  "storage",
  /** @type {any} */
  eventHandler
);
var offChange = (eventHandler) => usePolyfill2 || removeEventListener(
  "storage",
  /** @type {any} */
  eventHandler
);
var map2 = (obj, f) => {
  const results = [];
  for (const key in obj) {
    results.push(f(obj[key], key));
  }
  return results;
};
var isOneOf2 = (value, options) => options.includes(value);
var isNode2 = typeof process !== "undefined" && process.release && /node|io\.js/.test(process.release.name);
var isBrowser2 = typeof window !== "undefined" && typeof document !== "undefined" && !isNode2;
var isMac2 = typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
var params2;
var args2 = [];
var computeParams2 = () => {
  if (params2 === void 0) {
    if (isNode2) {
      params2 = create7();
      const pargs = process.argv;
      let currParamName = null;
      for (let i2 = 0; i2 < pargs.length; i2++) {
        const parg = pargs[i2];
        if (parg[0] === "-") {
          if (currParamName !== null) {
            params2.set(currParamName, "");
          }
          currParamName = parg;
        } else {
          if (currParamName !== null) {
            params2.set(currParamName, parg);
            currParamName = null;
          } else {
            args2.push(parg);
          }
        }
      }
      if (currParamName !== null) {
        params2.set(currParamName, "");
      }
    } else if (typeof location === "object") {
      params2 = create7();
      (location.search || "?").slice(1).split("&").forEach((kv) => {
        if (kv.length !== 0) {
          const [key, value] = kv.split("=");
          params2.set(`--${fromCamelCase2(key, "-")}`, value);
          params2.set(`-${fromCamelCase2(key, "-")}`, value);
        }
      });
    } else {
      params2 = create7();
    }
  }
  return params2;
};
var hasParam2 = (name) => computeParams2().has(name);
var getVariable2 = (name) => isNode2 ? undefinedToNull2(process.env[name.toUpperCase()]) : undefinedToNull2(varStorage2.getItem(name));
var hasConf2 = (name) => hasParam2("--" + name) || getVariable2(name) !== null;
var production2 = hasConf2("production");
var forceColor2 = isNode2 && isOneOf2(process.env.FORCE_COLOR, ["true", "1", "2"]);
var supportsColor2 = !hasParam2("no-colors") && (!isNode2 || process.stdout.isTTY || forceColor2) && (!isNode2 || hasParam2("color") || forceColor2 || getVariable2("COLORTERM") !== null || (getVariable2("TERM") || "").includes("color"));
var floor2 = Math.floor;
var min2 = (a, b) => a < b ? a : b;
var max2 = (a, b) => a > b ? a : b;
var isNaN4 = Number.isNaN;
var pow = Math.pow;
var BIT82 = 128;
var BIT182 = 1 << 17;
var BIT192 = 1 << 18;
var BIT202 = 1 << 19;
var BIT212 = 1 << 20;
var BIT222 = 1 << 21;
var BIT232 = 1 << 22;
var BIT242 = 1 << 23;
var BIT252 = 1 << 24;
var BIT262 = 1 << 25;
var BIT272 = 1 << 26;
var BIT282 = 1 << 27;
var BIT292 = 1 << 28;
var BIT302 = 1 << 29;
var BIT312 = 1 << 30;
var BIT322 = 1 << 31;
var BITS72 = 127;
var BITS172 = BIT182 - 1;
var BITS182 = BIT192 - 1;
var BITS192 = BIT202 - 1;
var BITS202 = BIT212 - 1;
var BITS212 = BIT222 - 1;
var BITS222 = BIT232 - 1;
var BITS232 = BIT242 - 1;
var BITS242 = BIT252 - 1;
var BITS252 = BIT262 - 1;
var BITS262 = BIT272 - 1;
var BITS272 = BIT282 - 1;
var BITS282 = BIT292 - 1;
var BITS292 = BIT302 - 1;
var BITS302 = BIT312 - 1;
var MAX_SAFE_INTEGER2 = Number.MAX_SAFE_INTEGER;
var MIN_SAFE_INTEGER2 = Number.MIN_SAFE_INTEGER;
var LOWEST_INT322 = 1 << 31;
var isInteger2 = Number.isInteger || ((num) => typeof num === "number" && isFinite(num) && floor2(num) === num);
var isNaN22 = Number.isNaN;
var parseInt3 = Number.parseInt;
var Encoder2 = class {
  constructor() {
    this.cpos = 0;
    this.cbuf = new Uint8Array(100);
    this.bufs = [];
  }
};
var createEncoder2 = () => new Encoder2();
var length3 = (encoder2) => {
  let len = encoder2.cpos;
  for (let i2 = 0; i2 < encoder2.bufs.length; i2++) {
    len += encoder2.bufs[i2].length;
  }
  return len;
};
var toUint8Array2 = (encoder2) => {
  const uint8arr = new Uint8Array(length3(encoder2));
  let curPos = 0;
  for (let i2 = 0; i2 < encoder2.bufs.length; i2++) {
    const d = encoder2.bufs[i2];
    uint8arr.set(d, curPos);
    curPos += d.length;
  }
  uint8arr.set(createUint8ArrayViewFromArrayBuffer(encoder2.cbuf.buffer, 0, encoder2.cpos), curPos);
  return uint8arr;
};
var write2 = (encoder2, num) => {
  const bufferLen = encoder2.cbuf.length;
  if (encoder2.cpos === bufferLen) {
    encoder2.bufs.push(encoder2.cbuf);
    encoder2.cbuf = new Uint8Array(bufferLen * 2);
    encoder2.cpos = 0;
  }
  encoder2.cbuf[encoder2.cpos++] = num;
};
var writeVarUint2 = (encoder2, num) => {
  while (num > BITS72) {
    write2(encoder2, BIT82 | BITS72 & num);
    num = floor2(num / 128);
  }
  write2(encoder2, BITS72 & num);
};
var _strBuffer2 = new Uint8Array(3e4);
var _maxStrBSize2 = _strBuffer2.length / 3;
var _writeVarStringNative2 = (encoder2, str) => {
  if (str.length < _maxStrBSize2) {
    const written = utf8TextEncoder2.encodeInto(str, _strBuffer2).written || 0;
    writeVarUint2(encoder2, written);
    for (let i2 = 0; i2 < written; i2++) {
      write2(encoder2, _strBuffer2[i2]);
    }
  } else {
    writeVarUint8Array2(encoder2, encodeUtf82(str));
  }
};
var _writeVarStringPolyfill2 = (encoder2, str) => {
  const encodedString = unescape(encodeURIComponent(str));
  const len = encodedString.length;
  writeVarUint2(encoder2, len);
  for (let i2 = 0; i2 < len; i2++) {
    write2(
      encoder2,
      /** @type {number} */
      encodedString.codePointAt(i2)
    );
  }
};
var writeVarString2 = utf8TextEncoder2 && /** @type {any} */
utf8TextEncoder2.encodeInto ? _writeVarStringNative2 : _writeVarStringPolyfill2;
var writeUint8Array2 = (encoder2, uint8Array) => {
  const bufferLen = encoder2.cbuf.length;
  const cpos = encoder2.cpos;
  const leftCopyLen = min2(bufferLen - cpos, uint8Array.length);
  const rightCopyLen = uint8Array.length - leftCopyLen;
  encoder2.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos);
  encoder2.cpos += leftCopyLen;
  if (rightCopyLen > 0) {
    encoder2.bufs.push(encoder2.cbuf);
    encoder2.cbuf = new Uint8Array(max2(bufferLen * 2, rightCopyLen));
    encoder2.cbuf.set(uint8Array.subarray(leftCopyLen));
    encoder2.cpos = rightCopyLen;
  }
};
var writeVarUint8Array2 = (encoder2, uint8Array) => {
  writeVarUint2(encoder2, uint8Array.byteLength);
  writeUint8Array2(encoder2, uint8Array);
};
var floatTestBed2 = new DataView(new ArrayBuffer(4));
var create32 = (s2) => new Error(s2);
var errorUnexpectedEndOfArray2 = create32("Unexpected end of array");
var errorIntegerOutOfRange2 = create32("Integer out of Range");
var Decoder2 = class {
  /**
   * @param {Uint8Array} uint8Array Binary data to decode
   */
  constructor(uint8Array) {
    this.arr = uint8Array;
    this.pos = 0;
  }
};
var createDecoder2 = (uint8Array) => new Decoder2(uint8Array);
var readUint8Array2 = (decoder2, len) => {
  const view = createUint8ArrayViewFromArrayBuffer(decoder2.arr.buffer, decoder2.pos + decoder2.arr.byteOffset, len);
  decoder2.pos += len;
  return view;
};
var readVarUint8Array2 = (decoder2) => readUint8Array2(decoder2, readVarUint2(decoder2));
var readVarUint2 = (decoder2) => {
  let num = 0;
  let mult = 1;
  const len = decoder2.arr.length;
  while (decoder2.pos < len) {
    const r = decoder2.arr[decoder2.pos++];
    num = num + (r & BITS72) * mult;
    mult *= 128;
    if (r < BIT82) {
      return num;
    }
    if (num > MAX_SAFE_INTEGER2) {
      throw errorIntegerOutOfRange2;
    }
  }
  throw errorUnexpectedEndOfArray2;
};
var createUint8ArrayFromLen2 = (len) => new Uint8Array(len);
var createUint8ArrayViewFromArrayBuffer = (buffer, byteOffset, length22) => new Uint8Array(buffer, byteOffset, length22);
var createUint8ArrayFromArrayBuffer = (buffer) => new Uint8Array(buffer);
var toBase64Browser = (bytes) => {
  let s2 = "";
  for (let i2 = 0; i2 < bytes.byteLength; i2++) {
    s2 += fromCharCode2(bytes[i2]);
  }
  return btoa(s2);
};
var toBase64Node = (bytes) => Buffer.from(bytes.buffer, bytes.byteOffset, bytes.byteLength).toString("base64");
var fromBase64Browser = (s2) => {
  const a = atob(s2);
  const bytes = createUint8ArrayFromLen2(a.length);
  for (let i2 = 0; i2 < a.length; i2++) {
    bytes[i2] = a.charCodeAt(i2);
  }
  return bytes;
};
var fromBase64Node = (s2) => {
  const buf = Buffer.from(s2, "base64");
  return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
};
var toBase64 = isBrowser2 ? toBase64Browser : toBase64Node;
var fromBase64 = isBrowser2 ? fromBase64Browser : fromBase64Node;
var channels = /* @__PURE__ */ new Map();
var LocalStoragePolyfill = class {
  /**
   * @param {string} room
   */
  constructor(room) {
    this.room = room;
    this.onmessage = null;
    this._onChange = (e2) => e2.key === room && this.onmessage !== null && this.onmessage({ data: fromBase64(e2.newValue || "") });
    onChange(this._onChange);
  }
  /**
   * @param {ArrayBuffer} buf
   */
  postMessage(buf) {
    varStorage2.setItem(this.room, toBase64(createUint8ArrayFromArrayBuffer(buf)));
  }
  close() {
    offChange(this._onChange);
  }
};
var BC = typeof BroadcastChannel === "undefined" ? LocalStoragePolyfill : BroadcastChannel;
var getChannel = (room) => setIfUndefined2(channels, room, () => {
  const subs = create22();
  const bc = new BC(room);
  bc.onmessage = (e2) => subs.forEach((sub) => sub(e2.data, "broadcastchannel"));
  return {
    bc,
    subs
  };
});
var subscribe = (room, f) => {
  getChannel(room).subs.add(f);
  return f;
};
var unsubscribe = (room, f) => {
  const channel = getChannel(room);
  const unsubscribed = channel.subs.delete(f);
  if (unsubscribed && channel.subs.size === 0) {
    channel.bc.close();
    channels.delete(room);
  }
  return unsubscribed;
};
var publish = (room, data, origin = null) => {
  const c = getChannel(room);
  c.bc.postMessage(data);
  c.subs.forEach((sub) => sub(data, origin));
};
var getUnixTime2 = Date.now;
var Observable2 = class {
  constructor() {
    this._observers = create7();
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  on(name, f) {
    setIfUndefined2(this._observers, name, create22).add(f);
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  once(name, f) {
    const _f = (...args22) => {
      this.off(name, _f);
      f(...args22);
    };
    this.on(name, _f);
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  off(name, f) {
    const observers = this._observers.get(name);
    if (observers !== void 0) {
      observers.delete(f);
      if (observers.size === 0) {
        this._observers.delete(name);
      }
    }
  }
  /**
   * Emit a named event. All registered event listeners that listen to the
   * specified name will receive the event.
   *
   * @todo This should catch exceptions
   *
   * @param {N} name The event name.
   * @param {Array<any>} args The arguments that are applied to the event listener.
   */
  emit(name, args22) {
    return from2((this._observers.get(name) || create7()).values()).forEach((f) => f(...args22));
  }
  destroy() {
    this._observers = create7();
  }
};
var encodeQueryParams = (params22) => map2(params22, (val, key) => `${encodeURIComponent(key)}=${encodeURIComponent(val)}`).join("&");
var messageSync = 0;
var messageQueryAwareness = 3;
var messageAwareness = 1;
var messageAuth = 2;
var messageHandlers = [];
messageHandlers[messageSync] = (encoder2, decoder2, provider, emitSynced, _messageType) => {
  writeVarUint2(encoder2, messageSync);
  const syncMessageType = readSyncMessage(decoder2, encoder2, provider.doc, provider);
  if (emitSynced && syncMessageType === messageYjsSyncStep2 && !provider.synced) {
    provider.synced = true;
  }
};
messageHandlers[messageQueryAwareness] = (encoder2, _decoder, provider, _emitSynced, _messageType) => {
  writeVarUint2(encoder2, messageAwareness);
  writeVarUint8Array2(
    encoder2,
    encodeAwarenessUpdate(
      provider.awareness,
      Array.from(provider.awareness.getStates().keys())
    )
  );
};
messageHandlers[messageAwareness] = (_encoder, decoder2, provider, _emitSynced, _messageType) => {
  applyAwarenessUpdate(
    provider.awareness,
    readVarUint8Array2(decoder2),
    provider
  );
};
messageHandlers[messageAuth] = (_encoder, decoder2, provider, _emitSynced, _messageType) => {
  readAuthMessage(
    decoder2,
    provider.doc,
    (_ydoc, reason) => permissionDeniedHandler(provider, reason)
  );
};
var messageReconnectTimeout = 3e4;
var permissionDeniedHandler = (provider, reason) => console.warn(`Permission denied to access ${provider.url}.
${reason}`);
var readMessage = (provider, buf, emitSynced) => {
  const decoder2 = createDecoder2(buf);
  const encoder2 = createEncoder2();
  const messageType = readVarUint2(decoder2);
  const messageHandler = provider.messageHandlers[messageType];
  if (
    /** @type {any} */
    messageHandler
  ) {
    messageHandler(encoder2, decoder2, provider, emitSynced, messageType);
  } else {
    console.error("Unable to compute message");
  }
  return encoder2;
};
var setupWS = (provider) => {
  if (provider.shouldConnect && provider.ws === null) {
    const websocket = new provider._WS(provider.url);
    websocket.binaryType = "arraybuffer";
    provider.ws = websocket;
    provider.wsconnecting = true;
    provider.wsconnected = false;
    provider.synced = false;
    websocket.onmessage = (event) => {
      provider.wsLastMessageReceived = getUnixTime2();
      const encoder2 = readMessage(provider, new Uint8Array(event.data), true);
      if (length3(encoder2) > 1) {
        websocket.send(toUint8Array2(encoder2));
      }
    };
    websocket.onerror = (event) => {
      provider.emit("connection-error", [event, provider]);
    };
    websocket.onclose = (event) => {
      provider.emit("connection-close", [event, provider]);
      provider.ws = null;
      provider.wsconnecting = false;
      if (provider.wsconnected) {
        provider.wsconnected = false;
        provider.synced = false;
        removeAwarenessStates(
          provider.awareness,
          Array.from(provider.awareness.getStates().keys()).filter(
            (client) => client !== provider.doc.clientID
          ),
          provider
        );
        provider.emit("status", [
          {
            status: "disconnected"
          }
        ]);
      } else {
        provider.wsUnsuccessfulReconnects++;
      }
      setTimeout(
        setupWS,
        min2(pow(2, provider.wsUnsuccessfulReconnects) * 100, provider.maxBackoffTime),
        provider
      );
    };
    websocket.onopen = () => {
      provider.wsLastMessageReceived = getUnixTime2();
      provider.wsconnecting = false;
      provider.wsconnected = true;
      provider.wsUnsuccessfulReconnects = 0;
      provider.emit("status", [
        {
          status: "connected"
        }
      ]);
      const encoder2 = createEncoder2();
      writeVarUint2(encoder2, messageSync);
      writeSyncStep1(encoder2, provider.doc);
      websocket.send(toUint8Array2(encoder2));
      if (provider.awareness.getLocalState() !== null) {
        const encoderAwarenessState = createEncoder2();
        writeVarUint2(encoderAwarenessState, messageAwareness);
        writeVarUint8Array2(
          encoderAwarenessState,
          encodeAwarenessUpdate(provider.awareness, [provider.doc.clientID])
        );
        websocket.send(toUint8Array2(encoderAwarenessState));
      }
    };
    provider.emit("status", [
      {
        status: "connecting"
      }
    ]);
  }
};
var broadcastMessage = (provider, buf) => {
  const ws = provider.ws;
  if (provider.wsconnected && ws && ws.readyState === ws.OPEN) {
    ws.send(buf);
  }
  if (provider.bcconnected) {
    publish(provider.bcChannel, buf, provider);
  }
};
var YSweetProvider = class extends Observable2 {
  /**
   * @param serverUrl - server url
   * @param roomname - room name
   * @param doc - Y.Doc instance
   * @param opts - options
   * @param opts.connect - connect option
   * @param opts.awareness - awareness protocol instance
   * @param opts.params - parameters
   * @param opts.WebSocketPolyfill - WebSocket polyfill
   * @param opts.resyncInterval - resync interval
   * @param opts.maxBackoffTime - maximum backoff time
   * @param opts.disableBc - disable broadcast channel
   */
  constructor(serverUrl, roomname, doc2, {
    connect = true,
    awareness = new Awareness(doc2),
    params: params22 = {},
    WebSocketPolyfill = WebSocket,
    resyncInterval = -1,
    maxBackoffTime = 2500,
    disableBc = false
  } = {}) {
    super();
    while (serverUrl[serverUrl.length - 1] === "/") {
      serverUrl = serverUrl.slice(0, serverUrl.length - 1);
    }
    const encodedParams = encodeQueryParams(params22);
    this.maxBackoffTime = maxBackoffTime;
    this.bcChannel = serverUrl + "/" + roomname;
    this.url = serverUrl + "/" + roomname + (encodedParams.length === 0 ? "" : "?" + encodedParams);
    this.roomname = roomname;
    this.doc = doc2;
    this._WS = WebSocketPolyfill;
    this.awareness = awareness;
    this.wsconnected = false;
    this.wsconnecting = false;
    this.bcconnected = false;
    this.disableBc = disableBc;
    this.wsUnsuccessfulReconnects = 0;
    this.messageHandlers = messageHandlers.slice();
    this._synced = false;
    this.ws = null;
    this.wsLastMessageReceived = 0;
    this.shouldConnect = connect;
    this._resyncInterval = 0;
    if (resyncInterval > 0) {
      this._resyncInterval = setInterval(() => {
        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
          const encoder2 = createEncoder2();
          writeVarUint2(encoder2, messageSync);
          writeSyncStep1(encoder2, doc2);
          this.ws.send(toUint8Array2(encoder2));
        }
      }, resyncInterval);
    }
    this._bcSubscriber = (data, origin) => {
      if (origin !== this) {
        const encoder2 = readMessage(this, new Uint8Array(data), false);
        if (length3(encoder2) > 1) {
          publish(this.bcChannel, toUint8Array2(encoder2), this);
        }
      }
    };
    this._updateHandler = (update2, origin) => {
      if (origin !== this) {
        const encoder2 = createEncoder2();
        writeVarUint2(encoder2, messageSync);
        writeUpdate(encoder2, update2);
        broadcastMessage(this, toUint8Array2(encoder2));
      }
    };
    this.doc.on("update", this._updateHandler);
    this._awarenessUpdateHandler = ({ added, updated, removed }, _origin) => {
      const changedClients = added.concat(updated).concat(removed);
      const encoder2 = createEncoder2();
      writeVarUint2(encoder2, messageAwareness);
      writeVarUint8Array2(
        encoder2,
        encodeAwarenessUpdate(awareness, changedClients)
      );
      broadcastMessage(this, toUint8Array2(encoder2));
    };
    this._unloadHandler = () => {
      removeAwarenessStates(this.awareness, [doc2.clientID], "window unload");
    };
    if (typeof window !== "undefined") {
      window.addEventListener("unload", this._unloadHandler);
    } else if (typeof process !== "undefined") {
      process.on("exit", this._unloadHandler);
    }
    awareness.on("update", this._awarenessUpdateHandler);
    this._checkInterval = setInterval(() => {
      var _a2;
      if (this.wsconnected && messageReconnectTimeout < getUnixTime2() - this.wsLastMessageReceived) {
        (_a2 = this.ws) == null ? void 0 : _a2.close();
      }
    }, messageReconnectTimeout / 10);
    if (connect) {
      this.connect();
    }
  }
  /**
   * @type {boolean}
   */
  get synced() {
    return this._synced;
  }
  set synced(state) {
    if (this._synced !== state) {
      this._synced = state;
      this.emit("synced", [state]);
      this.emit("sync", [state]);
    }
  }
  destroy() {
    if (this._resyncInterval !== 0) {
      clearInterval(this._resyncInterval);
    }
    clearInterval(this._checkInterval);
    this.disconnect();
    if (typeof window !== "undefined") {
      window.removeEventListener("unload", this._unloadHandler);
    } else if (typeof process !== "undefined") {
      process.off("exit", this._unloadHandler);
    }
    this.awareness.off("update", this._awarenessUpdateHandler);
    this.doc.off("update", this._updateHandler);
    super.destroy();
  }
  connectBc() {
    if (this.disableBc) {
      return;
    }
    if (!this.bcconnected) {
      subscribe(this.bcChannel, this._bcSubscriber);
      this.bcconnected = true;
    }
    const encoderSync = createEncoder2();
    writeVarUint2(encoderSync, messageSync);
    writeSyncStep1(encoderSync, this.doc);
    publish(this.bcChannel, toUint8Array2(encoderSync), this);
    const encoderState = createEncoder2();
    writeVarUint2(encoderState, messageSync);
    writeSyncStep2(encoderState, this.doc);
    publish(this.bcChannel, toUint8Array2(encoderState), this);
    const encoderAwarenessQuery = createEncoder2();
    writeVarUint2(encoderAwarenessQuery, messageQueryAwareness);
    publish(this.bcChannel, toUint8Array2(encoderAwarenessQuery), this);
    const encoderAwarenessState = createEncoder2();
    writeVarUint2(encoderAwarenessState, messageAwareness);
    writeVarUint8Array2(
      encoderAwarenessState,
      encodeAwarenessUpdate(this.awareness, [this.doc.clientID])
    );
    publish(this.bcChannel, toUint8Array2(encoderAwarenessState), this);
  }
  disconnectBc() {
    const encoder2 = createEncoder2();
    writeVarUint2(encoder2, messageAwareness);
    writeVarUint8Array2(
      encoder2,
      encodeAwarenessUpdate(this.awareness, [this.doc.clientID], /* @__PURE__ */ new Map())
    );
    broadcastMessage(this, toUint8Array2(encoder2));
    if (this.bcconnected) {
      unsubscribe(this.bcChannel, this._bcSubscriber);
      this.bcconnected = false;
    }
  }
  disconnect() {
    this.shouldConnect = false;
    this.disconnectBc();
    if (this.ws !== null) {
      this.ws.close();
    }
  }
  connect() {
    this.shouldConnect = true;
    if (!this.wsconnected && this.ws === null) {
      setupWS(this);
      this.connectBc();
    }
  }
};

// src/debug.ts
var import_obsidian = require("obsidian");
var debugging = false;
function setDebugging(debug2) {
  debugging = debug2;
}
function toastDebug(error) {
  new import_obsidian.Notice(error.name + "\n" + error.message);
  return error;
}
function toastProd(error) {
  new import_obsidian.Notice(
    error.name + ":\nAn error has occurred, please reload Obsidian."
  );
  return error;
}
function curryLog(initialText, level = "log") {
  if (debugging) {
    return (...args3) => console[level](initialText, ": ", ...args3);
  }
  return (...args3) => {
  };
}
var debug = false;
var toast = debug ? toastDebug : toastProd;

// src/promiseUtils.ts
function promiseWithTimeout(promise, ms) {
  let timeoutId;
  const timeout = new Promise((_, reject) => {
    timeoutId = window.setTimeout(() => {
      try {
        throw new Error("Timeout");
      } catch (error) {
        curryLog("[Promise]", "error")("Timeout on promise", promise);
      }
      reject("Timeout after " + ms + " ms");
    }, ms);
  });
  return Promise.race([promise, timeout]).finally(() => {
    clearTimeout(timeoutId);
  });
}
var SharedPromise = class {
  constructor(promiseFunction, checkFunction) {
    this.currentPromise = null;
    this.promiseFunction = promiseFunction;
    this.checkFunction = checkFunction;
  }
  getPromise() {
    const [success, result] = this.checkFunction();
    if (success) {
      return Promise.resolve(result);
    }
    if (!this.currentPromise) {
      this.currentPromise = this.promiseFunction().then(
        (result2) => {
          this.currentPromise = null;
          return result2;
        },
        (error) => {
          this.currentPromise = null;
          throw error;
        }
      );
    }
    return this.currentPromise;
  }
};

// src/S3RN.ts
var S3RelayProduct = class {
  constructor() {
    this.platform = "s3rn";
    this.product = "relay";
  }
};
var S3Relay = class {
  constructor(relayId) {
    this.relayId = relayId;
    this.platform = "s3rn";
    this.product = "relay";
  }
};
var S3RemoteFolder = class {
  constructor(relayId, folderId) {
    this.relayId = relayId;
    this.folderId = folderId;
    this.platform = "s3rn";
    this.product = "relay";
  }
};
var S3RemoteDocument = class {
  constructor(relayId, folderId, documentId) {
    this.relayId = relayId;
    this.folderId = folderId;
    this.documentId = documentId;
    this.platform = "s3rn";
    this.product = "relay";
  }
};
var S3Folder = class {
  constructor(folderId) {
    this.folderId = folderId;
    this.platform = "s3rn";
    this.product = "relay";
  }
};
var S3Document = class {
  constructor(folderId, documentId) {
    this.folderId = folderId;
    this.documentId = documentId;
    this.platform = "s3rn";
    this.product = "relay";
  }
};
var S3RN = class {
  static validateUUID(uuid) {
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    return uuidRegex.test(uuid);
  }
  static encode(entity) {
    let s3rn = `${entity.platform}:${entity.product}`;
    if ("relayId" in entity) {
      if (!this.validateUUID(entity.relayId)) {
        throw new Error("Invalid relay UUID");
      }
      s3rn += `:relay:${entity.relayId}`;
    }
    if ("folderId" in entity) {
      if (!this.validateUUID(entity.folderId)) {
        throw new Error("Invalid folder UUID");
      }
      s3rn += `:folder:${entity.folderId}`;
    }
    if ("documentId" in entity) {
      if (!this.validateUUID(entity.documentId)) {
        throw new Error("Invalid document UUID");
      }
      s3rn += `:doc:${entity.documentId}`;
    }
    return s3rn;
  }
  static decode(s3rn) {
    const parts = s3rn.split(":");
    if (parts.length < 3) {
      throw new Error("Invalid s3rn format");
    }
    const [, product, type0, item0, type1, item1, type2, item2] = parts;
    if (!this.validateUUID(item0)) {
      throw new Error("Invalid UUID");
    }
    if (item1 && !this.validateUUID(item1)) {
      throw new Error("Invalid UUID");
    }
    if (item2 && !this.validateUUID(item2)) {
      throw new Error("Invalid UUID");
    }
    if (product === "relay" && type0 === "relay" && type1 === "folder" && type2 === "doc") {
      return new S3RemoteDocument(item0, item1, item2);
    } else if (product === "relay" && type0 === "relay" && type1 == "folder") {
      return new S3RemoteFolder(item0, item1);
    } else if (product === "relay" && type0 === "folder" && type1 === "document") {
      return new S3Document(item0, item1);
    } else if (product === "relay" && type0 === "folder") {
      return new S3Folder(item0);
    } else if (product === "relay" && type0 === "relay") {
      return new S3Relay(item0);
    } else if (type0 === void 0) {
      return new S3RelayProduct();
    }
    throw new Error("Invalid s3rn format for the given product type");
  }
};

// src/HasProvider.ts
var import_obsidian2 = require("obsidian");
var readyStateMap = {
  3: "disconnected",
  2: "disconnected",
  1: "connected",
  0: "connecting"
};
function makeProvider(clientToken, ydoc, user) {
  const params3 = {
    token: clientToken.token
  };
  const provider = new YSweetProvider(
    clientToken.url,
    clientToken.docId,
    ydoc,
    {
      connect: false,
      params: params3,
      disableBc: true
    }
  );
  if (user) {
    provider.awareness.setLocalStateField("user", {
      name: user.name,
      color: user.color.color,
      colorLight: user.color.light
    });
  }
  return provider;
}
var HasProvider = class {
  constructor(s3rn, tokenStore, loginManager) {
    this.PROVIDER_MAX_ERRORS = 3;
    this.debug = curryLog("[HasProvider]", "debug");
    this.log = curryLog("[HasProvider]", "log");
    this.warn = curryLog("[HasProvider]", "warn");
    this.error = curryLog("[HasProvider]", "error");
    var _a2;
    this._s3rn = s3rn;
    this.listeners = /* @__PURE__ */ new Map();
    this.loginManager = loginManager;
    this.ydoc = new Doc();
    this.tokenStore = tokenStore;
    this.clientToken = this.tokenStore.getTokenSync(S3RN.encode(this.s3rn)) || { token: "", url: "", docId: "-", expiryTime: 0 };
    const user = (_a2 = this.loginManager) == null ? void 0 : _a2.user;
    this._provider = makeProvider(this.clientToken, this.ydoc, user);
    const connectionErrorSub = this.providerConnectionErrorSubscription(
      (event) => {
        this.log(`[${this.path}] disconnection event`, event);
        const shouldConnect = this._provider.url && this._provider.shouldConnect && this._provider.wsUnsuccessfulReconnects < this.PROVIDER_MAX_ERRORS;
        this.disconnect();
        if (shouldConnect) {
          this.connect();
        }
      }
    );
    connectionErrorSub.on();
    this._offConnectionError = connectionErrorSub.off;
    const stateSub = this.providerStateSubscription(
      (state) => {
        this.notifyListeners();
      }
    );
    stateSub.on();
    this._offState = stateSub.off;
  }
  get s3rn() {
    return this._s3rn;
  }
  set s3rn(value) {
    this._s3rn = value;
    this.refreshProvider(this.clientToken);
  }
  notifyListeners() {
    this.debug("[Provider State]", this.path, this.state);
    this.listeners.forEach((listener) => {
      listener(this.state);
    });
  }
  subscribe(el, listener) {
    this.listeners.set(el, listener);
    return () => {
      this.unsubscribe(el);
    };
  }
  unsubscribe(el) {
    this.listeners.delete(el);
  }
  async getProviderToken() {
    this.log("get provider token");
    const tokenPromise = this.tokenStore.getToken(
      S3RN.encode(this.s3rn),
      this.path || "unknown",
      this.refreshProvider.bind(this)
    );
    if (import_obsidian2.Platform.isIosApp) {
      return tokenPromise;
    }
    const timeoutPromise = promiseWithTimeout(
      tokenPromise,
      1e4
    );
    return timeoutPromise;
  }
  providerActive() {
    var _a2;
    if (this.clientToken) {
      const tokenIsSet = this._provider.url == this.clientToken.url;
      const expired = Date.now() > (((_a2 = this.clientToken) == null ? void 0 : _a2.expiryTime) || 0);
      return tokenIsSet && !expired;
    }
    return false;
  }
  refreshProvider(clientToken) {
    var _a2;
    this.clientToken = clientToken;
    const tempProvider = makeProvider(clientToken, new Doc());
    const newUrl = tempProvider.url;
    if (!this._provider) {
      throw new Error("missing provider!");
    } else if (this._provider.url !== newUrl) {
      this._provider.url = newUrl;
      this._provider.wsUnsuccessfulReconnects = 0;
      this.log(
        `Token Refreshed: setting new provider url, ${this._provider.url}`
      );
      (_a2 = this._provider.ws) == null ? void 0 : _a2.close();
    }
  }
  get connected() {
    return this.state.status === "connected";
  }
  connect() {
    if (this.connected) {
      return Promise.resolve(true);
    }
    return this.getProviderToken().then((clientToken) => {
      this.refreshProvider(clientToken);
      this._provider.connect();
      this.notifyListeners();
      return true;
    }).catch((e2) => {
      return false;
    });
  }
  get state() {
    var _a2;
    return {
      status: readyStateMap[((_a2 = this._provider.ws) == null ? void 0 : _a2.readyState) || 3 /* CLOSED */],
      intent: this._provider.shouldConnect ? "connected" : "disconnected"
    };
  }
  get synced() {
    return this._provider.synced;
  }
  disconnect() {
    var _a2;
    this._provider.shouldConnect = false;
    (_a2 = this._provider.ws) == null ? void 0 : _a2.close();
    this._provider.ws = null;
    this.notifyListeners();
  }
  withActiveProvider() {
    if (this.providerActive()) {
      return new Promise((resolve) => {
        resolve(this);
      });
    }
    return this.getProviderToken().then((clientToken) => {
      return this;
    });
  }
  onceConnected() {
    return new Promise((resolve) => {
      const resolveOnConnect = (state) => {
        if (state.status === "connected") {
          resolve();
        }
      };
      this._provider.on("status", resolveOnConnect);
    });
  }
  onceProviderSynced() {
    var _a2;
    if ((_a2 = this._provider) == null ? void 0 : _a2.synced) {
      return new Promise((resolve) => {
        resolve();
      });
    }
    return new Promise((resolve) => {
      this._provider.once("synced", resolve);
    });
  }
  _injectIntent(f) {
    const inner = (state) => {
      const intent = this._provider.shouldConnect ? "connected" : "disconnected";
      f({ status: state.status, intent });
    };
    return inner;
  }
  providerConnectionErrorSubscription(f) {
    const on = () => {
      this._provider.on("connection-error", f);
    };
    const off = () => {
      this._provider.off("connection-error", f);
    };
    return { on, off };
  }
  providerStateSubscription(f) {
    const on = () => {
      this._provider.on("status", this._injectIntent(f));
    };
    const off = () => {
      this._provider.off("status", this._injectIntent(f));
    };
    return { on, off };
  }
  destroy() {
    if (this._offConnectionError) {
      this._offConnectionError();
    }
    if (this._offState) {
      this._offState();
    }
    if (this._provider) {
      this._provider.disconnect();
      this._provider.destroy();
    }
    this.listeners.clear();
  }
};

// src/Document.ts
var Document = class extends HasProvider {
  constructor(path2, guid, loginManager, parent) {
    const s3rn = parent.relayId ? new S3RemoteDocument(parent.relayId, parent.guid, guid) : new S3Document(parent.guid, guid);
    super(s3rn, parent.tokenStore, loginManager);
    this.guid = guid;
    this._parent = parent;
    this.path = path2;
    this.setLoggers(`[SharedDoc](${this.path})`);
    this._persistence = new IndexeddbPersistence(this.guid, this.ydoc);
    this.ydoc.on(
      "update",
      (update2, origin, doc2) => {
      }
    );
  }
  setLoggers(context) {
    this.debug = curryLog(context, "debug");
    this.log = curryLog(context, "log");
    this.warn = curryLog(context, "warn");
    this.error = curryLog(context, "error");
  }
  move(newPath) {
    this.path = newPath;
    this.setLoggers(`[SharedDoc](${this.path})`);
  }
  get sharedFolder() {
    return this._parent;
  }
  get ytext() {
    return this.ydoc.getText("contents");
  }
  get text() {
    return this.ytext.toString();
  }
  connect() {
    if (this.sharedFolder.s3rn instanceof S3Folder) {
      return Promise.resolve(false);
    } else if (this.s3rn instanceof S3Document) {
      if (this.sharedFolder.relayId) {
        this.s3rn = new S3RemoteDocument(
          this.sharedFolder.relayId,
          this.sharedFolder.guid,
          this.guid
        );
      } else {
        this.s3rn = new S3Document(this.sharedFolder.guid, this.guid);
      }
    }
    return this.sharedFolder.connect().then((connected) => {
      return super.connect();
    });
  }
  async whenReady() {
    const dependencies = [];
    if (!this._persistence.synced) {
      dependencies.push(this.whenSynced());
    }
    if (!this._provider) {
      dependencies.push(this.withActiveProvider());
    }
    return Promise.all(dependencies).then((_) => {
      return this;
    });
  }
  whenSynced() {
    if (this._persistence.synced) {
      return Promise.resolve();
    }
    return new Promise((resolve) => {
      this._persistence.once("synced", resolve);
    });
  }
  hasKnownPeers() {
    if (this._hasKnownPeers !== void 0) {
      return Promise.resolve(this._hasKnownPeers);
    }
    return this.whenSynced().then(async () => {
      await fetchUpdates(this._persistence);
      this._hasKnownPeers = this._persistence._dbsize > 3;
      this.log("update count", this.path, this._persistence._dbsize);
      return this._hasKnownPeers;
    });
  }
  destroy() {
    if (this._persistence) {
      this._persistence.destroy();
    }
    super.destroy();
  }
};

// src/observable/Postie.ts
var PostOffice = class {
  constructor(deliveryWindow = 20) {
    this.deliveryWindow = deliveryWindow;
    this.mailboxes = /* @__PURE__ */ new Map();
    this.allMailLog = [];
    this.deliveredMailLog = [];
    this.isDelivering = false;
    this.deliveryInterval = null;
    this.currentTransactionId = 0;
    this.isInTransaction = false;
  }
  static getInstance() {
    if (!PostOffice.instance) {
      PostOffice.instance = new PostOffice();
      const log = curryLog("[postie]", "warn");
      log("instance", this.instance);
    }
    return PostOffice.instance;
  }
  beginTransaction() {
    this.isInTransaction = true;
    this.currentTransactionId++;
  }
  commitTransaction() {
    this.isInTransaction = false;
    if (!this.isDelivering) {
      this.scheduleDelivery();
    }
  }
  send(sender, recipient, immediate = false) {
    const mail = {
      sender,
      recipient,
      transactionId: this.currentTransactionId,
      timestamp: Date.now(),
      recipientOrigin: this.getFunctionOrigin(recipient)
    };
    this.allMailLog.push(mail);
    if (!this.mailboxes.has(recipient)) {
      this.mailboxes.set(recipient, /* @__PURE__ */ new Set());
    }
    this.mailboxes.get(recipient).add(sender);
    if (immediate) {
      this.deliverImmediate(sender, recipient);
    } else if (!this.isInTransaction && !this.isDelivering) {
      this.scheduleDelivery();
    }
  }
  deliverImmediate(sender, recipient) {
    recipient(sender);
    this.deliveredMailLog.push({
      sender,
      recipient,
      transactionId: this.currentTransactionId,
      timestamp: Date.now(),
      recipientOrigin: this.getFunctionOrigin(recipient)
    });
  }
  scheduleDelivery() {
    this.isDelivering = true;
    this.deliveryInterval = window.setTimeout(() => {
      this.deliver();
      this.deliveryInterval = null;
      this.isDelivering = false;
      if (this.mailboxes.size > 0 && !this.isInTransaction) {
        this.scheduleDelivery();
      }
    }, this.deliveryWindow);
  }
  deliver() {
    const log = curryLog("[postie]", "debug");
    for (const [recipient, senders] of this.mailboxes) {
      for (const sender of senders) {
        recipient(sender);
        log("send", sender, recipient);
        this.deliveredMailLog.push({
          sender,
          recipient,
          transactionId: this.currentTransactionId,
          timestamp: Date.now(),
          recipientOrigin: this.getFunctionOrigin(recipient)
        });
      }
      senders.clear();
    }
  }
  getAllMailLog() {
    return [...this.allMailLog];
  }
  getDeliveredMailLog() {
    return [...this.deliveredMailLog];
  }
  prettyPrintAllMailLog() {
    const log = curryLog("[postie]", "warn");
    log("All Mail Log:");
    this.prettyPrintMailLog(this.allMailLog);
  }
  prettyPrintDeliveredMailLog() {
    const log = curryLog("[postie]", "warn");
    log("Delivered Mail Log:");
    this.prettyPrintMailLog(this.deliveredMailLog);
  }
  prettyPrintMailLog(log) {
    const _log = curryLog("[postie]", "warn");
    log.forEach((mail, index) => {
      _log(`Mail #${index + 1}:`);
      _log(`  Timestamp: ${new Date(mail.timestamp).toISOString()}`);
      _log(`  Transaction ID: ${mail.transactionId}`);
      _log(
        `  Sender: ${mail.sender.observableName || mail.sender.constructor.name}`
      );
      _log(`  Recipient: ${mail.recipient.name || "Anonymous function"}`);
      _log(`  Recipient Origin: ${mail.recipientOrigin || "Unknown"}`);
      _log("---");
    });
  }
  getFunctionOrigin(func) {
    if (func.name) {
      return func.name;
    }
    const funcString = func.toString();
    const funcMatch = funcString.match(/^(function|class)?\s*([^\s(]*)/);
    if (funcMatch && funcMatch[2]) {
      return funcMatch[2];
    }
    const maxLength = 200;
    let definition = funcString.replace(/\s+/g, " ").slice(0, maxLength);
    if (definition.length === maxLength) {
      definition += "...";
    }
    return `AnonymousFunction(${definition})`;
  }
};

// src/observable/Observable.ts
var observables = /* @__PURE__ */ new Map();
function auditTeardown() {
  for (const [, auditTeardown2] of observables) {
    auditTeardown2();
  }
  observables.clear();
}
var Observable3 = class {
  constructor(observableName) {
    this.observableName = observableName;
    const warn2 = curryLog("[Observable]", "warn");
    observables.set(this, () => {
      if (this._listeners.size > 0) {
        warn2(
          `Missing tear down of ${this._listeners.size} listeners`,
          this,
          this._listeners
        );
      }
    });
    this._listeners = /* @__PURE__ */ new Set();
  }
  notifyListeners() {
    for (const recipient of this._listeners) {
      PostOffice.getInstance().send(
        this,
        recipient
      );
    }
  }
  on(listener) {
    this._listeners.add(listener);
    return () => {
      this.off(listener);
    };
  }
  subscribe(run2) {
    this._listeners.add(run2);
    PostOffice.getInstance().send(
      this,
      run2,
      true
    );
    return () => {
      this.unsubscribe(run2);
    };
  }
  off(listener) {
    this._listeners.delete(listener);
  }
  unsubscribe(run2) {
    this._listeners.delete(run2);
  }
};

// src/observable/ObservableSet.ts
var ObservableSet = class extends Observable3 {
  constructor() {
    super();
    this._set = /* @__PURE__ */ new Set();
  }
  add(item) {
    this._set.add(item);
    this.notifyListeners();
    return this;
  }
  delete(item) {
    const result = this._set.delete(item);
    if (result) {
      this.notifyListeners();
    }
    return result;
  }
  clear() {
    this._set.clear();
    this.notifyListeners();
  }
  has(item) {
    return this._set.has(item);
  }
  items() {
    return [...this._set];
  }
  get size() {
    return this._set.size;
  }
  map(callbackfn) {
    return this.items().map(callbackfn);
  }
  forEach(callbackfn) {
    this.items().forEach(callbackfn);
  }
  find(predicate) {
    return this.items().find(predicate);
  }
  some(predicate) {
    for (const item of this._set) {
      if (predicate(item)) {
        return true;
      }
    }
    return false;
  }
  filter(predicate) {
    const filtered = [];
    for (const value of this._set) {
      if (predicate(value)) {
        filtered.push(value);
      }
    }
    return filtered;
  }
};

// src/SharedFolder.ts
var import_obsidian4 = require("obsidian");
var Documents = class extends ObservableSet {
  constructor() {
    super(...arguments);
    // Startup performance optimization
    this.notifyListeners = (0, import_obsidian3.debounce)(super.notifyListeners, 100);
  }
  update() {
    this.notifyListeners();
    return;
  }
  add(item, update2 = true) {
    this._set.add(item);
    if (update2) {
      this.notifyListeners();
    }
    return this;
  }
};
var SharedFolder = class extends HasProvider {
  constructor(guid, path2, loginManager, vault, fileManager, tokenStore, relayManager, relayId, awaitingUpdates = true) {
    const s3rn = relayId ? new S3RemoteFolder(relayId, guid) : new S3Folder(guid);
    super(s3rn, tokenStore, loginManager);
    this.readyPromise = null;
    this.unsubscribes = [];
    this.addLocalDocs = () => {
      const files = this.vault.getFiles();
      const docs = [];
      const vpaths = [];
      files.forEach((file) => {
        if (!this.checkPath(file.path)) {
          return;
        }
        if (file instanceof import_obsidian3.TFolder) {
          return;
        }
        if (!this.ids.has(file.path)) {
          vpaths.push(this.getVirtualPath(file.path));
        }
      });
      this.placeHold(vpaths);
      files.forEach((file) => {
        if (!this.checkPath(file.path)) {
          return;
        }
        if (file instanceof import_obsidian3.TFolder) {
          return;
        }
        const loadFromDisk = !this.ids.has(file.path);
        const doc2 = this.createFile(file.path, loadFromDisk, false);
        docs.push(doc2);
      });
      if (docs.length > 0) {
        this.docset.update();
      }
    };
    this.log = curryLog("[SharedFolder]", "log");
    this.warn = curryLog("[SharedFolder]", "warn");
    this.debug = curryLog("[SharedFolder]", "debug");
    this.error = curryLog("[SharedFolder]", "error");
    this.guid = guid;
    this.fileManager = fileManager;
    this.vault = vault;
    this.path = path2;
    this.ids = this.ydoc.getMap("docs");
    this.docs = /* @__PURE__ */ new Map();
    this.docset = new Documents();
    this.relayManager = relayManager;
    this._awaitingUpdates = awaitingUpdates;
    this.relayId = relayId;
    this.unsubscribes.push(
      this.relayManager.remoteFolders.subscribe((folders) => {
        this.remote = folders.find(
          (folder) => folder.guid == this.guid
        );
      })
    );
    this._persistence = new IndexeddbPersistence(this.guid, this.ydoc);
    this._persistence.once("synced", () => {
      this.log("", this.ids);
    });
    if (loginManager.loggedIn) {
      this.connect();
    }
    this.whenReady().then(() => {
      this.addLocalDocs();
    });
    this.ydoc.on(
      "update",
      async (update2, origin, doc2) => {
        if (origin == this) {
          return;
        }
        this.log("file tree", this._debugFileTree());
        await this.syncFileTree(doc2);
      }
    );
  }
  connect() {
    if (this.s3rn instanceof S3RemoteFolder) {
      return super.connect();
    }
    return Promise.resolve(false);
  }
  get name() {
    return this.path.split("/").pop() || "";
  }
  get location() {
    return this.path.split("/").slice(0, -1).join("/");
  }
  get settings() {
    return {
      guid: this.guid,
      path: this.path,
      relay: this.relayId
    };
  }
  get remote() {
    var _a2;
    try {
      (_a2 = this._remote) == null ? void 0 : _a2.relay;
    } catch (e2) {
      return void 0;
    }
    return this._remote;
  }
  set remote(value) {
    var _a2;
    if (this._remote === value) {
      return;
    }
    this._remote = value;
    this.relayId = (_a2 = value == null ? void 0 : value.relay) == null ? void 0 : _a2.guid;
    this.s3rn = this.relayId ? new S3RemoteFolder(this.relayId, this.guid) : new S3Folder(this.guid);
    this.notifyListeners();
  }
  get ready() {
    const persistenceSynced = this._persistence.synced;
    const serverSynced = this.synced && this.connected;
    return persistenceSynced && (!this._awaitingUpdates || serverSynced);
  }
  async awaitingUpdates() {
    await this.whenSynced();
    if (this._awaitingUpdates) {
      await fetchUpdates(this._persistence);
      this.log("update count", this.path, this._persistence._dbsize);
      this._awaitingUpdates = this._persistence._dbsize < 3;
    }
    return this._awaitingUpdates;
  }
  async whenReady() {
    const promiseFn = async () => {
      const awaitingUpdates = await this.awaitingUpdates();
      if (awaitingUpdates) {
        await this.onceConnected();
        await this.onceProviderSynced();
        return this;
      }
      return this;
    };
    this.readyPromise = this.readyPromise || new SharedPromise(
      promiseFn,
      () => {
        return [this.ready, this];
      }
    );
    return this.readyPromise.getPromise();
  }
  _debugFileTree() {
    const ids = /* @__PURE__ */ new Map();
    this.ydoc.getMap("docs")._map.forEach((item, path2) => {
      if (item.content instanceof ContentAny) {
        ids.set(path2, item.content.arr[0]);
      } else {
        ids.set(path2, item.content);
      }
    });
    return ids;
  }
  whenSynced() {
    if (this._persistence.synced) {
      return new Promise((resolve) => {
        resolve();
      });
    }
    return new Promise((resolve) => {
      this._persistence.once("synced", resolve);
    });
  }
  async _handleServerRename(doc2, path2, file, diffLog) {
    diffLog == null ? void 0 : diffLog.push(`${file.path} was renamed to ${path2}`);
    const dir = (0, import_path_browserify.dirname)(path2);
    if (!this.existsSync(dir)) {
      await this.mkdir(dir);
      diffLog == null ? void 0 : diffLog.push(`creating directory ${dir}`);
    }
    this.fileManager.renameFile(file, (0, import_obsidian3.normalizePath)(this.getPath(path2))).then(() => {
      doc2.move(path2);
    });
  }
  async _handleServerCreate(path2, diffLog) {
    const doc2 = this.createDoc(path2, false, false);
    let folderPromise = Promise.resolve();
    const dir = (0, import_path_browserify.dirname)(path2);
    if (!this.existsSync(dir)) {
      folderPromise = this.mkdir(dir);
      diffLog == null ? void 0 : diffLog.push(`creating directory ${dir}`);
    }
    const start = import_obsidian4.moment.now();
    await doc2.whenReady();
    const end = import_obsidian4.moment.now();
    this.debug(
      `receive delay: received content for ${doc2.path} after ${end - start}ms`,
      doc2.text.toString()
    );
    await folderPromise;
    this.flush(doc2, doc2.text.toString());
    diffLog == null ? void 0 : diffLog.push(`created local file for remotely added doc ${path2}`);
    return doc2;
  }
  _assertNamespacing(path2) {
    try {
      this.assertPath(this.path + path2);
    } catch (e2) {
      this.error(
        "Deleting doc (somehow moved outside of shared folder)",
        path2
      );
      this.ids.delete(path2);
      return;
    }
  }
  applyRemoteState(guid, path2, remoteIds, diffLog) {
    const doc2 = this.docs.get(guid);
    if (this.existsSync(path2)) {
      return { op: "noop", path: path2, promise: Promise.resolve() };
    }
    if (remoteIds.has(guid) && doc2) {
      const oldPath = this.getPath(doc2.path);
      const file = this.vault.getAbstractFileByPath(oldPath);
      if (file) {
        const promise2 = this._handleServerRename(
          doc2,
          path2,
          file,
          diffLog
        );
        return {
          op: "rename",
          path: path2,
          from: oldPath,
          to: path2,
          promise: promise2
        };
      }
    }
    const promise = this._handleServerCreate(path2, diffLog);
    return { op: "create", path: path2, promise };
  }
  cleanupExtraLocalFiles(remotePaths, diffLog) {
    const files = this.vault.getFiles();
    const deletes = [];
    files.forEach((file) => {
      var _a2, _b2;
      const fileInFolder = this.checkPath(file.path);
      const fileInMap = remotePaths.contains(
        file.path.slice(this.path.length)
      );
      const synced = ((_a2 = this._provider) == null ? void 0 : _a2.synced) && ((_b2 = this._persistence) == null ? void 0 : _b2.synced);
      if (fileInFolder && !fileInMap) {
        if (synced) {
          diffLog.push(
            `deleted local file ${file.path} for remotely deleted doc`
          );
          const promise = this.vault.adapter.trashLocal(file.path);
          deletes.push({ op: "delete", path: file.path, promise });
        }
      }
    });
    return deletes;
  }
  async syncFileTree(doc2) {
    const ops = [];
    const map3 = doc2.getMap("docs");
    const diffLog = [];
    this.ydoc.transact(() => {
      map3.forEach((_, path2) => {
        this._assertNamespacing(path2);
      });
      const remoteIds = new Set(this.ids.values());
      map3.forEach((guid, path2) => {
        this._assertNamespacing(path2);
        ops.push(this.applyRemoteState(guid, path2, remoteIds, diffLog));
      });
    });
    const creates = ops.filter((op) => op.op === "create");
    const renames = ops.filter((op) => op.op === "rename");
    const remotePaths = ops.map((op) => op.path);
    await Promise.all([...creates, ...renames].map((op) => op.promise));
    const deletes = this.cleanupExtraLocalFiles(remotePaths, diffLog);
    if ([...renames, ...creates, ...deletes].length > 0) {
      this.docset.update();
    }
    this.log("syncFileTree diff:\n" + diffLog.join("\n"));
  }
  read(doc2) {
    const vaultPath = (0, import_path_browserify.join)(this.path, doc2.path);
    return this.vault.adapter.read((0, import_obsidian3.normalizePath)(vaultPath));
  }
  existsSync(path2) {
    const vaultPath = (0, import_obsidian3.normalizePath)((0, import_path_browserify.join)(this.path, path2));
    const pathExists = this.vault.getAbstractFileByPath(vaultPath) !== null;
    return pathExists;
  }
  exists(doc2) {
    const vaultPath = (0, import_path_browserify.join)(this.path, doc2.path);
    return this.vault.adapter.exists((0, import_obsidian3.normalizePath)(vaultPath));
  }
  flush(doc2, content) {
    const vaultPath = (0, import_path_browserify.join)(this.path, doc2.path);
    return this.vault.adapter.write((0, import_obsidian3.normalizePath)(vaultPath), content);
  }
  getPath(path2) {
    return (0, import_path_browserify.join)(this.path, path2);
  }
  assertPath(path2) {
    if (!this.checkPath(path2)) {
      throw new Error("Path is not in shared folder: " + path2);
    }
  }
  mkdir(path2) {
    const vaultPath = (0, import_path_browserify.join)(this.path, path2);
    return this.vault.adapter.mkdir((0, import_obsidian3.normalizePath)(vaultPath));
  }
  checkPath(path2) {
    return path2.startsWith(this.path + import_path_browserify.sep);
  }
  getVirtualPath(path2) {
    this.assertPath(path2);
    const vPath = path2.slice(this.path.length);
    return vPath;
  }
  getFile(path2, create8 = true, loadFromDisk = false, update2 = true) {
    const vPath = this.getVirtualPath(path2);
    try {
      return this.getDoc(vPath, create8, loadFromDisk, update2);
    } catch (e2) {
      this.warn(e2, path2);
      throw e2;
    }
  }
  getDoc(vPath, create8 = true, loadFromDisk = false, update2 = true) {
    const id2 = this.ids.get(vPath);
    if (id2 !== void 0) {
      const doc2 = this.docs.get(id2);
      if (doc2 !== void 0) {
        doc2.move(vPath);
        return doc2;
      } else {
        this.log("[getDoc]: creating doc for shared ID");
        return this.createDoc(vPath, false, update2);
      }
    } else if (create8) {
      this.log("[getDoc]: creating new shared ID for existing file");
      return this.createDoc(vPath, loadFromDisk, update2);
    } else {
      throw new Error("No shared doc for vpath: " + vPath);
    }
  }
  createFile(path2, loadFromDisk = false, update2 = true) {
    const vPath = this.getVirtualPath(path2);
    return this.createDoc(vPath, loadFromDisk, update2);
  }
  placeHold(vpaths) {
    this.ydoc.transact(() => {
      vpaths.forEach((vpath) => {
        if (!this.ids.has(vpath)) {
          this.debug("creating entirely new doc for", vpath);
          const guid = v4_default();
          this.ids.set(vpath, guid);
        }
      });
    }, this);
  }
  createDoc(vpath, loadFromDisk = false, update2 = true) {
    if (!this.synced && !this.ids.get(vpath)) {
      this.warn(`potential for document split at ${vpath}`);
    }
    const maybeGuid = this.ids.get(vpath);
    let guid;
    if (maybeGuid === void 0) {
      if (!loadFromDisk) {
        throw new Error(
          "attempting to create a new doc without a local file"
        );
      }
      guid = v4_default();
      this.ydoc.transact(() => {
        this.ids.set(vpath, guid);
      }, this);
    } else {
      guid = maybeGuid;
    }
    const doc2 = this.docs.get(guid) || new Document(vpath, guid, this.loginManager, this);
    const knownPeersPromise = doc2.hasKnownPeers();
    const awaitingUpdatesPromise = this.awaitingUpdates();
    if (loadFromDisk) {
      (async () => {
        const exists = await this.exists(doc2);
        if (!exists) {
          return;
        }
        const [contents, hasKnownPeers, awaitingUpdates] = await Promise.all([
          this.read(doc2),
          knownPeersPromise,
          awaitingUpdatesPromise
        ]);
        const text3 = doc2.ydoc.getText("contents");
        if (!awaitingUpdates && !hasKnownPeers && contents && text3.toString() != contents) {
          this.log(
            `[${doc2.path}] No Known Peers: Syncing file into ytext.`
          );
          text3.insert(0, contents);
        }
      })();
    }
    this.docs.set(guid, doc2);
    this.docset.add(doc2, update2);
    return doc2;
  }
  deleteFile(path2) {
    const vPath = this.getVirtualPath(path2);
    return this.deleteDoc(vPath);
  }
  deleteDoc(vPath) {
    const guid = this.ids.get(vPath);
    if (guid) {
      this.ydoc.transact(() => {
        var _a2;
        this.ids.delete(vPath);
        const doc2 = (_a2 = this.docs.get(guid)) == null ? void 0 : _a2.destroy();
        if (doc2) {
          this.docset.delete(doc2);
        }
        this.docs.delete(guid);
      }, this);
    }
  }
  renameFile(newPath, oldPath) {
    let newVPath = "";
    let oldVPath = "";
    try {
      newVPath = this.getVirtualPath(newPath);
    } catch (e2) {
      this.log("Moving out of shared folder");
    }
    try {
      oldVPath = this.getVirtualPath(oldPath);
    } catch (e2) {
      this.log("Moving in from outside of shared folder");
    }
    if (!newVPath && !oldVPath) {
      return;
    } else if (!oldVPath) {
      this.assertPath(newPath);
      this.createDoc(newVPath, true, true);
    } else {
      const guid = this.ids.get(oldVPath);
      if (!guid)
        return;
      const doc2 = this.docs.get(guid);
      if (!newVPath) {
        this.ydoc.transact(() => {
          this.ids.delete(oldVPath);
        }, this);
        if (doc2) {
          doc2.destroy();
          this.docset.delete(doc2);
        }
        this.docs.delete(guid);
      } else {
        const guid2 = this.ids.get(oldVPath);
        if (!guid2) {
          return;
        }
        this.ydoc.transact(() => {
          this.ids.set(newVPath, guid2);
          this.ids.delete(oldVPath);
          if (doc2) {
            doc2.move(newVPath);
          }
        }, this);
      }
    }
  }
  destroy() {
    this.docs.forEach((doc2) => {
      doc2.destroy();
      this.docs.delete(doc2.guid);
    });
    super.destroy();
    if (this._persistence) {
      this._persistence.destroy();
    }
    this.docset.clear();
    this.unsubscribes.forEach((unsubscribe2) => {
      unsubscribe2();
    });
  }
};
var SharedFolders = class extends ObservableSet {
  constructor(relayManager, folderBuilder) {
    super();
    this.update = (0, import_obsidian3.debounce)(this.notifyListeners, 100);
    this.folderBuilder = folderBuilder;
    this.relayManager = relayManager;
    if (!this._offRemoteUpdates) {
      this._offRemoteUpdates = this.relayManager.remoteFolders.subscribe(
        (remotes) => {
          let updated = false;
          this.items().forEach((folder) => {
            const remote = remotes.find(
              (remote2) => remote2.guid == folder.guid
            );
            if (folder.remote != remote) {
              updated = true;
            }
            folder.remote = remote;
          });
          if (updated) {
            this.update();
          }
        }
      );
    }
  }
  toSettings() {
    return this.items().map((folder) => folder.settings);
  }
  delete(item) {
    item == null ? void 0 : item.destroy();
    return super.delete(item);
  }
  lookup(path2) {
    const folder = this.find((sharedFolder) => {
      return sharedFolder.checkPath(path2);
    });
    if (!folder) {
      return null;
    }
    return folder;
  }
  destroy() {
    this.items().forEach((folder) => {
      folder.destroy();
    });
    this.clear();
    if (this._offRemoteUpdates) {
      this._offRemoteUpdates();
    }
  }
  async _new(path2, guid, relayId, awaitingUpdates) {
    const existing = this.find(
      (folder2) => folder2.path == path2 && folder2.guid == guid
    );
    if (existing) {
      return existing;
    }
    const sameGuid = this.find((folder2) => folder2.guid == guid);
    if (sameGuid) {
      throw new Error(
        `This folder is already mounted at ${sameGuid.path}.`
      );
    }
    const samePath = this.find((folder2) => folder2.path == path2);
    if (samePath) {
      throw new Error(
        "Conflict: Tracked folder exists at this location."
      );
    }
    const folder = await this.folderBuilder(
      path2,
      guid,
      relayId,
      awaitingUpdates
    );
    this._set.add(folder);
    return folder;
  }
  async new(path2, guid, relayId, awaitingUpdates) {
    const folder = await this._new(path2, guid, relayId, awaitingUpdates);
    this.notifyListeners();
    return folder;
  }
};

// src/LiveViews.ts
var import_obsidian5 = require("obsidian");
var import_state3 = require("@codemirror/state");

// node_modules/svelte/src/runtime/internal/utils.js
function noop() {
}
function assign2(tar, src) {
  for (const k in src)
    tar[k] = src[k];
  return (
    /** @type {T & S} */
    tar
  );
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || a && typeof a === "object" || typeof a === "function";
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function subscribe2(store, ...callbacks) {
  if (store == null) {
    for (const callback of callbacks) {
      callback(void 0);
    }
    return noop;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function component_subscribe(component, store, callback) {
  component.$$.on_destroy.push(subscribe2(store, callback));
}
function create_slot(definition, ctx, $$scope, fn) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
    return definition[0](slot_ctx);
  }
}
function get_slot_context(definition, ctx, $$scope, fn) {
  return definition[1] && fn ? assign2($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
  if (definition[2] && fn) {
    const lets = definition[2](fn(dirty));
    if ($$scope.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);
      for (let i2 = 0; i2 < len; i2 += 1) {
        merged[i2] = $$scope.dirty[i2] | lets[i2];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    const dirty = [];
    const length4 = $$scope.ctx.length / 32;
    for (let i2 = 0; i2 < length4; i2++) {
      dirty[i2] = -1;
    }
    return dirty;
  }
  return -1;
}
function exclude_internal_props(props) {
  const result = {};
  for (const k in props)
    if (k[0] !== "$")
      result[k] = props[k];
  return result;
}
function compute_rest_props(props, keys2) {
  const rest = {};
  keys2 = new Set(keys2);
  for (const k in props)
    if (!keys2.has(k) && k[0] !== "$")
      rest[k] = props[k];
  return rest;
}
function null_to_empty(value) {
  return value == null ? "" : value;
}
function set_store_value(store, ret, value) {
  store.set(value);
  return ret;
}

// node_modules/svelte/src/runtime/internal/globals.js
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : (
  // @ts-ignore Node typings have this
  global
);

// node_modules/svelte/src/runtime/internal/ResizeObserverSingleton.js
var ResizeObserverSingleton = class {
  /** @param {ResizeObserverOptions} options */
  constructor(options) {
    /**
     * @private
     * @readonly
     * @type {WeakMap<Element, import('./private.js').Listener>}
     */
    __publicField(this, "_listeners", "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0);
    /**
     * @private
     * @type {ResizeObserver}
     */
    __publicField(this, "_observer");
    /** @type {ResizeObserverOptions} */
    __publicField(this, "options");
    this.options = options;
  }
  /**
   * @param {Element} element
   * @param {import('./private.js').Listener} listener
   * @returns {() => void}
   */
  observe(element3, listener) {
    this._listeners.set(element3, listener);
    this._getObserver().observe(element3, this.options);
    return () => {
      this._listeners.delete(element3);
      this._observer.unobserve(element3);
    };
  }
  /**
   * @private
   */
  _getObserver() {
    var _a2;
    return (_a2 = this._observer) != null ? _a2 : this._observer = new ResizeObserver((entries) => {
      var _a3;
      for (const entry of entries) {
        ResizeObserverSingleton.entries.set(entry.target, entry);
        (_a3 = this._listeners.get(entry.target)) == null ? void 0 : _a3(entry);
      }
    });
  }
};
ResizeObserverSingleton.entries = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;

// node_modules/svelte/src/runtime/internal/dom.js
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append2(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element2("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && /** @type {ShadowRoot} */
  root.host) {
    return (
      /** @type {ShadowRoot} */
      root
    );
  }
  return node.ownerDocument;
}
function append_stylesheet(node, style) {
  append2(
    /** @type {Document} */
    node.head || node,
    style
  );
  return style.sheet;
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i2 = 0; i2 < iterations.length; i2 += 1) {
    if (iterations[i2])
      iterations[i2].d(detaching);
  }
}
function element2(name) {
  return document.createElement(name);
}
function svg_element(name) {
  return document.createElementNS("http://www.w3.org/2000/svg", name);
}
function text2(data) {
  return document.createTextNode(data);
}
function space() {
  return text2(" ");
}
function empty() {
  return text2("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function set_svg_attributes(node, attributes) {
  for (const key in attributes) {
    attr(node, key, attributes[key]);
  }
}
function children(element3) {
  return Array.from(element3.childNodes);
}
function set_data(text3, data) {
  data = "" + data;
  if (text3.data === data)
    return;
  text3.data = /** @type {string} */
  data;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function set_style(node, key, value, important) {
  if (value == null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value, important ? "important" : "");
  }
}
function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
  return new CustomEvent(type, { detail, bubbles, cancelable });
}
function get_custom_elements_slots(element3) {
  const result = {};
  element3.childNodes.forEach(
    /** @param {Element} node */
    (node) => {
      result[node.slot || "default"] = true;
    }
  );
  return result;
}

// node_modules/svelte/src/runtime/internal/lifecycle.js
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function onDestroy(fn) {
  get_current_component().$$.on_destroy.push(fn);
}
function createEventDispatcher() {
  const component = get_current_component();
  return (type, detail, { cancelable = false } = {}) => {
    const callbacks = component.$$.callbacks[type];
    if (callbacks) {
      const event = custom_event(
        /** @type {string} */
        type,
        detail,
        { cancelable }
      );
      callbacks.slice().forEach((fn) => {
        fn.call(component, event);
      });
      return !event.defaultPrevented;
    }
    return true;
  };
}

// node_modules/svelte/src/runtime/internal/scheduler.js
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = /* @__PURE__ */ Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e2) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e2;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i2 = 0; i2 < render_callbacks.length; i2 += 1) {
      const callback = render_callbacks[i2];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
  targets.forEach((c) => c());
  render_callbacks = filtered;
}

// node_modules/svelte/src/runtime/internal/transitions.js
var outroing = /* @__PURE__ */ new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}

// node_modules/svelte/src/runtime/internal/each.js
function ensure_array_like(array_like_or_iterator) {
  return (array_like_or_iterator == null ? void 0 : array_like_or_iterator.length) !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
}

// node_modules/svelte/src/runtime/internal/spread.js
function get_spread_update(levels, updates) {
  const update2 = {};
  const to_null_out = {};
  const accounted_for = { $$scope: 1 };
  let i2 = levels.length;
  while (i2--) {
    const o = levels[i2];
    const n = updates[i2];
    if (n) {
      for (const key in o) {
        if (!(key in n))
          to_null_out[key] = 1;
      }
      for (const key in n) {
        if (!accounted_for[key]) {
          update2[key] = n[key];
          accounted_for[key] = 1;
        }
      }
      levels[i2] = n;
    } else {
      for (const key in o) {
        accounted_for[key] = 1;
      }
    }
  }
  for (const key in to_null_out) {
    if (!(key in update2))
      update2[key] = void 0;
  }
  return update2;
}
function get_spread_object(spread_props) {
  return typeof spread_props === "object" && spread_props !== null ? spread_props : {};
}

// node_modules/svelte/src/shared/boolean_attributes.js
var _boolean_attributes = (
  /** @type {const} */
  [
    "allowfullscreen",
    "allowpaymentrequest",
    "async",
    "autofocus",
    "autoplay",
    "checked",
    "controls",
    "default",
    "defer",
    "disabled",
    "formnovalidate",
    "hidden",
    "inert",
    "ismap",
    "loop",
    "multiple",
    "muted",
    "nomodule",
    "novalidate",
    "open",
    "playsinline",
    "readonly",
    "required",
    "reversed",
    "selected"
  ]
);
var boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);

// node_modules/svelte/src/runtime/internal/Component.js
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor) {
  const { fragment: fragment2, after_update } = component.$$;
  fragment2 && fragment2.m(target, anchor);
  add_render_callback(() => {
    const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
    if (component.$$.on_destroy) {
      component.$$.on_destroy.push(...new_on_destroy);
    } else {
      run_all(new_on_destroy);
    }
    component.$$.on_mount = [];
  });
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i2) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i2 / 31 | 0] |= 1 << i2 % 31;
}
function init(component, options, instance26, create_fragment26, not_equal, props, append_styles2 = null, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance26 ? instance26(component, options.props || {}, (i2, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i2], $$.ctx[i2] = value)) {
      if (!$$.skip_bound && $$.bound[i2])
        $$.bound[i2](value);
      if (ready)
        make_dirty(component, i2);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment26 ? create_fragment26($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor($$componentCtor, $$slots, use_shadow_dom) {
      super();
      /** The Svelte component constructor */
      __publicField(this, "$$ctor");
      /** Slots */
      __publicField(this, "$$s");
      /** The Svelte component instance */
      __publicField(this, "$$c");
      /** Whether or not the custom element is connected */
      __publicField(this, "$$cn", false);
      /** Component props data */
      __publicField(this, "$$d", {});
      /** `true` if currently in the process of reflecting component props back to attributes */
      __publicField(this, "$$r", false);
      /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
      __publicField(this, "$$p_d", {});
      /** @type {Record<string, Function[]>} Event listeners */
      __publicField(this, "$$l", {});
      /** @type {Map<Function, Function>} Event listener unsubscribe functions */
      __publicField(this, "$$l_u", /* @__PURE__ */ new Map());
      this.$$ctor = $$componentCtor;
      this.$$s = $$slots;
      if (use_shadow_dom) {
        this.attachShadow({ mode: "open" });
      }
    }
    addEventListener(type, listener, options) {
      this.$$l[type] = this.$$l[type] || [];
      this.$$l[type].push(listener);
      if (this.$$c) {
        const unsub = this.$$c.$on(type, listener);
        this.$$l_u.set(listener, unsub);
      }
      super.addEventListener(type, listener, options);
    }
    removeEventListener(type, listener, options) {
      super.removeEventListener(type, listener, options);
      if (this.$$c) {
        const unsub = this.$$l_u.get(listener);
        if (unsub) {
          unsub();
          this.$$l_u.delete(listener);
        }
      }
    }
    async connectedCallback() {
      this.$$cn = true;
      if (!this.$$c) {
        let create_slot2 = function(name) {
          return () => {
            let node;
            const obj = {
              c: function create8() {
                node = element2("slot");
                if (name !== "default") {
                  attr(node, "name", name);
                }
              },
              /**
               * @param {HTMLElement} target
               * @param {HTMLElement} [anchor]
               */
              m: function mount(target, anchor) {
                insert(target, node, anchor);
              },
              d: function destroy(detaching) {
                if (detaching) {
                  detach(node);
                }
              }
            };
            return obj;
          };
        };
        await Promise.resolve();
        if (!this.$$cn || this.$$c) {
          return;
        }
        const $$slots = {};
        const existing_slots = get_custom_elements_slots(this);
        for (const name of this.$$s) {
          if (name in existing_slots) {
            $$slots[name] = [create_slot2(name)];
          }
        }
        for (const attribute of this.attributes) {
          const name = this.$$g_p(attribute.name);
          if (!(name in this.$$d)) {
            this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, "toProp");
          }
        }
        for (const key in this.$$p_d) {
          if (!(key in this.$$d) && this[key] !== void 0) {
            this.$$d[key] = this[key];
            delete this[key];
          }
        }
        this.$$c = new this.$$ctor({
          target: this.shadowRoot || this,
          props: {
            ...this.$$d,
            $$slots,
            $$scope: {
              ctx: []
            }
          }
        });
        const reflect_attributes = () => {
          this.$$r = true;
          for (const key in this.$$p_d) {
            this.$$d[key] = this.$$c.$$.ctx[this.$$c.$$.props[key]];
            if (this.$$p_d[key].reflect) {
              const attribute_value = get_custom_element_value(
                key,
                this.$$d[key],
                this.$$p_d,
                "toAttribute"
              );
              if (attribute_value == null) {
                this.removeAttribute(this.$$p_d[key].attribute || key);
              } else {
                this.setAttribute(this.$$p_d[key].attribute || key, attribute_value);
              }
            }
          }
          this.$$r = false;
        };
        this.$$c.$$.after_update.push(reflect_attributes);
        reflect_attributes();
        for (const type in this.$$l) {
          for (const listener of this.$$l[type]) {
            const unsub = this.$$c.$on(type, listener);
            this.$$l_u.set(listener, unsub);
          }
        }
        this.$$l = {};
      }
    }
    // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
    // and setting attributes through setAttribute etc, this is helpful
    attributeChangedCallback(attr2, _oldValue, newValue) {
      var _a2;
      if (this.$$r)
        return;
      attr2 = this.$$g_p(attr2);
      this.$$d[attr2] = get_custom_element_value(attr2, newValue, this.$$p_d, "toProp");
      (_a2 = this.$$c) == null ? void 0 : _a2.$set({ [attr2]: this.$$d[attr2] });
    }
    disconnectedCallback() {
      this.$$cn = false;
      Promise.resolve().then(() => {
        if (!this.$$cn) {
          this.$$c.$destroy();
          this.$$c = void 0;
        }
      });
    }
    $$g_p(attribute_name) {
      return Object.keys(this.$$p_d).find(
        (key) => this.$$p_d[key].attribute === attribute_name || !this.$$p_d[key].attribute && key.toLowerCase() === attribute_name
      ) || attribute_name;
    }
  };
}
function get_custom_element_value(prop, value, props_definition, transform) {
  var _a2;
  const type = (_a2 = props_definition[prop]) == null ? void 0 : _a2.type;
  value = type === "Boolean" && typeof value !== "boolean" ? value != null : value;
  if (!transform || !props_definition[prop]) {
    return value;
  } else if (transform === "toAttribute") {
    switch (type) {
      case "Object":
      case "Array":
        return value == null ? null : JSON.stringify(value);
      case "Boolean":
        return value ? "" : null;
      case "Number":
        return value == null ? null : value;
      default:
        return value;
    }
  } else {
    switch (type) {
      case "Object":
      case "Array":
        return value && JSON.parse(value);
      case "Boolean":
        return value;
      case "Number":
        return value != null ? +value : value;
      default:
        return value;
    }
  }
}
var SvelteComponent = class {
  constructor() {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$");
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$set");
  }
  /** @returns {void} */
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(props) {
    if (this.$$set && !is_empty(props)) {
      this.$$.skip_bound = true;
      this.$$set(props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/svelte/src/shared/version.js
var PUBLIC_VERSION = "4";

// node_modules/svelte/src/runtime/internal/disclose-version/index.js
if (typeof window !== "undefined")
  (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);

// node_modules/lucide-svelte/dist/defaultAttributes.js
var defaultAttributes = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": 2,
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
var defaultAttributes_default = defaultAttributes;

// node_modules/lucide-svelte/dist/Icon.svelte
function get_each_context(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i2][0];
  child_ctx[12] = list[i2][1];
  return child_ctx;
}
function create_dynamic_element(ctx) {
  let svelte_element;
  let svelte_element_levels = [
    /*attrs*/
    ctx[12]
  ];
  let svelte_element_data = {};
  for (let i2 = 0; i2 < svelte_element_levels.length; i2 += 1) {
    svelte_element_data = assign2(svelte_element_data, svelte_element_levels[i2]);
  }
  return {
    c() {
      svelte_element = svg_element(
        /*tag*/
        ctx[11]
      );
      set_svg_attributes(svelte_element, svelte_element_data);
    },
    m(target, anchor) {
      insert(target, svelte_element, anchor);
    },
    p(ctx2, dirty) {
      set_svg_attributes(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [dirty & /*iconNode*/
      32 && /*attrs*/
      ctx2[12]]));
    },
    d(detaching) {
      if (detaching) {
        detach(svelte_element);
      }
    }
  };
}
function create_each_block(ctx) {
  let previous_tag = (
    /*tag*/
    ctx[11]
  );
  let svelte_element_anchor;
  let svelte_element = (
    /*tag*/
    ctx[11] && create_dynamic_element(ctx)
  );
  return {
    c() {
      if (svelte_element)
        svelte_element.c();
      svelte_element_anchor = empty();
    },
    m(target, anchor) {
      if (svelte_element)
        svelte_element.m(target, anchor);
      insert(target, svelte_element_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (
        /*tag*/
        ctx2[11]
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element(ctx2);
          previous_tag = /*tag*/
          ctx2[11];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*tag*/
          ctx2[11]
        )) {
          svelte_element.d(1);
          svelte_element = create_dynamic_element(ctx2);
          previous_tag = /*tag*/
          ctx2[11];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
        previous_tag = /*tag*/
        ctx2[11];
      }
    },
    d(detaching) {
      if (detaching) {
        detach(svelte_element_anchor);
      }
      if (svelte_element)
        svelte_element.d(detaching);
    }
  };
}
function create_fragment(ctx) {
  let svg;
  let each_1_anchor;
  let svg_stroke_width_value;
  let svg_class_value;
  let current;
  let each_value = ensure_array_like(
    /*iconNode*/
    ctx[5]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block(get_each_context(ctx, each_value, i2));
  }
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  let svg_levels = [
    defaultAttributes_default,
    /*$$restProps*/
    ctx[7],
    { width: (
      /*size*/
      ctx[2]
    ) },
    { height: (
      /*size*/
      ctx[2]
    ) },
    { stroke: (
      /*color*/
      ctx[1]
    ) },
    {
      "stroke-width": svg_stroke_width_value = /*absoluteStrokeWidth*/
      ctx[4] ? Number(
        /*strokeWidth*/
        ctx[3]
      ) * 24 / Number(
        /*size*/
        ctx[2]
      ) : (
        /*strokeWidth*/
        ctx[3]
      )
    },
    {
      class: svg_class_value = /*mergeClasses*/
      ctx[6](
        "lucide-icon",
        "lucide",
        /*name*/
        ctx[0] ? `lucide-${/*name*/
        ctx[0]}` : "",
        /*$$props*/
        ctx[8].class
      )
    }
  ];
  let svg_data = {};
  for (let i2 = 0; i2 < svg_levels.length; i2 += 1) {
    svg_data = assign2(svg_data, svg_levels[i2]);
  }
  return {
    c() {
      svg = svg_element("svg");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
      if (default_slot)
        default_slot.c();
      set_svg_attributes(svg, svg_data);
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(svg, null);
        }
      }
      append2(svg, each_1_anchor);
      if (default_slot) {
        default_slot.m(svg, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*iconNode*/
      32) {
        each_value = ensure_array_like(
          /*iconNode*/
          ctx2[5]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(svg, each_1_anchor);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        defaultAttributes_default,
        dirty & /*$$restProps*/
        128 && /*$$restProps*/
        ctx2[7],
        (!current || dirty & /*size*/
        4) && { width: (
          /*size*/
          ctx2[2]
        ) },
        (!current || dirty & /*size*/
        4) && { height: (
          /*size*/
          ctx2[2]
        ) },
        (!current || dirty & /*color*/
        2) && { stroke: (
          /*color*/
          ctx2[1]
        ) },
        (!current || dirty & /*absoluteStrokeWidth, strokeWidth, size*/
        28 && svg_stroke_width_value !== (svg_stroke_width_value = /*absoluteStrokeWidth*/
        ctx2[4] ? Number(
          /*strokeWidth*/
          ctx2[3]
        ) * 24 / Number(
          /*size*/
          ctx2[2]
        ) : (
          /*strokeWidth*/
          ctx2[3]
        ))) && { "stroke-width": svg_stroke_width_value },
        (!current || dirty & /*name, $$props*/
        257 && svg_class_value !== (svg_class_value = /*mergeClasses*/
        ctx2[6](
          "lucide-icon",
          "lucide",
          /*name*/
          ctx2[0] ? `lucide-${/*name*/
          ctx2[0]}` : "",
          /*$$props*/
          ctx2[8].class
        ))) && { class: svg_class_value }
      ]));
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
      destroy_each(each_blocks, detaching);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "name",
    "color",
    "size",
    "strokeWidth",
    "absoluteStrokeWidth",
    "iconNode",
    "mergeClasses"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  let { name = void 0 } = $$props;
  let { color = "currentColor" } = $$props;
  let { size = 24 } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { absoluteStrokeWidth = false } = $$props;
  let { iconNode } = $$props;
  const mergeClasses = (...classes) => classes.filter((className, index, array) => {
    return Boolean(className) && array.indexOf(className) === index;
  }).join(" ");
  $$self.$$set = ($$new_props) => {
    $$invalidate(8, $$props = assign2(assign2({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("name" in $$new_props)
      $$invalidate(0, name = $$new_props.name);
    if ("color" in $$new_props)
      $$invalidate(1, color = $$new_props.color);
    if ("size" in $$new_props)
      $$invalidate(2, size = $$new_props.size);
    if ("strokeWidth" in $$new_props)
      $$invalidate(3, strokeWidth = $$new_props.strokeWidth);
    if ("absoluteStrokeWidth" in $$new_props)
      $$invalidate(4, absoluteStrokeWidth = $$new_props.absoluteStrokeWidth);
    if ("iconNode" in $$new_props)
      $$invalidate(5, iconNode = $$new_props.iconNode);
    if ("$$scope" in $$new_props)
      $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [
    name,
    color,
    size,
    strokeWidth,
    absoluteStrokeWidth,
    iconNode,
    mergeClasses,
    $$restProps,
    $$props,
    $$scope,
    slots
  ];
}
var Icon = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, {
      name: 0,
      color: 1,
      size: 2,
      strokeWidth: 3,
      absoluteStrokeWidth: 4,
      iconNode: 5,
      mergeClasses: 6
    });
  }
  get mergeClasses() {
    return this.$$.ctx[6];
  }
};
var Icon_default = Icon;

// node_modules/lucide-svelte/dist/icons/arrow-right-left.svelte
function create_default_slot(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment2(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "arrow-right-left" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot] },
    $$scope: { ctx }
  };
  for (let i2 = 0; i2 < icon_spread_levels.length; i2 += 1) {
    icon_props = assign2(icon_props, icon_spread_levels[i2]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["path", { "d": "m16 3 4 4-4 4" }],
    ["path", { "d": "M20 7H4" }],
    ["path", { "d": "m8 21-4-4 4-4" }],
    ["path", { "d": "M4 17h16" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign2(assign2({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Arrow_right_left = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance2, create_fragment2, safe_not_equal, {});
  }
};
var arrow_right_left_default = Arrow_right_left;

// node_modules/lucide-svelte/dist/icons/chevron-left.svelte
function create_default_slot2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment3(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "chevron-left" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot2] },
    $$scope: { ctx }
  };
  for (let i2 = 0; i2 < icon_spread_levels.length; i2 += 1) {
    icon_props = assign2(icon_props, icon_spread_levels[i2]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance3($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [["path", { "d": "m15 18-6-6 6-6" }]];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign2(assign2({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Chevron_left = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance3, create_fragment3, safe_not_equal, {});
  }
};
var chevron_left_default = Chevron_left;

// node_modules/lucide-svelte/dist/icons/folder.svelte
function create_default_slot3(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment4(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "folder" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot3] },
    $$scope: { ctx }
  };
  for (let i2 = 0; i2 < icon_spread_levels.length; i2 += 1) {
    icon_props = assign2(icon_props, icon_spread_levels[i2]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance4($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "path",
      {
        "d": "M20 20a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.9a2 2 0 0 1-1.69-.9L9.6 3.9A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13a2 2 0 0 0 2 2Z"
      }
    ]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign2(assign2({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Folder = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance4, create_fragment4, safe_not_equal, {});
  }
};
var folder_default = Folder;

// node_modules/lucide-svelte/dist/icons/layers.svelte
function create_default_slot4(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment5(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "layers" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot4] },
    $$scope: { ctx }
  };
  for (let i2 = 0; i2 < icon_spread_levels.length; i2 += 1) {
    icon_props = assign2(icon_props, icon_spread_levels[i2]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance5($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "path",
      {
        "d": "m12.83 2.18a2 2 0 0 0-1.66 0L2.6 6.08a1 1 0 0 0 0 1.83l8.58 3.91a2 2 0 0 0 1.66 0l8.58-3.9a1 1 0 0 0 0-1.83Z"
      }
    ],
    [
      "path",
      {
        "d": "m22 17.65-9.17 4.16a2 2 0 0 1-1.66 0L2 17.65"
      }
    ],
    [
      "path",
      {
        "d": "m22 12.65-9.17 4.16a2 2 0 0 1-1.66 0L2 12.65"
      }
    ]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign2(assign2({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Layers = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance5, create_fragment5, safe_not_equal, {});
  }
};
var layers_default = Layers;

// node_modules/lucide-svelte/dist/icons/satellite.svelte
function create_default_slot5(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment6(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "satellite" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot5] },
    $$scope: { ctx }
  };
  for (let i2 = 0; i2 < icon_spread_levels.length; i2 += 1) {
    icon_props = assign2(icon_props, icon_spread_levels[i2]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance6($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["path", { "d": "M13 7 9 3 5 7l4 4" }],
    ["path", { "d": "m17 11 4 4-4 4-4-4" }],
    ["path", { "d": "m8 12 4 4 6-6-4-4Z" }],
    ["path", { "d": "m16 8 3-3" }],
    ["path", { "d": "M9 21a6 6 0 0 0-6-6" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign2(assign2({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Satellite = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance6, create_fragment6, safe_not_equal, {});
  }
};
var satellite_default = Satellite;

// node_modules/lucide-svelte/dist/icons/settings.svelte
function create_default_slot6(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment7(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "settings" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot6] },
    $$scope: { ctx }
  };
  for (let i2 = 0; i2 < icon_spread_levels.length; i2 += 1) {
    icon_props = assign2(icon_props, icon_spread_levels[i2]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance7($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "path",
      {
        "d": "M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"
      }
    ],
    ["circle", { "cx": "12", "cy": "12", "r": "3" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign2(assign2({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Settings = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance7, create_fragment7, safe_not_equal, {});
  }
};
var settings_default = Settings;

// src/components/ViewActions.svelte
function add_css(target) {
  append_styles(target, "svelte-2kz9o8", "button.system3-connected.svelte-2kz9o8{color:var(--color-accent)}button.system3-disconnected.svelte-2kz9o8{color:var(--color-base-40)}button.notebook.svelte-2kz9o8{color:var(--color-base-30);background-color:transparent}");
}
function create_else_block(ctx) {
  let button;
  let layers;
  let button_data_filename_value;
  let current;
  layers = new layers_default({ props: { class: "svg-icon inline-icon" } });
  return {
    c() {
      var _a2;
      button = element2("button");
      create_component(layers.$$.fragment);
      attr(button, "class", "notebook clickable-icon view-action svelte-2kz9o8");
      attr(button, "aria-label", "Tracking Changes");
      attr(button, "tabindex", "0");
      attr(button, "data-filename", button_data_filename_value = /*view*/
      (_a2 = ctx[0].view.file) == null ? void 0 : _a2.name);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      mount_component(layers, button, null);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      if (!current || dirty & /*view*/
      1 && button_data_filename_value !== (button_data_filename_value = /*view*/
      (_a2 = ctx2[0].view.file) == null ? void 0 : _a2.name)) {
        attr(button, "data-filename", button_data_filename_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(layers.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(layers.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      destroy_component(layers);
    }
  };
}
function create_if_block(ctx) {
  let button0;
  let layers;
  let button0_data_filename_value;
  let t2;
  let button1;
  let satellite;
  let button1_class_value;
  let button1_aria_label_value;
  let current;
  let mounted;
  let dispose;
  layers = new layers_default({ props: { class: "svg-icon inline-icon" } });
  satellite = new satellite_default({ props: { class: "svg-icon inline-icon" } });
  return {
    c() {
      var _a2;
      button0 = element2("button");
      create_component(layers.$$.fragment);
      t2 = space();
      button1 = element2("button");
      create_component(satellite.$$.fragment);
      attr(button0, "class", "hidden notebook clickable-icon view-action system3-view-action svelte-2kz9o8");
      attr(button0, "aria-label", "Tracking Changes");
      attr(button0, "tabindex", "0");
      attr(button0, "data-filename", button0_data_filename_value = /*view*/
      (_a2 = ctx[0].view.file) == null ? void 0 : _a2.name);
      attr(button1, "class", button1_class_value = "system3-" + /*state*/
      ctx[1].status + " clickable-icon view-action system3-view-action svelte-2kz9o8");
      attr(button1, "aria-label", button1_aria_label_value = `${/*remote*/
      ctx[2].relay.name} (${/*state*/
      ctx[1].status})`);
      attr(button1, "tabindex", "0");
    },
    m(target, anchor) {
      insert(target, button0, anchor);
      mount_component(layers, button0, null);
      insert(target, t2, anchor);
      insert(target, button1, anchor);
      mount_component(satellite, button1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button1,
            "click",
            /*handleClick*/
            ctx[3]
          ),
          listen(
            button1,
            "keypress",
            /*handleKeyPress*/
            ctx[4]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      var _a2;
      if (!current || dirty & /*view*/
      1 && button0_data_filename_value !== (button0_data_filename_value = /*view*/
      (_a2 = ctx2[0].view.file) == null ? void 0 : _a2.name)) {
        attr(button0, "data-filename", button0_data_filename_value);
      }
      if (!current || dirty & /*state*/
      2 && button1_class_value !== (button1_class_value = "system3-" + /*state*/
      ctx2[1].status + " clickable-icon view-action system3-view-action svelte-2kz9o8")) {
        attr(button1, "class", button1_class_value);
      }
      if (!current || dirty & /*remote, state*/
      6 && button1_aria_label_value !== (button1_aria_label_value = `${/*remote*/
      ctx2[2].relay.name} (${/*state*/
      ctx2[1].status})`)) {
        attr(button1, "aria-label", button1_aria_label_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(layers.$$.fragment, local);
      transition_in(satellite.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(layers.$$.fragment, local);
      transition_out(satellite.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button0);
        detach(t2);
        detach(button1);
      }
      destroy_component(layers);
      destroy_component(satellite);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment8(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*remote*/
      ctx2[2]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function instance8($$self, $$props, $$invalidate) {
  var _a2;
  let { view } = $$props;
  let { document: document2 } = $$props;
  let { state } = $$props;
  let remote;
  if ((_a2 = document2 === null || document2 === void 0 ? void 0 : document2.sharedFolder) === null || _a2 === void 0 ? void 0 : _a2.remote) {
    remote = document2.sharedFolder.remote;
  }
  const ariaLabels = {
    connected: "connected: click to go offline",
    connecting: "connecting...",
    disconnected: "disconnected: click to go online",
    unknown: "unknown status"
  };
  const handleClick = () => {
    view.toggleConnection();
  };
  const handleKeyPress = (event) => {
    if (event.key === "Enter") {
      handleClick();
    }
  };
  $$self.$$set = ($$props2) => {
    if ("view" in $$props2)
      $$invalidate(0, view = $$props2.view);
    if ("document" in $$props2)
      $$invalidate(5, document2 = $$props2.document);
    if ("state" in $$props2)
      $$invalidate(1, state = $$props2.state);
  };
  return [view, state, remote, handleClick, handleKeyPress, document2];
}
var ViewActions = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance8, create_fragment8, safe_not_equal, { view: 0, document: 5, state: 1 }, add_css);
  }
};
var ViewActions_default = ViewActions;

// src/y-codemirror.next/LiveEditPlugin.ts
var import_state = require("@codemirror/state");
var import_view = require("@codemirror/view");
var connectionManagerFacet = import_state.Facet.define({
  combine(inputs) {
    return inputs[inputs.length - 1];
  }
});
var ySyncAnnotation = import_state.Annotation.define();
var LiveCMPluginValue = class {
  constructor(editor) {
    this.log = (message) => {
    };
    var _a2;
    this.editor = editor;
    this.connectionManager = this.editor.state.facet(
      connectionManagerFacet
    );
    this.view = this.connectionManager.findView(editor);
    this.editor = editor;
    if (!this.view) {
      return;
    }
    this.log = curryLog(
      `[LiveCMPluginValue][${(_a2 = this.view.view.file) == null ? void 0 : _a2.path}]`
    );
    this.log("created");
    if (!this.view.document) {
      return;
    }
    this.view.plugin = this;
    this.view.document.whenSynced().then(() => {
      var _a3;
      this.setBuffer();
      (_a3 = this.view) == null ? void 0 : _a3.view.requestSave();
    });
    this._observer = (event, tr) => {
      if (tr.origin !== this) {
        const delta = event.delta;
        const changes = [];
        let pos = 0;
        for (let i2 = 0; i2 < delta.length; i2++) {
          const d = delta[i2];
          if (d.insert != null) {
            changes.push({
              from: pos,
              to: pos,
              insert: d.insert
            });
          } else if (d.delete != null) {
            changes.push({
              from: pos,
              to: pos + d.delete,
              insert: ""
            });
            pos += d.delete;
          } else if (d.retain != null) {
            pos += d.retain;
          }
        }
        this.log("dispatch");
        editor.dispatch({
          changes,
          annotations: [ySyncAnnotation.of(this)]
        });
      }
    };
    this._ytext = this.view.document.ytext;
    this._ytext.observe(this._observer);
  }
  setBuffer() {
    var _a2, _b2, _c;
    if (((_a2 = this.view) == null ? void 0 : _a2.document) && ((_b2 = this.view) == null ? void 0 : _b2.document.text) !== this.editor.state.doc.toString()) {
      this.log(`setting buffer ${(_c = this.view) == null ? void 0 : _c.document} ${this.editor}`);
      this.editor.dispatch({
        changes: {
          from: 0,
          to: this.editor.state.doc.length,
          insert: this.view.document.text
        },
        annotations: [ySyncAnnotation.of(this)]
        // this should be ignored by the update handler
      });
      return true;
    }
    return false;
  }
  update(update2) {
    var _a2, _b2, _c;
    if (!update2.docChanged || update2.transactions.length > 0 && update2.transactions[0].annotation(ySyncAnnotation) === this) {
      return;
    }
    const editor = update2.view;
    this.view = this.connectionManager.findView(editor);
    const ytext = (_b2 = (_a2 = this.view) == null ? void 0 : _a2.document) == null ? void 0 : _b2.ytext;
    if (!ytext) {
      return;
    }
    (_c = ytext.doc) == null ? void 0 : _c.transact(() => {
      let adj = 0;
      update2.changes.iterChanges((fromA, toA, fromB, toB, insert2) => {
        const insertText2 = insert2.sliceString(0, insert2.length, "\n");
        if (fromA !== toA) {
          ytext.delete(fromA + adj, toA - fromA);
        }
        if (insertText2.length > 0) {
          ytext.insert(fromA + adj, insertText2);
        }
        adj += insertText2.length - (toA - fromA);
      });
    }, this);
  }
  destroy() {
    var _a2;
    if (this._observer) {
      (_a2 = this._ytext) == null ? void 0 : _a2.unobserve(this._observer);
    }
  }
};
var LiveEdit = import_view.ViewPlugin.fromClass(LiveCMPluginValue);

// src/y-codemirror.next/RemoteSelections.ts
var import_state2 = require("@codemirror/state");
var import_view2 = require("@codemirror/view");
var yRemoteSelectionsTheme = import_view2.EditorView.baseTheme({
  ".cm-ySelection": {},
  ".cm-yLineSelection": {
    padding: 0,
    margin: "0px 2px 0px 4px"
  },
  ".cm-ySelectionCaret": {
    position: "relative",
    borderLeft: "1px solid black",
    borderRight: "1px solid black",
    marginLeft: "-1px",
    marginRight: "-1px",
    boxSizing: "border-box",
    display: "inline"
  },
  ".cm-ySelectionCaretDot": {
    borderRadius: "50%",
    position: "absolute",
    width: ".4em",
    height: ".4em",
    top: "-.2em",
    left: "-.2em",
    backgroundColor: "inherit",
    transition: "transform .3s ease-in-out",
    boxSizing: "border-box"
  },
  ".cm-ySelectionCaret:hover > .cm-ySelectionCaretDot": {
    transformOrigin: "bottom center",
    transform: "scale(0)"
  },
  ".cm-ySelectionInfo": {
    position: "absolute",
    top: "-1.05em",
    left: "-1px",
    fontSize: ".75em",
    fontFamily: "serif",
    fontStyle: "normal",
    fontWeight: "normal",
    lineHeight: "normal",
    userSelect: "none",
    color: "white",
    paddingLeft: "2px",
    paddingRight: "2px",
    zIndex: 101,
    transition: "opacity .3s ease-in-out",
    backgroundColor: "inherit",
    // these should be separate
    opacity: 0,
    transitionDelay: "0s",
    whiteSpace: "nowrap"
  },
  ".cm-ySelectionCaret:hover > .cm-ySelectionInfo": {
    opacity: 1,
    transitionDelay: "0s"
  }
});
var yRemoteSelectionsAnnotation = import_state2.Annotation.define();
var YRemoteCaretWidget = class extends import_view2.WidgetType {
  constructor(color, name) {
    super();
    this.color = color;
    this.name = name;
  }
  toDOM(editor) {
    return element(
      "span",
      [
        create5("class", "cm-ySelectionCaret"),
        create5(
          "style",
          `background-color: ${this.color}; border-color: ${this.color}`
        )
      ],
      [
        text("\u2060"),
        element("div", [
          create5("class", "cm-ySelectionCaretDot")
        ]),
        text("\u2060"),
        element(
          "div",
          [create5("class", "cm-ySelectionInfo")],
          [text(this.name)]
        ),
        text("\u2060")
      ]
    );
  }
  eq(widget) {
    return widget.color === this.color;
  }
  compare(widget) {
    return widget.color === this.color;
  }
  updateDOM() {
    return false;
  }
  get estimatedHeight() {
    return -1;
  }
  ignoreEvent() {
    return true;
  }
};
var YRemoteSelectionsPluginValue = class {
  constructor(editor) {
    var _a2;
    this.editor = editor;
    this.decorations = import_state2.RangeSet.of([]);
    this.connectionManager = this.editor.state.facet(
      connectionManagerFacet
    );
    const view = this.connectionManager.findView(editor);
    if (view && view instanceof LiveView) {
      this.view = view;
      const provider = (_a2 = this.view.document) == null ? void 0 : _a2._provider;
      this._listener = ({ added, updated, removed }, s2, t2) => {
        const clients = added.concat(updated).concat(removed);
        if (clients.findIndex(
          (id2) => {
            var _a3;
            return id2 !== ((_a3 = this._awareness) == null ? void 0 : _a3.doc.clientID);
          }
        ) >= 0) {
          editor.dispatch({
            annotations: [yRemoteSelectionsAnnotation.of([])]
          });
        }
      };
      if (provider) {
        this._awareness = provider.awareness;
        this._awareness.on("change", this._listener);
      }
    }
  }
  destroy() {
    var _a2;
    if (this._listener) {
      (_a2 = this._awareness) == null ? void 0 : _a2.off("change", this._listener);
    }
  }
  update(update2) {
    var _a2, _b2, _c, _d;
    const editor = update2.view;
    this.view = (_a2 = this.connectionManager) == null ? void 0 : _a2.findView(editor);
    const ytext = (_c = (_b2 = this.view) == null ? void 0 : _b2.document) == null ? void 0 : _c.ytext;
    if (!(this.view && ytext && ytext.doc)) {
      return;
    }
    const provider = (_d = this.view.document) == null ? void 0 : _d._provider;
    if (!provider) {
      return;
    }
    this._awareness = provider.awareness;
    const awareness = this._awareness;
    const ydoc = ytext.doc;
    const decorations = [];
    const localAwarenessState = this._awareness.getLocalState();
    if (localAwarenessState != null) {
      const hasFocus = update2.view.hasFocus && update2.view.dom.ownerDocument.hasFocus();
      const sel = hasFocus ? update2.state.selection.main : null;
      const currentAnchor = localAwarenessState.cursor == null ? null : createRelativePositionFromJSON(
        localAwarenessState.cursor.anchor
        // eslint-disable-next-line no-mixed-spaces-and-tabs
      );
      const currentHead = localAwarenessState.cursor == null ? null : createRelativePositionFromJSON(
        localAwarenessState.cursor.head
        // eslint-disable-next-line no-mixed-spaces-and-tabs
      );
      if (sel != null) {
        const anchor = createRelativePositionFromTypeIndex(
          ytext,
          sel.anchor
        );
        const head = createRelativePositionFromTypeIndex(
          ytext,
          sel.head
        );
        if (localAwarenessState.cursor == null || !compareRelativePositions(currentAnchor, anchor) || !compareRelativePositions(currentHead, head)) {
          awareness.setLocalStateField("cursor", {
            anchor,
            head
          });
        }
      } else if (localAwarenessState.cursor != null && hasFocus) {
        awareness.setLocalStateField("cursor", null);
      }
    }
    awareness.getStates().forEach((state, clientid) => {
      if (clientid === awareness.doc.clientID) {
        return;
      }
      const cursor = state.cursor;
      if (cursor == null || cursor.anchor == null || cursor.head == null) {
        return;
      }
      const anchor = createAbsolutePositionFromRelativePosition(
        cursor.anchor,
        ydoc
      );
      const head = createAbsolutePositionFromRelativePosition(
        cursor.head,
        ydoc
      );
      if (anchor == null || head == null || anchor.type !== ytext || head.type !== ytext) {
        return;
      }
      const { color = "#30bced", name = "Anonymous" } = state.user || {};
      const colorLight = state.user && state.user.colorLight || color + "33";
      const start = min(anchor.index, head.index);
      const end = max(anchor.index, head.index);
      const startLine = update2.view.state.doc.lineAt(start);
      const endLine = update2.view.state.doc.lineAt(end);
      if (startLine.number === endLine.number) {
        decorations.push({
          from: start,
          to: end,
          value: import_view2.Decoration.mark({
            attributes: {
              style: `background-color: ${colorLight}`
            },
            class: "cm-ySelection"
          })
        });
      } else {
        decorations.push({
          from: start,
          to: startLine.from + startLine.length,
          value: import_view2.Decoration.mark({
            attributes: {
              style: `background-color: ${colorLight}`
            },
            class: "cm-ySelection"
          })
        });
        decorations.push({
          from: endLine.from,
          to: end,
          value: import_view2.Decoration.mark({
            attributes: {
              style: `background-color: ${colorLight}`
            },
            class: "cm-ySelection"
          })
        });
        for (let i2 = startLine.number + 1; i2 < endLine.number; i2++) {
          const linePos = update2.view.state.doc.line(i2).from;
          decorations.push({
            from: linePos,
            to: linePos,
            value: import_view2.Decoration.line({
              attributes: {
                style: `background-color: ${colorLight}`,
                class: "cm-yLineSelection"
              }
            })
          });
        }
      }
      decorations.push({
        from: head.index,
        to: head.index,
        value: import_view2.Decoration.widget({
          side: head.index - anchor.index > 0 ? -1 : 1,
          // the local cursor should be rendered outside the remote selection
          block: false,
          widget: new YRemoteCaretWidget(color, name)
        })
      });
    });
    this.decorations = import_view2.Decoration.set(decorations, true);
  }
};
var yRemoteSelections = import_view2.ViewPlugin.fromClass(
  YRemoteSelectionsPluginValue,
  {
    decorations: (v) => v.decorations
  }
);

// src/ui/Banner.ts
var Banner = class {
  constructor(view, text3, onClick) {
    this.view = view;
    this.text = text3;
    this.onClick = onClick;
    this.display();
  }
  display() {
    const leafContentEl = this.view.containerEl;
    const contentEl = this.view.containerEl.querySelector(".view-content");
    if (!leafContentEl) {
      return;
    }
    let bannerBox = leafContentEl.querySelector(".bannerBox");
    if (!bannerBox) {
      bannerBox = document.createElement("div");
      bannerBox.classList.add("bannerBox");
      leafContentEl.insertBefore(bannerBox, contentEl);
    }
    let banner = leafContentEl.querySelector(".banner");
    if (!banner) {
      banner = document.createElement("div");
      banner.classList.add("banner");
      const span = banner.createSpan();
      span.setText(this.text);
      banner.appendChild(span);
      bannerBox.appendChild(banner);
      const onClick = async () => {
        const destroy = await this.onClick();
        if (destroy) {
          this.destroy();
        }
      };
      banner.addEventListener("click", onClick);
    }
    return true;
  }
  destroy() {
    const leafContentEl = this.view.containerEl;
    if (!leafContentEl) {
      return;
    }
    const bannerBox = leafContentEl.querySelector(".bannerBox");
    if (bannerBox) {
      bannerBox.replaceChildren();
    }
    return true;
  }
};

// src/LiveViews.ts
var import_obsidian6 = require("obsidian");
var BACKGROUND_CONNECTIONS = 20;
function ViewsetsEqual(vs1, vs2) {
  var _a2, _b2, _c, _d;
  if (vs1.length !== vs2.length) {
    return false;
  }
  for (let i2 = 0; i2 < vs1.length; i2++) {
    if (((_a2 = vs1[i2].view.file) == null ? void 0 : _a2.path) !== ((_b2 = vs2[i2].view.file) == null ? void 0 : _b2.path)) {
      return false;
    }
    if (((_c = vs1[i2].document) == null ? void 0 : _c.path) !== ((_d = vs2[i2].document) == null ? void 0 : _d.path)) {
      return false;
    }
  }
  return true;
}
var LoggedOutView = class {
  constructor(connectionManager, view, login) {
    this.document = null;
    this._parent = connectionManager;
    this.view = view;
    this.login = login;
  }
  attach() {
    this.banner = new Banner(
      this.view,
      "Login to enable Live edits",
      async () => {
        return await this.login();
      }
    );
    return Promise.resolve(this);
  }
  release() {
    var _a2;
    (_a2 = this.banner) == null ? void 0 : _a2.destroy();
  }
};
var LiveView = class {
  constructor(connectionManager, view, document2, shouldConnect = true, canConnect = true) {
    this._parent = connectionManager;
    this.view = view;
    this.document = document2;
    this.shouldConnect = shouldConnect;
    this.canConnect = canConnect;
    if (!connectionManager.networkStatus.online) {
      this.offlineBanner();
    }
  }
  toggleConnection() {
    this.shouldConnect = !this.shouldConnect;
    if (this.shouldConnect) {
      this.document.connect().then((connected) => {
        if (!connected) {
          this.shouldConnect = false;
        }
      });
    } else {
      this.document.disconnect();
    }
  }
  get ytext() {
    return this.document.ytext;
  }
  offlineBanner() {
    if (this.shouldConnect) {
      const banner = new Banner(
        this.view,
        "You're offline -- click to reconnect",
        async () => {
          this._parent.networkStatus.checkStatus();
          this.connect();
          return this._parent.networkStatus.online;
        }
      );
      this._parent.networkStatus.onceOnline(() => {
        this.connect();
        banner.destroy();
      });
    }
    return () => {
    };
  }
  setConnectionDot() {
    const viewActionsElement = this.view.containerEl.querySelector(".view-actions");
    if (viewActionsElement && viewActionsElement.firstChild) {
      const viewActions = this.view.containerEl.querySelectorAll(
        ".system3-view-action"
      );
      if (!this._viewActions) {
        if (viewActions.length > 0) {
          viewActions.forEach((viewAction) => {
            viewAction.remove();
          });
        }
        if (this.offConnectionStatusSubscription) {
          this.offConnectionStatusSubscription();
        }
        this._viewActions = new ViewActions_default({
          target: viewActionsElement,
          anchor: viewActionsElement.firstChild,
          props: {
            view: this,
            document: this.document,
            state: this.document.state
          }
        });
        this.offConnectionStatusSubscription = this.document.subscribe(
          viewActionsElement,
          (state) => {
            var _a2;
            (_a2 = this._viewActions) == null ? void 0 : _a2.$set({
              view: this,
              document: this.document,
              state
            });
          }
        );
      }
      this._viewActions.$set({
        view: this,
        document: this.document,
        state: this.document.state
      });
    }
  }
  attach() {
    this.setConnectionDot();
    return new Promise((resolve) => {
      return this.document.whenReady().then((doc2) => {
        if (this.shouldConnect && this.canConnect && this._parent.networkStatus.online) {
          this.connect();
        }
        resolve(this);
      }).catch(() => {
        this.offlineBanner();
      });
    });
  }
  connect() {
    this.document.connect();
  }
  release() {
    var _a2;
    (_a2 = this._viewActions) == null ? void 0 : _a2.$destroy();
    this._viewActions = void 0;
    if (this.offConnectionStatusSubscription) {
      this.offConnectionStatusSubscription();
      this.offConnectionStatusSubscription = void 0;
    }
    this.document.disconnect();
  }
};
var LiveViewManager2 = class {
  constructor(workspace, sharedFolders, loginManager, networkStatus) {
    this.offListeners = [];
    this.folderListeners = /* @__PURE__ */ new Map();
    this.workspace = workspace;
    this.sharedFolders = sharedFolders;
    this.views = [];
    this.extensions = [];
    this._compartment = new import_state3.Compartment();
    this._activePromise = null;
    this._stale = "";
    this.loginManager = loginManager;
    this.networkStatus = networkStatus;
    this.refreshQueue = [];
    this.log = curryLog("[LiveViews]", "log");
    this.warn = curryLog("[LiveViews]", "warn");
    this.offListeners.push(
      this.loginManager.on(() => {
        this.refresh("[LoginManager]");
      })
    );
    const folderSub = (folder) => {
      if (!folder.ready) {
        folder.whenReady().then(() => {
          this.refresh("[Shared Folder Ready]");
        }).catch((_) => {
          this.views.forEach((view) => {
            var _a2;
            if (((_a2 = view.document) == null ? void 0 : _a2.sharedFolder) === folder) {
              view.offlineBanner();
            }
          });
        });
      }
      return folder.docset.on(() => {
        this.refresh("[Docset]");
      });
    };
    this.offListeners.push(
      this.sharedFolders.on(() => {
        this.refresh("[Shared Folders]");
        this.folderListeners.forEach((off, folder) => {
          if (!this.sharedFolders.has(folder)) {
            off();
            this.folderListeners.delete(folder);
          }
        });
        this.sharedFolders.forEach((folder) => {
          if (!this.folderListeners.has(folder)) {
            this.folderListeners.set(folder, folderSub(folder));
          }
        });
      })
    );
  }
  goOffline() {
    this.log("[System 3][Relay][Live Views] going offline");
    this.views.forEach((view) => {
      var _a2;
      return (_a2 = view.document) == null ? void 0 : _a2.disconnect();
    });
    this.refresh("[NetworkStatus]");
  }
  goOnline() {
    this.log("[System 3][Relay][Live Views] going online");
    this.sharedFolders.items().forEach((folder) => {
      folder.connect();
    });
    this.viewsAttachedWithConnectionPool(this.views);
  }
  releaseViews(views) {
    views.forEach((view) => {
      view.release();
    });
  }
  findFolders() {
    const folders = /* @__PURE__ */ new Set();
    this.workspace.iterateMarkdownViews((markdownView) => {
      var _a2;
      const viewFilePath = (_a2 = markdownView.file) == null ? void 0 : _a2.path;
      if (!viewFilePath) {
        return;
      }
      const folder = this.sharedFolders.lookup(viewFilePath);
      if (folder) {
        folders.add(folder);
      }
    });
    if ([...folders].length == 0) {
      return [];
    }
    return [...folders];
  }
  async foldersReady() {
    const folders = /* @__PURE__ */ new Set();
    this.workspace.iterateMarkdownViews((markdownView) => {
      var _a2;
      const viewFilePath = (_a2 = markdownView.file) == null ? void 0 : _a2.path;
      if (!viewFilePath) {
        return;
      }
      const folder = this.sharedFolders.lookup(viewFilePath);
      if (folder) {
        folders.add(folder);
      }
    });
    if ([...folders].length == 0) {
      return [];
    }
    const readyFolders = [...folders].map((folder) => folder.whenReady());
    return Promise.all(readyFolders);
  }
  getViews() {
    const views = [];
    this.workspace.iterateMarkdownViews((markdownView) => {
      var _a2;
      const viewFilePath = (_a2 = markdownView.file) == null ? void 0 : _a2.path;
      if (!viewFilePath) {
        return;
      }
      const folder = this.sharedFolders.lookup(viewFilePath);
      if (folder) {
        if (!this.loginManager.loggedIn) {
          const view = new LoggedOutView(this, markdownView, () => {
            return this.loginManager.openLoginPage();
          });
          views.push(view);
        } else {
          const doc2 = folder.getFile(viewFilePath, true, true, true);
          const view = new LiveView(this, markdownView, doc2);
          views.push(view);
        }
      }
    });
    return views;
  }
  findView(cmEditor) {
    return this.views.find((view) => {
      const editor = view.view.editor;
      const cm = editor.cm;
      return cm === cmEditor;
    });
  }
  async viewsReady(views) {
    return await Promise.all(
      views.filter((view) => view instanceof LiveView).map(
        async (view) => view.document.whenReady().then((_) => view)
      )
    );
  }
  async viewsAttachedWithConnectionPool(views, backgroundConnections = BACKGROUND_CONNECTIONS) {
    const activeView = this.workspace.workspace.getActiveViewOfType(
      import_obsidian5.MarkdownView
    );
    let attemptedConnections = 0;
    for (const view of views) {
      if (view instanceof LiveView) {
        if (view.view === activeView) {
          view.canConnect = true;
        } else {
          view.canConnect = attemptedConnections < backgroundConnections;
          attemptedConnections++;
        }
      }
    }
    if (attemptedConnections > backgroundConnections) {
      this.warn(
        `[System 3][Relay][Live Views] connection pool (max ${backgroundConnections}): rejected connections for ${attemptedConnections - backgroundConnections} views`
      );
    }
    return this.viewsAttached(views);
  }
  async viewsAttached(views) {
    return await Promise.all(
      views.map(async (view) => {
        return view.attach();
      })
    );
  }
  deduplicate(views) {
    const stale = [];
    const matching = [];
    this.views.forEach((oldView) => {
      const found = views.find((newView) => {
        if (oldView.document == newView.document && oldView.view == newView.view) {
          return true;
        }
      });
      if (found) {
        matching.push(oldView);
        views.remove(found);
      } else {
        stale.push(oldView);
      }
    });
    views.forEach((view) => {
      matching.push(view);
    });
    return [matching, stale];
  }
  async _refreshViews(context, queuedAt) {
    const ctx = `[LiveViews][${context}]`;
    const log = curryLog(ctx, "warn");
    log("Refresh");
    await this.foldersReady();
    let views = [];
    try {
      views = this.getViews();
    } catch (e2) {
      this.warn("[System 3][Relay][Live Views] error getting views", e2);
      return false;
    }
    const activeDocumentFolders = this.findFolders();
    if (activeDocumentFolders.length === 0 && views.length === 0) {
      if (this.extensions.length !== 0) {
        log("Unexpected plugins loaded.");
        this.wipe();
      }
      log("Releasing Views", this.views);
      this.releaseViews(this.views);
      this.views = [];
      return true;
    }
    if (this.loginManager.loggedIn && this.networkStatus.online) {
      activeDocumentFolders.forEach((folder) => {
        folder.connect();
      });
    } else {
      this.sharedFolders.forEach((folder) => {
        folder.disconnect();
      });
    }
    const [matching, stale] = this.deduplicate(views);
    log("Releasing Views", stale);
    this.releaseViews(stale);
    if (stale.length === 0 && ViewsetsEqual(matching, this.views)) {
      const attachedViews = await this.viewsAttachedWithConnectionPool(
        this.views
      );
      log("Attached Views", attachedViews);
    } else {
      const readyViews = await this.viewsReady(matching);
      log("Ready Views", readyViews);
      const attachedViews = await this.viewsAttachedWithConnectionPool(
        readyViews
      );
      log("Attached Views", attachedViews);
      this.views = matching;
    }
    log("loading plugins");
    this.load();
    const now2 = import_obsidian6.moment.utc();
    log(`refresh completed in ${now2.diff(queuedAt)}ms`, ctx);
    return true;
  }
  async refresh(context, timeout = 3e3) {
    const log = curryLog(context, "warn");
    const queuedAt = import_obsidian6.moment.utc();
    this.refreshQueue.push(() => {
      return this._refreshViews(context, queuedAt);
    });
    if (this._activePromise !== null) {
      return false;
    }
    while (this.refreshQueue.length > 0) {
      if (this.refreshQueue.length > 2) {
        log("refreshQueue size:", this.refreshQueue.length);
        this.refreshQueue.slice(-2);
      }
      if (import_obsidian5.Platform.isIosApp) {
        this._activePromise = this.refreshQueue.pop()().finally(() => {
          this._activePromise = null;
        });
        await this._activePromise;
      } else {
        this._activePromise = promiseWithTimeout(
          this.refreshQueue.pop()(),
          timeout
        ).catch((e2) => {
          this.warn(
            `[System 3][Relay][Live Views] refresh views timed out... timeout=${timeout}`,
            e2
          );
          this._activePromise = null;
          return false;
        }).finally(() => {
          this._activePromise = null;
        });
        await this._activePromise;
      }
    }
    return true;
  }
  wipe() {
    this.extensions.length = 0;
    this.workspace.updateOptions();
  }
  load() {
    this.wipe();
    if (this.views.length > 0) {
      this.extensions.push([
        this._compartment.of(connectionManagerFacet.of(this)),
        LiveEdit,
        yRemoteSelectionsTheme,
        yRemoteSelections
      ]);
      this.workspace.updateOptions();
    }
  }
  destroy() {
    this.releaseViews(this.views);
    this.offListeners.forEach((off) => off());
    this.offListeners.length = 0;
    this.folderListeners.forEach((off) => off());
    this.folderListeners.clear();
    this.wipe();
  }
};

// src/obsidian-api/Vault.ts
var import_obsidian7 = require("obsidian");
var import_path_browserify2 = __toESM(require_path_browserify());
var VaultFacade = class extends Observable {
  constructor(app) {
    super();
    this.app = app;
    this.adapter = app.vault.adapter;
  }
  getName() {
    return this.app.vault.getName();
  }
  get root() {
    const adapter = this.app.vault.adapter;
    if (adapter instanceof import_obsidian7.FileSystemAdapter) {
      return adapter.getBasePath();
    }
    throw new Error("Unexpected Adapter");
  }
  fullPath(name) {
    return import_path_browserify2.default.join(this.root, name);
  }
  getFiles() {
    return this.app.vault.getFiles();
  }
  getAbstractFileByPath(path2) {
    return this.app.vault.getAbstractFileByPath(path2);
  }
  getFolderByPath(path2) {
    const maybeFolder = this.app.vault.getAbstractFileByPath(path2);
    if (maybeFolder instanceof import_obsidian7.TFolder) {
      return maybeFolder;
    }
    return null;
  }
  rename(file, newName) {
    this.app.vault.rename(file, newName);
  }
  createFolder(path2) {
    return this.app.vault.createFolder(path2);
  }
  iterateFolders(fn) {
    function iterateFolders(folder) {
      fn(folder);
      folder.children.forEach((child) => {
        if (child instanceof import_obsidian7.TFolder) {
          iterateFolders(child);
        }
      });
    }
    const rootFolder = this.app.vault.getRoot();
    iterateFolders(rootFolder);
  }
};

// src/obsidian-api/Workspace.ts
var import_obsidian8 = require("obsidian");
var WorkspaceFacade = class {
  constructor(workspace) {
    this.workspace = workspace;
  }
  iterateMarkdownViews(fn) {
    this.workspace.iterateAllLeaves((leaf) => {
      if (leaf.view instanceof import_obsidian8.MarkdownView) {
        fn(leaf.view);
      }
    });
  }
  getActiveViewOfType(type) {
    return this.workspace.getActiveViewOfType(type);
  }
  updateOptions() {
    this.workspace.updateOptions();
  }
};

// src/ui/FolderNav.ts
var import_obsidian9 = require("obsidian");

// src/components/Pill.svelte
function add_css2(target) {
  append_styles(target, "svelte-3npei9", ".folder-icons.svelte-3npei9{display:inline-flex;align-items:center;vertical-align:middle;border-radius:var(--radius-m);transition:width 0.3s ease;margin-right:0.6em;padding-left:0.2em;padding-right:0.2em;background-color:var(--color-base-05)}.icon.svelte-3npei9{margin-right:0.2em;margin-left:0.2em;width:1em;display:flex;transition:display 0.3s ease}span.system3-connected.svelte-3npei9{color:var(--color-accent)}span.system3-disconnected.svelte-3npei9{color:var(--color-base-40)}span.notebook.svelte-3npei9{color:var(--color-accent)}span.hidden.svelte-3npei9{display:none}");
}
function create_else_block2(ctx) {
  let span;
  let layers;
  let current;
  layers = new layers_default({
    props: {
      class: "inline-icon",
      style: "width: 0.8em"
    }
  });
  return {
    c() {
      span = element2("span");
      create_component(layers.$$.fragment);
      attr(span, "class", "notebook icon svelte-3npei9");
      attr(span, "aria-label", "Tracking Changes");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      mount_component(layers, span, null);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(layers.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(layers.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      destroy_component(layers);
    }
  };
}
function create_if_block2(ctx) {
  let span0;
  let layers;
  let t2;
  let span1;
  let satellite;
  let span1_class_value;
  let span1_aria_label_value;
  let current;
  layers = new layers_default({
    props: {
      class: "inline-icon",
      style: "width: 0.8em"
    }
  });
  satellite = new satellite_default({ props: { class: "inline-icon" } });
  return {
    c() {
      span0 = element2("span");
      create_component(layers.$$.fragment);
      t2 = space();
      span1 = element2("span");
      create_component(satellite.$$.fragment);
      attr(span0, "class", "notebook icon hidden svelte-3npei9");
      attr(span0, "aria-label", "Tracking Changes");
      attr(span1, "class", span1_class_value = "satellite icon system3-" + /*status*/
      ctx[0] + " svelte-3npei9");
      attr(span1, "aria-label", span1_aria_label_value = `${/*remote*/
      ctx[1].relay.name} (${/*status*/
      ctx[0]})`);
    },
    m(target, anchor) {
      insert(target, span0, anchor);
      mount_component(layers, span0, null);
      insert(target, t2, anchor);
      insert(target, span1, anchor);
      mount_component(satellite, span1, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (!current || dirty & /*status*/
      1 && span1_class_value !== (span1_class_value = "satellite icon system3-" + /*status*/
      ctx2[0] + " svelte-3npei9")) {
        attr(span1, "class", span1_class_value);
      }
      if (!current || dirty & /*remote, status*/
      3 && span1_aria_label_value !== (span1_aria_label_value = `${/*remote*/
      ctx2[1].relay.name} (${/*status*/
      ctx2[0]})`)) {
        attr(span1, "aria-label", span1_aria_label_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(layers.$$.fragment, local);
      transition_in(satellite.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(layers.$$.fragment, local);
      transition_out(satellite.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span0);
        detach(t2);
        detach(span1);
      }
      destroy_component(layers);
      destroy_component(satellite);
    }
  };
}
function create_fragment9(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block2, create_else_block2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*remote*/
      ctx2[1]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element2("div");
      if_block.c();
      attr(div, "class", "folder-icons svelte-3npei9");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance9($$self, $$props, $$invalidate) {
  let { status = "disconnected" } = $$props;
  let { remote } = $$props;
  $$self.$$set = ($$props2) => {
    if ("status" in $$props2)
      $$invalidate(0, status = $$props2.status);
    if ("remote" in $$props2)
      $$invalidate(1, remote = $$props2.remote);
  };
  return [status, remote];
}
var Pill = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance9, create_fragment9, safe_not_equal, { status: 0, remote: 1 }, add_css2);
  }
};
var Pill_default = Pill;

// src/ui/FolderNav.ts
var SiblingWatcher = class {
  constructor(el, onceSibling) {
    this.el = el;
    const observer = new MutationObserver((mutationsList, observer2) => {
      for (const mutation of mutationsList) {
        if (mutation.type === "childList") {
          if (el.nextSibling) {
            onceSibling(el);
            observer2.disconnect();
          }
        }
      }
    });
    observer.observe(el.parentElement, {
      childList: true,
      subtree: true
    });
    this.mutationObserver = observer;
  }
  destroy() {
    var _a2;
    (_a2 = this.mutationObserver) == null ? void 0 : _a2.disconnect();
    this.mutationObserver = null;
  }
};
var BaseVisitor = class {
  visitFolder(folder, item, storage, sharedFolder) {
    return null;
  }
  visitFile(file, item, storage, sharedFolder) {
    return null;
  }
};
var FolderBar = class {
  constructor(el, sharedFolder) {
    this.el = el;
    this.sharedFolder = sharedFolder;
    this.siblingWatcher = new SiblingWatcher(this.el, (el2) => {
      this.add();
    });
    this.add();
  }
  add() {
    var _a2;
    (_a2 = this.el.nextSibling) == null ? void 0 : _a2.addClass("system3-live");
  }
  remove() {
    var _a2;
    (_a2 = this.el.nextSibling) == null ? void 0 : _a2.removeClass("system3-live");
  }
  destroy() {
    this.siblingWatcher.destroy();
    this.remove();
  }
};
var FolderBarVisitor = class extends BaseVisitor {
  visitFolder(folder, item, storage, sharedFolder) {
    if (sharedFolder) {
      return storage || new FolderBar(item.selfEl, sharedFolder);
    }
    if (storage) {
      storage.destroy();
    }
    return null;
  }
};
var PillDecoration = class {
  constructor(el, sharedFolder) {
    this.el = el;
    this.sharedFolder = sharedFolder;
    this.el.addClass("system3-pill");
    this.pill = new Pill_default({
      target: this.el,
      props: {
        status: this.sharedFolder.state.status,
        remote: this.sharedFolder.remote
      }
    });
    this.unsubscribe = this.sharedFolder.subscribe(
      this.el,
      (state) => {
        this.pill.$set({
          status: state.status,
          remote: this.sharedFolder.remote
        });
      }
    );
  }
  destroy() {
    this.pill.$destroy();
    this.unsubscribe();
    this.el.removeClass("system3-pill");
  }
};
var FolderPillVisitor = class extends BaseVisitor {
  visitFolder(folder, item, storage, sharedFolder) {
    if (sharedFolder) {
      return storage || new PillDecoration(item.selfEl, sharedFolder);
    }
    if (storage) {
      storage.destroy();
    }
    return null;
  }
};
var DocumentStatus = class {
  constructor(el, document2, doc2) {
    this.el = el;
    this.document = document2;
    this.document.subscribe(el, (status) => {
      this.docStatus(status);
    });
    this.docStatus(this.document.state);
  }
  docStatus(status) {
    if ((status == null ? void 0 : status.status) === "connected") {
      this.el.removeClass("system3-connecting");
      this.el.addClass("system3-connected");
      this.el.addClass("system3-live");
    } else if ((status == null ? void 0 : status.status) === "connecting") {
      this.el.removeClass("system3-connected");
      this.el.addClass("system3-connecting");
      this.el.addClass("system3-live");
    } else if ((status == null ? void 0 : status.status) === "disconnected") {
      this.el.addClass("system3-live");
      this.el.removeClass("system3-connected");
      this.el.removeClass("system3-connecting");
    } else {
      this.el.removeClass("system3-connected");
      this.el.removeClass("system3-connecting");
      this.el.removeClass("system3-live");
    }
  }
  destroy() {
    var _a2;
    (_a2 = this.document) == null ? void 0 : _a2.unsubscribe(this.el);
    this.docStatus();
  }
};
var FileStatusVisitor = class extends BaseVisitor {
  visitFile(file, item, storage, sharedFolder) {
    if (sharedFolder) {
      try {
        const document2 = sharedFolder.getFile(file.path, false);
        return storage || new DocumentStatus(item.el, document2, file);
      } catch (e2) {
        return null;
      }
    }
    if (storage) {
      storage.destroy();
    }
    return null;
  }
};
var FileExplorerWalker = class {
  constructor(fileExplorer, sharedFolders, visitors) {
    this.fileExplorer = fileExplorer;
    this.sharedFolders = sharedFolders;
    this.visitors = visitors;
    this.storage = /* @__PURE__ */ new Map();
    for (const visitor of this.visitors) {
      this.storage.set(visitor, /* @__PURE__ */ new Map());
    }
  }
  _getFileExplorerItem(path2) {
    return this.fileExplorer.view.fileItems[path2];
  }
  // XXX this is a private API
  getFileExplorerItem(fileExplorer, fileOrFolder) {
    if (typeof fileOrFolder === "string") {
      return this._getFileExplorerItem(fileOrFolder);
    }
    return this._getFileExplorerItem(fileOrFolder.path);
  }
  walk(folder) {
    const sharedFolder = this.sharedFolders.find(
      (sharedFolder2) => sharedFolder2.path === folder.path
    );
    const folderItem = this.getFileExplorerItem(
      this.fileExplorer,
      folder
    );
    if (folderItem) {
      this.storage.forEach((store, visitor) => {
        const stored = store.get(folderItem);
        const update2 = visitor.visitFolder(
          folder,
          folderItem,
          stored,
          sharedFolder
        );
        if (stored && !update2) {
          store.delete(folderItem);
        } else if (update2) {
          store.set(folderItem, update2);
        }
      });
    }
    folder.children.forEach((child) => {
      if (child instanceof import_obsidian9.TFolder) {
        this.walk(child);
      } else if (child instanceof import_obsidian9.TFile) {
        const fileItem = this.getFileExplorerItem(
          this.fileExplorer,
          child
        );
        this.storage.forEach((store, visitor) => {
          const stored = store.get(fileItem);
          const update2 = visitor.visitFile(
            child,
            fileItem,
            stored,
            sharedFolder
          );
          if (stored && !update2) {
            store.delete(fileItem);
          } else if (update2) {
            store.set(fileItem, update2);
          }
        });
      }
    });
  }
  destory() {
    this.storage.forEach((store) => {
      store.forEach((item) => {
        item.destroy();
      });
    });
  }
};
var FolderNavigationDecorations = class {
  constructor(vault, workspace, sharedFolders, showDocumentStatus = false) {
    this.vault = vault;
    this.workspace = workspace;
    this.sharedFolders = sharedFolders;
    this.showDocumentStatus = showDocumentStatus;
    this.treeState = /* @__PURE__ */ new Map();
    this.workspace.onLayoutReady(() => this.refresh());
    this.offDocumentListeners = /* @__PURE__ */ new Map();
    this.offFolderListener = this.sharedFolders.subscribe(() => {
      this.sharedFolders.forEach((folder) => {
        if (showDocumentStatus) {
          const docsetListener = this.offDocumentListeners.get(folder);
          if (!docsetListener) {
            this.offDocumentListeners.set(
              folder,
              folder.docset.on(() => {
                this.refresh();
              })
            );
          }
        }
      });
      this.refresh();
    });
  }
  register() {
    return this.workspace.on("layout-change", () => this.quickRefresh());
  }
  makeVisitors() {
    const visitors = [];
    visitors.push(new FolderBarVisitor());
    visitors.push(new FolderPillVisitor());
    if (this.showDocumentStatus) {
      visitors.push(new FileStatusVisitor());
    }
    return visitors;
  }
  quickRefresh() {
    const fileExplorers = this.workspace.getLeavesOfType("file-explorer");
    const sharedFolders = this.sharedFolders.map((folder) => folder.path);
    for (const fileExplorer of fileExplorers) {
      const walker = this.treeState.get(fileExplorer) || new FileExplorerWalker(
        fileExplorer,
        this.sharedFolders,
        this.makeVisitors()
      );
      this.treeState.set(fileExplorer, walker);
      for (const sharedFolderPath of sharedFolders) {
        const sharedFolder = this.vault.getAbstractFileByPath(sharedFolderPath);
        if (sharedFolder instanceof import_obsidian9.TFolder) {
          walker.walk(sharedFolder);
        }
      }
    }
  }
  refresh() {
    const fileExplorers = this.workspace.getLeavesOfType("file-explorer");
    for (const fileExplorer of fileExplorers) {
      const walker = this.treeState.get(fileExplorer) || new FileExplorerWalker(
        fileExplorer,
        this.sharedFolders,
        this.makeVisitors()
      );
      this.treeState.set(fileExplorer, walker);
      const root = this.vault.getAbstractFileByPath("/");
      if (root instanceof import_obsidian9.TFolder) {
        walker.walk(root);
      }
    }
  }
  destroy() {
    this.offFolderListener();
    this.offDocumentListeners.forEach((off) => off());
    this.treeState.forEach((walker) => {
      walker.destory();
    });
    this.treeState.clear();
  }
};

// src/ui/SettingsTab.ts
var import_obsidian20 = require("obsidian");

// node_modules/tslib/tslib.es6.js
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// src/components/LoggedIn.svelte
var import_obsidian11 = require("obsidian");

// src/components/SettingItem.svelte
function get_each_context2(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i2];
  return child_ctx;
}
var get_description_slot_changes = (dirty) => ({});
var get_description_slot_context = (ctx) => ({});
var get_name_slot_changes = (dirty) => ({});
var get_name_slot_context = (ctx) => ({});
function fallback_block_1(ctx) {
  let t2;
  return {
    c() {
      t2 = text2(
        /*name*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*name*/
      1)
        set_data(
          t2,
          /*name*/
          ctx2[0]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block3(ctx) {
  let each_1_anchor;
  let each_value = ensure_array_like(
    /*itemDescriptionLines*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block2(get_each_context2(ctx, each_value, i2));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*itemDescriptionLines*/
      2) {
        each_value = ensure_array_like(
          /*itemDescriptionLines*/
          ctx2[1]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block2(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block2(ctx) {
  let div;
  return {
    c() {
      div = element2("div");
      div.textContent = `${/*itemDescriptionLine*/
      ctx[5]} `;
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function fallback_block(ctx) {
  let if_block_anchor;
  let if_block = (
    /*itemDescriptionLines*/
    ctx[1].length > 0 && create_if_block3(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (
        /*itemDescriptionLines*/
        ctx2[1].length > 0
      )
        if_block.p(ctx2, dirty);
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_fragment10(ctx) {
  let div4;
  let div2;
  let div0;
  let t0;
  let div1;
  let t1;
  let div3;
  let current;
  const name_slot_template = (
    /*#slots*/
    ctx[4].name
  );
  const name_slot = create_slot(
    name_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    get_name_slot_context
  );
  const name_slot_or_fallback = name_slot || fallback_block_1(ctx);
  const description_slot_template = (
    /*#slots*/
    ctx[4].description
  );
  const description_slot = create_slot(
    description_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    get_description_slot_context
  );
  const description_slot_or_fallback = description_slot || fallback_block(ctx);
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      div4 = element2("div");
      div2 = element2("div");
      div0 = element2("div");
      if (name_slot_or_fallback)
        name_slot_or_fallback.c();
      t0 = space();
      div1 = element2("div");
      if (description_slot_or_fallback)
        description_slot_or_fallback.c();
      t1 = space();
      div3 = element2("div");
      if (default_slot)
        default_slot.c();
      attr(div0, "class", "setting-item-name");
      set_style(div0, "display", "grid");
      set_style(div0, "align-items", "center");
      attr(div1, "class", "setting-item-description");
      attr(div2, "class", "setting-item-info");
      set_style(div2, "display", "grid");
      attr(div3, "class", "setting-item-control");
      attr(div4, "class", "setting-item");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append2(div4, div2);
      append2(div2, div0);
      if (name_slot_or_fallback) {
        name_slot_or_fallback.m(div0, null);
      }
      append2(div2, t0);
      append2(div2, div1);
      if (description_slot_or_fallback) {
        description_slot_or_fallback.m(div1, null);
      }
      append2(div4, t1);
      append2(div4, div3);
      if (default_slot) {
        default_slot.m(div3, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (name_slot) {
        if (name_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            name_slot,
            name_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              name_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              get_name_slot_changes
            ),
            get_name_slot_context
          );
        }
      } else {
        if (name_slot_or_fallback && name_slot_or_fallback.p && (!current || dirty & /*name*/
        1)) {
          name_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (description_slot) {
        if (description_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            description_slot,
            description_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              description_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              get_description_slot_changes
            ),
            get_description_slot_context
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(name_slot_or_fallback, local);
      transition_in(description_slot_or_fallback, local);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(name_slot_or_fallback, local);
      transition_out(description_slot_or_fallback, local);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div4);
      }
      if (name_slot_or_fallback)
        name_slot_or_fallback.d(detaching);
      if (description_slot_or_fallback)
        description_slot_or_fallback.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance10($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { name = "" } = $$props;
  let { description } = $$props;
  const itemDescriptionLines = description !== void 0 ? description.split("\n") : [];
  $$self.$$set = ($$props2) => {
    if ("name" in $$props2)
      $$invalidate(0, name = $$props2.name);
    if ("description" in $$props2)
      $$invalidate(2, description = $$props2.description);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  return [name, itemDescriptionLines, description, $$scope, slots];
}
var SettingItem = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance10, create_fragment10, safe_not_equal, { name: 0, description: 2 });
  }
};
var SettingItem_default = SettingItem;

// src/components/SettingItemHeading.svelte
function create_fragment11(ctx) {
  let div4;
  let div2;
  let div0;
  let t0;
  let t1;
  let div1;
  let t2;
  let t3;
  let div3;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  return {
    c() {
      div4 = element2("div");
      div2 = element2("div");
      div0 = element2("div");
      t0 = text2(
        /*name*/
        ctx[0]
      );
      t1 = space();
      div1 = element2("div");
      t2 = text2(
        /*description*/
        ctx[1]
      );
      t3 = space();
      div3 = element2("div");
      if (default_slot)
        default_slot.c();
      attr(div0, "class", "setting-item-name");
      attr(div1, "class", "setting-item-description");
      attr(div2, "class", "setting-item-info");
      attr(div3, "class", "setting-item-control");
      attr(div4, "class", "setting-item setting-item-heading");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append2(div4, div2);
      append2(div2, div0);
      append2(div0, t0);
      append2(div2, t1);
      append2(div2, div1);
      append2(div1, t2);
      append2(div4, t3);
      append2(div4, div3);
      if (default_slot) {
        default_slot.m(div3, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*name*/
      1)
        set_data(
          t0,
          /*name*/
          ctx2[0]
        );
      if (!current || dirty & /*description*/
      2)
        set_data(
          t2,
          /*description*/
          ctx2[1]
        );
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div4);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance11($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { name } = $$props;
  let { description = "" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("name" in $$props2)
      $$invalidate(0, name = $$props2.name);
    if ("description" in $$props2)
      $$invalidate(1, description = $$props2.description);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  return [name, description, $$scope, slots];
}
var SettingItemHeading = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance11, create_fragment11, safe_not_equal, { name: 0, description: 1 });
  }
};
var SettingItemHeading_default = SettingItemHeading;

// src/components/Callout.svelte
function add_css3(target) {
  append_styles(target, "svelte-11qoyvs", ".callout.svelte-11qoyvs{mix-blend-mode:normal !important}");
}
function create_fragment12(ctx) {
  let div4;
  let div2;
  let div0;
  let t0;
  let div1;
  let t1;
  let t2;
  let div3;
  let p;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  return {
    c() {
      div4 = element2("div");
      div2 = element2("div");
      div0 = element2("div");
      div0.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-pencil"><path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"></path><path d="m15 5 4 4"></path></svg>`;
      t0 = space();
      div1 = element2("div");
      t1 = text2(
        /*title*/
        ctx[0]
      );
      t2 = space();
      div3 = element2("div");
      p = element2("p");
      if (default_slot)
        default_slot.c();
      attr(div0, "class", "callout-icon");
      attr(div0, "dir", "auto");
      attr(div1, "class", "callout-title-inner");
      attr(div1, "dir", "auto");
      attr(div2, "class", "callout-title");
      attr(div2, "dir", "auto");
      attr(p, "dir", "auto");
      attr(div3, "class", "callout-content");
      attr(div3, "dir", "auto");
      attr(div4, "data-callout-metadata", "");
      attr(div4, "data-callout-fold", "");
      attr(div4, "data-callout", "callout");
      attr(div4, "class", "callout svelte-11qoyvs");
      attr(div4, "dir", "auto");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append2(div4, div2);
      append2(div2, div0);
      append2(div2, t0);
      append2(div2, div1);
      append2(div1, t1);
      append2(div4, t2);
      append2(div4, div3);
      append2(div3, p);
      if (default_slot) {
        default_slot.m(p, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*title*/
      1)
        set_data(
          t1,
          /*title*/
          ctx2[0]
        );
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div4);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance12($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { title } = $$props;
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  return [title, $$scope, slots];
}
var Callout = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance12, create_fragment12, safe_not_equal, { title: 0 }, add_css3);
  }
};
var Callout_default = Callout;

// node_modules/svelte/src/runtime/store/index.js
var subscriber_queue = [];
function readable(value, start) {
  return {
    subscribe: writable(value, start).subscribe
  };
}
function writable(value, start = noop) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i2 = 0; i2 < subscriber_queue.length; i2 += 2) {
            subscriber_queue[i2][0](subscriber_queue[i2 + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set(fn(value));
  }
  function subscribe3(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set, update2) || noop;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update: update2, subscribe: subscribe3 };
}
function derived(stores, fn, initial_value) {
  const single = !Array.isArray(stores);
  const stores_array = single ? [stores] : stores;
  if (!stores_array.every(Boolean)) {
    throw new Error("derived() expects stores as input, got a falsy value");
  }
  const auto = fn.length < 2;
  return readable(initial_value, (set, update2) => {
    let started = false;
    const values = [];
    let pending = 0;
    let cleanup = noop;
    const sync = () => {
      if (pending) {
        return;
      }
      cleanup();
      const result = fn(single ? values[0] : values, set, update2);
      if (auto) {
        set(result);
      } else {
        cleanup = is_function(result) ? result : noop;
      }
    };
    const unsubscribers = stores_array.map(
      (store, i2) => subscribe2(
        store,
        (value) => {
          values[i2] = value;
          pending &= ~(1 << i2);
          if (started) {
            sync();
          }
        },
        () => {
          pending |= 1 << i2;
        }
      )
    );
    started = true;
    sync();
    return function stop() {
      run_all(unsubscribers);
      cleanup();
      started = false;
    };
  });
}

// src/customFetch.ts
var import_obsidian10 = require("obsidian");
var ResponsePolyfill = typeof Response !== "undefined" ? Response : class {
  constructor(body, init2) {
    this.body = null;
    this.bodyUsed = false;
    var _a2, _b2;
    this._body = body;
    this.status = (_a2 = init2 == null ? void 0 : init2.status) != null ? _a2 : 200;
    this.statusText = (_b2 = init2 == null ? void 0 : init2.statusText) != null ? _b2 : "";
    this.headers = new Headers(init2 == null ? void 0 : init2.headers);
    this.type = "default";
    this.redirected = false;
    this.ok = this.status >= 200 && this.status < 300;
    this._url = "";
  }
  static error() {
    return new ResponsePolyfill(null, {
      status: 0,
      statusText: ""
    });
  }
  static json(data, init2) {
    const body = JSON.stringify(data);
    return new ResponsePolyfill(body, {
      ...init2,
      headers: {
        ...init2 == null ? void 0 : init2.headers,
        "Content-Type": "application/json"
      }
    });
  }
  static redirect(url, status = 302) {
    if (status < 300 || status > 399) {
      throw new RangeError("Invalid status code");
    }
    return new ResponsePolyfill(null, {
      status,
      headers: { Location: url.toString() }
    });
  }
  get url() {
    return this._url;
  }
  set url(value) {
    this._url = value;
  }
  clone() {
    const cloned = new ResponsePolyfill(this._body, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers)
    });
    cloned._url = this.url;
    return cloned;
  }
  arrayBuffer() {
    return Promise.resolve(
      this._body instanceof ArrayBuffer ? this._body : new ArrayBuffer(0)
    );
  }
  blob() {
    return Promise.resolve(new Blob([this._body]));
  }
  formData() {
    throw new Error(
      "formData() is not implemented in this polyfill"
    );
  }
  json() {
    return Promise.resolve(JSON.parse(this._body));
  }
  text() {
    return Promise.resolve(this._body);
  }
};
var customFetch = async (url, config) => {
  const urlString = url instanceof URL ? url.toString() : url;
  const method = (config == null ? void 0 : config.method) || "GET";
  const requestParams = {
    url: urlString,
    method,
    body: config == null ? void 0 : config.body,
    headers: config == null ? void 0 : config.headers,
    throw: false
  };
  let response = void 0;
  response = await (0, import_obsidian10.requestUrl)(requestParams);
  if (Response === void 0) {
    console.warn("Response is undefined, using polyfill");
    global["Response"] = ResponsePolyfill;
    Response = ResponsePolyfill;
  }
  if (!response.arrayBuffer.byteLength) {
    return new Response(null, {
      status: response.status,
      statusText: response.status.toString(),
      headers: new Headers(response.headers)
    });
  }
  const fetchResponse = new Response(response.arrayBuffer, {
    status: response.status,
    statusText: response.status.toString(),
    headers: new Headers(response.headers)
  });
  const json = async () => JSON.parse(response.text);
  Object.defineProperty(fetchResponse, "json", {
    value: json
  });
  const level = response.status >= 500 ? "error" : response.status >= 400 ? "warn" : "log";
  const response_text = response.text;
  curryLog("[CustomFetch]", level)(
    response.status.toString(),
    method,
    urlString,
    response_text
  );
  if (response.status >= 500) {
    throw new Error(response_text);
  }
  return fetchResponse;
};

// src/components/ObjectState.svelte
function add_css4(target) {
  append_styles(target, "svelte-1h8zaiy", ".object-state-display.svelte-1h8zaiy{padding:10px;margin-top:10px;font-family:monospace}pre.svelte-1h8zaiy{white-space:pre-wrap;word-wrap:break-word}");
}
function create_fragment13(ctx) {
  let div;
  let pre;
  let t0_value = Object.keys(
    /*object*/
    ctx[0]
  ).join("\n") + "";
  let t0;
  let t1;
  return {
    c() {
      div = element2("div");
      pre = element2("pre");
      t0 = text2(t0_value);
      t1 = text2("\n        ");
      attr(pre, "class", "svelte-1h8zaiy");
      attr(div, "class", "object-state-display svelte-1h8zaiy");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append2(div, pre);
      append2(pre, t0);
      append2(pre, t1);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*object*/
      1 && t0_value !== (t0_value = Object.keys(
        /*object*/
        ctx2[0]
      ).join("\n") + ""))
        set_data(t0, t0_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function instance13($$self, $$props, $$invalidate) {
  let { object } = $$props;
  $$self.$$set = ($$props2) => {
    if ("object" in $$props2)
      $$invalidate(0, object = $$props2.object);
  };
  return [object];
}
var ObjectState = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance13, create_fragment13, safe_not_equal, { object: 0 }, add_css4);
  }
};
var ObjectState_default = ObjectState;

// src/components/LoggedIn.svelte
function add_css5(target) {
  append_styles(target, "svelte-1xhkojk", "#login-issues.svelte-1xhkojk{color:var(--color-base-40)}");
}
function create_else_block3(ctx) {
  let settingitemheading;
  let t2;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  settingitemheading = new SettingItemHeading_default({
    props: {
      name: "Account",
      $$slots: { default: [create_default_slot_16] },
      $$scope: { ctx }
    }
  });
  const if_block_creators = [create_if_block_1, create_else_block_2];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (
      /*$automaticFlow*/
      ctx2[3]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_2(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      create_component(settingitemheading.$$.fragment);
      t2 = space();
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(settingitemheading, target, anchor);
      insert(target, t2, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const settingitemheading_changes = {};
      if (dirty[0] & /*$automaticFlow*/
      8 | dirty[1] & /*$$scope*/
      4194304) {
        settingitemheading_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitemheading.$set(settingitemheading_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitemheading.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(settingitemheading.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(if_block_anchor);
      }
      destroy_component(settingitemheading, detaching);
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_if_block4(ctx) {
  var _a2;
  let settingitemheading;
  let t0;
  let settingitem;
  let t1;
  let current;
  settingitemheading = new SettingItemHeading_default({ props: { name: "Account" } });
  settingitem = new SettingItem_default({
    props: {
      name: "Your account",
      description: "You are currently logged in as: " + /*$lm*/
      ((_a2 = ctx[2].user) == null ? void 0 : _a2.name) + ".",
      $$slots: { default: [create_default_slot7] },
      $$scope: { ctx }
    }
  });
  const default_slot_template = (
    /*#slots*/
    ctx[35].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[53],
    null
  );
  return {
    c() {
      create_component(settingitemheading.$$.fragment);
      t0 = space();
      create_component(settingitem.$$.fragment);
      t1 = space();
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      mount_component(settingitemheading, target, anchor);
      insert(target, t0, anchor);
      mount_component(settingitem, target, anchor);
      insert(target, t1, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      var _a3;
      const settingitem_changes = {};
      if (dirty[0] & /*$lm*/
      4)
        settingitem_changes.description = "You are currently logged in as: " + /*$lm*/
        ((_a3 = ctx2[2].user) == null ? void 0 : _a3.name) + ".";
      if (dirty[1] & /*$$scope*/
      4194304) {
        settingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem.$set(settingitem_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        4194304)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[53],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[53]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[53],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitemheading.$$.fragment, local);
      transition_in(settingitem.$$.fragment, local);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(settingitemheading.$$.fragment, local);
      transition_out(settingitem.$$.fragment, local);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
      destroy_component(settingitemheading, detaching);
      destroy_component(settingitem, detaching);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_else_block_3(ctx) {
  let a0;
  let t1;
  let a1;
  let mounted;
  let dispose;
  return {
    c() {
      a0 = element2("a");
      a0.innerHTML = `<span>Back</span>`;
      t1 = text2("\n			|\n			");
      a1 = element2("a");
      a1.innerHTML = `<span><svg width="1em" height="1em" viewBox="0 -28.5 256 256" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" preserveAspectRatio="xMidYMid"><g><path d="M216.856339,16.5966031 C200.285002,8.84328665 182.566144,3.2084988 164.041564,0 C161.766523,4.11318106 159.108624,9.64549908 157.276099,14.0464379 C137.583995,11.0849896 118.072967,11.0849896 98.7430163,14.0464379 C96.9108417,9.64549908 94.1925838,4.11318106 91.8971895,0 C73.3526068,3.2084988 55.6133949,8.86399117 39.0420583,16.6376612 C5.61752293,67.146514 -3.4433191,116.400813 1.08711069,164.955721 C23.2560196,181.510915 44.7403634,191.567697 65.8621325,198.148576 C71.0772151,190.971126 75.7283628,183.341335 79.7352139,175.300261 C72.104019,172.400575 64.7949724,168.822202 57.8887866,164.667963 C59.7209612,163.310589 61.5131304,161.891452 63.2445898,160.431257 C105.36741,180.133187 151.134928,180.133187 192.754523,160.431257 C194.506336,161.891452 196.298154,163.310589 198.110326,164.667963 C191.183787,168.842556 183.854737,172.420929 176.223542,175.320965 C180.230393,183.341335 184.861538,190.991831 190.096624,198.16893 C211.238746,191.588051 232.743023,181.531619 254.911949,164.955721 C260.227747,108.668201 245.831087,59.8662432 216.856339,16.5966031 Z M85.4738752,135.09489 C72.8290281,135.09489 62.4592217,123.290155 62.4592217,108.914901 C62.4592217,94.5396472 72.607595,82.7145587 85.4738752,82.7145587 C98.3405064,82.7145587 108.709962,94.5189427 108.488529,108.914901 C108.508531,123.290155 98.3405064,135.09489 85.4738752,135.09489 Z M170.525237,135.09489 C157.88039,135.09489 147.510584,123.290155 147.510584,108.914901 C147.510584,94.5396472 157.658606,82.7145587 170.525237,82.7145587 C183.391518,82.7145587 193.761324,94.5189427 193.539891,108.914901 C193.539891,123.290155 183.391518,135.09489 170.525237,135.09489 Z" fill="#5865F2" fill-rule="nonzero"></path></g></svg></span>`;
      attr(a0, "href", "#standard");
      attr(a0, "role", "button");
      attr(a0, "tabindex", "0");
      attr(a1, "href", "https://discord.system3.md");
    },
    m(target, anchor) {
      insert(target, a0, anchor);
      insert(target, t1, anchor);
      insert(target, a1, anchor);
      if (!mounted) {
        dispose = [
          listen(
            a0,
            "keydown",
            /*keydown_handler*/
            ctx[39]
          ),
          listen(
            a0,
            "click",
            /*click_handler_2*/
            ctx[40]
          )
        ];
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(a0);
        detach(t1);
        detach(a1);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_5(ctx) {
  let span0;
  let t0;
  let a0;
  let t2;
  let a1;
  let mounted;
  let dispose;
  return {
    c() {
      span0 = element2("span");
      t0 = text2("login issues? try the ");
      a0 = element2("a");
      a0.textContent = "debug flow.";
      t2 = text2("\n			|\n			");
      a1 = element2("a");
      a1.innerHTML = `<span><svg width="1em" height="1em" viewBox="0 -28.5 256 256" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" preserveAspectRatio="xMidYMid"><g><path d="M216.856339,16.5966031 C200.285002,8.84328665 182.566144,3.2084988 164.041564,0 C161.766523,4.11318106 159.108624,9.64549908 157.276099,14.0464379 C137.583995,11.0849896 118.072967,11.0849896 98.7430163,14.0464379 C96.9108417,9.64549908 94.1925838,4.11318106 91.8971895,0 C73.3526068,3.2084988 55.6133949,8.86399117 39.0420583,16.6376612 C5.61752293,67.146514 -3.4433191,116.400813 1.08711069,164.955721 C23.2560196,181.510915 44.7403634,191.567697 65.8621325,198.148576 C71.0772151,190.971126 75.7283628,183.341335 79.7352139,175.300261 C72.104019,172.400575 64.7949724,168.822202 57.8887866,164.667963 C59.7209612,163.310589 61.5131304,161.891452 63.2445898,160.431257 C105.36741,180.133187 151.134928,180.133187 192.754523,160.431257 C194.506336,161.891452 196.298154,163.310589 198.110326,164.667963 C191.183787,168.842556 183.854737,172.420929 176.223542,175.320965 C180.230393,183.341335 184.861538,190.991831 190.096624,198.16893 C211.238746,191.588051 232.743023,181.531619 254.911949,164.955721 C260.227747,108.668201 245.831087,59.8662432 216.856339,16.5966031 Z M85.4738752,135.09489 C72.8290281,135.09489 62.4592217,123.290155 62.4592217,108.914901 C62.4592217,94.5396472 72.607595,82.7145587 85.4738752,82.7145587 C98.3405064,82.7145587 108.709962,94.5189427 108.488529,108.914901 C108.508531,123.290155 98.3405064,135.09489 85.4738752,135.09489 Z M170.525237,135.09489 C157.88039,135.09489 147.510584,123.290155 147.510584,108.914901 C147.510584,94.5396472 157.658606,82.7145587 170.525237,82.7145587 C183.391518,82.7145587 193.761324,94.5189427 193.539891,108.914901 C193.539891,123.290155 183.391518,135.09489 170.525237,135.09489 Z" fill="#5865F2" fill-rule="nonzero"></path></g></svg></span>`;
      attr(a0, "href", "#debug");
      attr(a0, "role", "button");
      attr(a0, "tabindex", "0");
      attr(span0, "id", "login-issues");
      attr(span0, "class", "svelte-1xhkojk");
      attr(a1, "href", "https://discord.system3.md");
    },
    m(target, anchor) {
      insert(target, span0, anchor);
      append2(span0, t0);
      append2(span0, a0);
      insert(target, t2, anchor);
      insert(target, a1, anchor);
      if (!mounted) {
        dispose = [
          listen(
            a0,
            "keypress",
            /*keypress_handler*/
            ctx[37]
          ),
          listen(
            a0,
            "click",
            /*click_handler_1*/
            ctx[38]
          )
        ];
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(span0);
        detach(t2);
        detach(a1);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_default_slot_16(ctx) {
  let if_block_anchor;
  function select_block_type_1(ctx2, dirty) {
    if (
      /*$automaticFlow*/
      ctx2[3]
    )
      return create_if_block_5;
    return create_else_block_3;
  }
  let current_block_type = select_block_type_1(ctx, [-1, -1]);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_1(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
}
function create_else_block_2(ctx) {
  let callout;
  let t0;
  let t1;
  let settingitem0;
  let t2;
  let settingitem1;
  let t3;
  let settingitemheading0;
  let t4;
  let settingitem2;
  let t5;
  let settingitem3;
  let t6;
  let settingitem4;
  let t7;
  let settingitem5;
  let t8;
  let settingitemheading1;
  let t9;
  let objectstate;
  let t10;
  let settingitemheading2;
  let t11;
  let settingitem6;
  let t12;
  let settingitem7;
  let t13;
  let settingitem8;
  let t14;
  let if_block1_anchor;
  let current;
  callout = new Callout_default({
    props: {
      title: "Get Help",
      $$slots: { default: [create_default_slot_15] },
      $$scope: { ctx }
    }
  });
  let if_block0 = (
    /*$error*/
    ctx[5] && create_if_block_4(ctx)
  );
  settingitem0 = new SettingItem_default({
    props: {
      name: "Login",
      description: "Please complete the login flow in your browser and wait a few seconds.",
      $$slots: { default: [create_default_slot_13] },
      $$scope: { ctx }
    }
  });
  settingitem1 = new SettingItem_default({
    props: {
      name: "",
      description: "If your browser doesn't open, you can login manually by\n			visiting this URL in your browser. Clicking will copy the link to your clipboard.",
      $$slots: { default: [create_default_slot_12] },
      $$scope: { ctx }
    }
  });
  settingitemheading0 = new SettingItemHeading_default({
    props: {
      name: "Environment",
      $$slots: { default: [create_default_slot_11] },
      $$scope: { ctx }
    }
  });
  settingitem2 = new SettingItem_default({
    props: {
      name: "User Agent",
      description: "",
      $$slots: { default: [create_default_slot_10] },
      $$scope: { ctx }
    }
  });
  settingitem3 = new SettingItem_default({
    props: {
      name: "Fetch",
      description: "",
      $$slots: { default: [create_default_slot_9] },
      $$scope: { ctx }
    }
  });
  settingitem4 = new SettingItem_default({
    props: {
      name: "Response",
      description: "",
      $$slots: { default: [create_default_slot_8] },
      $$scope: { ctx }
    }
  });
  settingitem5 = new SettingItem_default({
    props: {
      name: "Blink Fetch",
      description: "",
      $$slots: { default: [create_default_slot_7] },
      $$scope: { ctx }
    }
  });
  settingitemheading1 = new SettingItemHeading_default({ props: { name: "Connections" } });
  objectstate = new ObjectState_default({
    props: {
      object: (
        /*$anyPb*/
        ctx[10].cancelControllers
      )
    }
  });
  settingitemheading2 = new SettingItemHeading_default({ props: { name: "Advanced" } });
  settingitem6 = new SettingItem_default({
    props: {
      name: "Patch Fetch API",
      description: "Workaround for Electron fetch API bug.",
      $$slots: { default: [create_default_slot_6] },
      $$scope: { ctx }
    }
  });
  settingitem7 = new SettingItem_default({
    props: {
      name: "Custom fetch",
      description: "Uses requestUrl to avoid CORS preflight checks.",
      $$slots: { default: [create_default_slot_5] },
      $$scope: { ctx }
    }
  });
  settingitem8 = new SettingItem_default({
    props: {
      name: "Debug logs",
      description: "Enable debug logs to help diagnose issues.",
      $$slots: { default: [create_default_slot_4] },
      $$scope: { ctx }
    }
  });
  let if_block1 = (
    /*$timedOut*/
    ctx[13] && create_if_block_3(ctx)
  );
  return {
    c() {
      create_component(callout.$$.fragment);
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      create_component(settingitem0.$$.fragment);
      t2 = space();
      create_component(settingitem1.$$.fragment);
      t3 = space();
      create_component(settingitemheading0.$$.fragment);
      t4 = space();
      create_component(settingitem2.$$.fragment);
      t5 = space();
      create_component(settingitem3.$$.fragment);
      t6 = space();
      create_component(settingitem4.$$.fragment);
      t7 = space();
      create_component(settingitem5.$$.fragment);
      t8 = space();
      create_component(settingitemheading1.$$.fragment);
      t9 = space();
      create_component(objectstate.$$.fragment);
      t10 = space();
      create_component(settingitemheading2.$$.fragment);
      t11 = space();
      create_component(settingitem6.$$.fragment);
      t12 = space();
      create_component(settingitem7.$$.fragment);
      t13 = space();
      create_component(settingitem8.$$.fragment);
      t14 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      mount_component(callout, target, anchor);
      insert(target, t0, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t1, anchor);
      mount_component(settingitem0, target, anchor);
      insert(target, t2, anchor);
      mount_component(settingitem1, target, anchor);
      insert(target, t3, anchor);
      mount_component(settingitemheading0, target, anchor);
      insert(target, t4, anchor);
      mount_component(settingitem2, target, anchor);
      insert(target, t5, anchor);
      mount_component(settingitem3, target, anchor);
      insert(target, t6, anchor);
      mount_component(settingitem4, target, anchor);
      insert(target, t7, anchor);
      mount_component(settingitem5, target, anchor);
      insert(target, t8, anchor);
      mount_component(settingitemheading1, target, anchor);
      insert(target, t9, anchor);
      mount_component(objectstate, target, anchor);
      insert(target, t10, anchor);
      mount_component(settingitemheading2, target, anchor);
      insert(target, t11, anchor);
      mount_component(settingitem6, target, anchor);
      insert(target, t12, anchor);
      mount_component(settingitem7, target, anchor);
      insert(target, t13, anchor);
      mount_component(settingitem8, target, anchor);
      insert(target, t14, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const callout_changes = {};
      if (dirty[1] & /*$$scope*/
      4194304) {
        callout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      callout.$set(callout_changes);
      if (
        /*$error*/
        ctx2[5]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*$error*/
          32) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_4(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      const settingitem0_changes = {};
      if (dirty[0] & /*$url*/
      64 | dirty[1] & /*$$scope*/
      4194304) {
        settingitem0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem0.$set(settingitem0_changes);
      const settingitem1_changes = {};
      if (dirty[0] & /*$url*/
      64 | dirty[1] & /*$$scope*/
      4194304) {
        settingitem1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem1.$set(settingitem1_changes);
      const settingitemheading0_changes = {};
      if (dirty[1] & /*$$scope*/
      4194304) {
        settingitemheading0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitemheading0.$set(settingitemheading0_changes);
      const settingitem2_changes = {};
      if (dirty[1] & /*$$scope*/
      4194304) {
        settingitem2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem2.$set(settingitem2_changes);
      const settingitem3_changes = {};
      if (dirty[0] & /*$fetchImpl*/
      128 | dirty[1] & /*$$scope*/
      4194304) {
        settingitem3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem3.$set(settingitem3_changes);
      const settingitem4_changes = {};
      if (dirty[0] & /*$responseImpl*/
      256 | dirty[1] & /*$$scope*/
      4194304) {
        settingitem4_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem4.$set(settingitem4_changes);
      const settingitem5_changes = {};
      if (dirty[0] & /*$usingBlink*/
      512 | dirty[1] & /*$$scope*/
      4194304) {
        settingitem5_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem5.$set(settingitem5_changes);
      const objectstate_changes = {};
      if (dirty[0] & /*$anyPb*/
      1024)
        objectstate_changes.object = /*$anyPb*/
        ctx2[10].cancelControllers;
      objectstate.$set(objectstate_changes);
      const settingitem6_changes = {};
      if (dirty[0] & /*$patched*/
      2048 | dirty[1] & /*$$scope*/
      4194304) {
        settingitem6_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem6.$set(settingitem6_changes);
      const settingitem7_changes = {};
      if (dirty[0] & /*$useCustomFetch*/
      2 | dirty[1] & /*$$scope*/
      4194304) {
        settingitem7_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem7.$set(settingitem7_changes);
      const settingitem8_changes = {};
      if (dirty[0] & /*$debugLogs*/
      4096 | dirty[1] & /*$$scope*/
      4194304) {
        settingitem8_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem8.$set(settingitem8_changes);
      if (
        /*$timedOut*/
        ctx2[13]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*$timedOut*/
          8192) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_3(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(callout.$$.fragment, local);
      transition_in(if_block0);
      transition_in(settingitem0.$$.fragment, local);
      transition_in(settingitem1.$$.fragment, local);
      transition_in(settingitemheading0.$$.fragment, local);
      transition_in(settingitem2.$$.fragment, local);
      transition_in(settingitem3.$$.fragment, local);
      transition_in(settingitem4.$$.fragment, local);
      transition_in(settingitem5.$$.fragment, local);
      transition_in(settingitemheading1.$$.fragment, local);
      transition_in(objectstate.$$.fragment, local);
      transition_in(settingitemheading2.$$.fragment, local);
      transition_in(settingitem6.$$.fragment, local);
      transition_in(settingitem7.$$.fragment, local);
      transition_in(settingitem8.$$.fragment, local);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(callout.$$.fragment, local);
      transition_out(if_block0);
      transition_out(settingitem0.$$.fragment, local);
      transition_out(settingitem1.$$.fragment, local);
      transition_out(settingitemheading0.$$.fragment, local);
      transition_out(settingitem2.$$.fragment, local);
      transition_out(settingitem3.$$.fragment, local);
      transition_out(settingitem4.$$.fragment, local);
      transition_out(settingitem5.$$.fragment, local);
      transition_out(settingitemheading1.$$.fragment, local);
      transition_out(objectstate.$$.fragment, local);
      transition_out(settingitemheading2.$$.fragment, local);
      transition_out(settingitem6.$$.fragment, local);
      transition_out(settingitem7.$$.fragment, local);
      transition_out(settingitem8.$$.fragment, local);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(t4);
        detach(t5);
        detach(t6);
        detach(t7);
        detach(t8);
        detach(t9);
        detach(t10);
        detach(t11);
        detach(t12);
        detach(t13);
        detach(t14);
        detach(if_block1_anchor);
      }
      destroy_component(callout, detaching);
      if (if_block0)
        if_block0.d(detaching);
      destroy_component(settingitem0, detaching);
      destroy_component(settingitem1, detaching);
      destroy_component(settingitemheading0, detaching);
      destroy_component(settingitem2, detaching);
      destroy_component(settingitem3, detaching);
      destroy_component(settingitem4, detaching);
      destroy_component(settingitem5, detaching);
      destroy_component(settingitemheading1, detaching);
      destroy_component(objectstate, detaching);
      destroy_component(settingitemheading2, detaching);
      destroy_component(settingitem6, detaching);
      destroy_component(settingitem7, detaching);
      destroy_component(settingitem8, detaching);
      if (if_block1)
        if_block1.d(detaching);
    }
  };
}
function create_if_block_1(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_2, create_else_block_1];
  const if_blocks = [];
  function select_block_type_3(ctx2, dirty) {
    if (!/*$pending*/
    ctx2[4])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_3(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_3(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_default_slot_15(ctx) {
  let p;
  return {
    c() {
      p = element2("p");
      p.innerHTML = `We&#39;re working on improving the login process. Please <a href="https://discord.system3.md">join our Discord</a> and we will help you.`;
    },
    m(target, anchor) {
      insert(target, p, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_if_block_4(ctx) {
  let callout;
  let current;
  callout = new Callout_default({
    props: {
      title: "Error",
      $$slots: { default: [create_default_slot_14] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(callout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(callout, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const callout_changes = {};
      if (dirty[0] & /*$error*/
      32 | dirty[1] & /*$$scope*/
      4194304) {
        callout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      callout.$set(callout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(callout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(callout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(callout, detaching);
    }
  };
}
function create_default_slot_14(ctx) {
  let p;
  let t2;
  return {
    c() {
      p = element2("p");
      t2 = text2(
        /*$error*/
        ctx[5]
      );
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append2(p, t2);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$error*/
      32)
        set_data(
          t2,
          /*$error*/
          ctx2[5]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_default_slot_13(ctx) {
  let a;
  let button;
  let t2;
  let button_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      a = element2("a");
      button = element2("button");
      t2 = text2("Login");
      button.disabled = button_disabled_value = /*$url*/
      ctx[6] === "please wait...";
      attr(
        a,
        "href",
        /*$url*/
        ctx[6]
      );
      attr(a, "target", "_blank");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append2(a, button);
      append2(button, t2);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler_5*/
          ctx[43]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$url*/
      64 && button_disabled_value !== (button_disabled_value = /*$url*/
      ctx2[6] === "please wait...")) {
        button.disabled = button_disabled_value;
      }
      if (dirty[0] & /*$url*/
      64) {
        attr(
          a,
          "href",
          /*$url*/
          ctx2[6]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(a);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_12(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element2("input");
      attr(input, "type", "text");
      input.value = /*$url*/
      ctx[6];
      input.readOnly = true;
      set_style(input, "width", "100%");
      attr(input, "id", "system3AuthUrl");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      if (!mounted) {
        dispose = listen(input, "click", (0, import_obsidian11.debounce)(
          /*selectText*/
          ctx[33]
        ));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$url*/
      64 && input.value !== /*$url*/
      ctx2[6]) {
        input.value = /*$url*/
        ctx2[6];
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_11(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element2("button");
      button.textContent = "Refresh";
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", (0, import_obsidian11.debounce)(
          /*click_handler_6*/
          ctx[44]
        ));
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_10(ctx) {
  let t_value = navigator.userAgent + "";
  let t2;
  return {
    c() {
      t2 = text2(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_9(ctx) {
  let t2;
  return {
    c() {
      t2 = text2(
        /*$fetchImpl*/
        ctx[7]
      );
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$fetchImpl*/
      128)
        set_data(
          t2,
          /*$fetchImpl*/
          ctx2[7]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_8(ctx) {
  let t2;
  return {
    c() {
      t2 = text2(
        /*$responseImpl*/
        ctx[8]
      );
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$responseImpl*/
      256)
        set_data(
          t2,
          /*$responseImpl*/
          ctx2[8]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_7(ctx) {
  let t2;
  return {
    c() {
      t2 = text2(
        /*$usingBlink*/
        ctx[9]
      );
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$usingBlink*/
      512)
        set_data(
          t2,
          /*$usingBlink*/
          ctx2[9]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_6(ctx) {
  let button;
  let t2;
  let mounted;
  let dispose;
  return {
    c() {
      button = element2("button");
      t2 = text2("Patch");
      button.disabled = /*$patched*/
      ctx[11];
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append2(button, t2);
      if (!mounted) {
        dispose = listen(button, "click", (0, import_obsidian11.debounce)(
          /*click_handler_7*/
          ctx[45]
        ));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$patched*/
      2048) {
        button.disabled = /*$patched*/
        ctx2[11];
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_5(ctx) {
  let div;
  let input;
  let div_class_value;
  let mounted;
  let dispose;
  return {
    c() {
      div = element2("div");
      input = element2("input");
      attr(input, "type", "checkbox");
      attr(input, "tabindex", "0");
      attr(div, "aria-label", "custom fetch can help avoid some network restrictions");
      attr(div, "role", "checkbox");
      attr(
        div,
        "aria-checked",
        /*$useCustomFetch*/
        ctx[1]
      );
      attr(div, "tabindex", "0");
      attr(div, "class", div_class_value = "checkbox-container mod-small " + /*$useCustomFetch*/
      (ctx[1] ? "is-enabled" : ""));
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append2(div, input);
      input.checked = /*$useCustomFetch*/
      ctx[1];
      if (!mounted) {
        dispose = [
          listen(
            input,
            "change",
            /*input_change_handler*/
            ctx[46]
          ),
          listen(
            div,
            "click",
            /*click_handler_8*/
            ctx[47]
          ),
          listen(div, "keydown", function() {
            if (is_function((0, import_obsidian11.debounce)(
              /*keydown_handler_1*/
              ctx[48]
            )))
              (0, import_obsidian11.debounce)(
                /*keydown_handler_1*/
                ctx[48]
              ).apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*$useCustomFetch*/
      2) {
        input.checked = /*$useCustomFetch*/
        ctx[1];
      }
      if (dirty[0] & /*$useCustomFetch*/
      2) {
        attr(
          div,
          "aria-checked",
          /*$useCustomFetch*/
          ctx[1]
        );
      }
      if (dirty[0] & /*$useCustomFetch*/
      2 && div_class_value !== (div_class_value = "checkbox-container mod-small " + /*$useCustomFetch*/
      (ctx[1] ? "is-enabled" : ""))) {
        attr(div, "class", div_class_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_default_slot_4(ctx) {
  let div;
  let input;
  let div_class_value;
  let mounted;
  let dispose;
  return {
    c() {
      div = element2("div");
      input = element2("input");
      attr(input, "type", "checkbox");
      attr(input, "tabindex", "0");
      attr(div, "aria-label", "custom fetch can help avoid some network restrictions");
      attr(div, "role", "checkbox");
      attr(
        div,
        "aria-checked",
        /*$debugLogs*/
        ctx[12]
      );
      attr(div, "tabindex", "0");
      attr(div, "class", div_class_value = "checkbox-container mod-small " + /*$debugLogs*/
      (ctx[12] ? "is-enabled" : ""));
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append2(div, input);
      input.checked = /*$debugLogs*/
      ctx[12];
      if (!mounted) {
        dispose = [
          listen(
            input,
            "change",
            /*input_change_handler_1*/
            ctx[49]
          ),
          listen(
            div,
            "click",
            /*click_handler_9*/
            ctx[50]
          ),
          listen(div, "keydown", (0, import_obsidian11.debounce)(
            /*keydown_handler_2*/
            ctx[51]
          ))
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$debugLogs*/
      4096) {
        input.checked = /*$debugLogs*/
        ctx2[12];
      }
      if (dirty[0] & /*$debugLogs*/
      4096) {
        attr(
          div,
          "aria-checked",
          /*$debugLogs*/
          ctx2[12]
        );
      }
      if (dirty[0] & /*$debugLogs*/
      4096 && div_class_value !== (div_class_value = "checkbox-container mod-small " + /*$debugLogs*/
      (ctx2[12] ? "is-enabled" : ""))) {
        attr(div, "class", div_class_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_3(ctx) {
  let settingitem;
  let current;
  settingitem = new SettingItem_default({
    props: {
      name: "Check",
      description: "Click here once you've completed login",
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const settingitem_changes = {};
      if (dirty[1] & /*$$scope*/
      4194304) {
        settingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem.$set(settingitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem, detaching);
    }
  };
}
function create_default_slot_3(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element2("button");
      button.textContent = "Check";
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", (0, import_obsidian11.debounce)(
          /*click_handler_10*/
          ctx[52]
        ));
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_else_block_1(ctx) {
  let settingitem;
  let current;
  settingitem = new SettingItem_default({
    props: {
      name: "Login",
      description: "Please complete the login flow in your browser and wait a few seconds.",
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const settingitem_changes = {};
      if (dirty[1] & /*$$scope*/
      4194304) {
        settingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem.$set(settingitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem, detaching);
    }
  };
}
function create_if_block_2(ctx) {
  let settingitem;
  let current;
  settingitem = new SettingItem_default({
    props: {
      name: "Login",
      description: "You need to login to use this plugin.",
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const settingitem_changes = {};
      if (dirty[1] & /*$$scope*/
      4194304) {
        settingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem.$set(settingitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem, detaching);
    }
  };
}
function create_default_slot_2(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element2("button");
      button.textContent = "Cancel";
      attr(button, "class", "mod-destructive");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", (0, import_obsidian11.debounce)(
          /*click_handler_4*/
          ctx[42]
        ));
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_1(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element2("button");
      button.textContent = "Login with Google";
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", (0, import_obsidian11.debounce)(
          /*click_handler_3*/
          ctx[41]
        ));
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot7(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element2("button");
      button.textContent = "Logout";
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", (0, import_obsidian11.debounce)(
          /*click_handler*/
          ctx[36]
        ));
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment14(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block4, create_else_block3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$lm*/
      ctx2[2].hasUser
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function patchFetch() {
  if (!globalThis) {
    console.warn("unable to patch fetch, global is not defined");
  }
  if (globalThis.blinkfetch) {
    console.warn("Using blinkFetch everywhere");
    globalThis.fetch = globalThis.blinkFetch;
    const keys2 = ["fetch", "Response", "FormData", "Request", "Headers"];
    for (const key of keys2) {
      globalThis[key] = globalThis[`blink${key}`];
    }
  }
}
function instance14($$self, $$props, $$invalidate) {
  let $useCustomFetch;
  let $lm, $$unsubscribe_lm = noop, $$subscribe_lm = () => ($$unsubscribe_lm(), $$unsubscribe_lm = subscribe2(lm, ($$value) => $$invalidate(2, $lm = $$value)), lm);
  let $automaticFlow;
  let $pending;
  let $error;
  let $url;
  let $fetchImpl;
  let $responseImpl;
  let $usingBlink;
  let $anyPb;
  let $patched;
  let $debugLogs;
  let $timedOut;
  $$self.$$.on_destroy.push(() => $$unsubscribe_lm());
  let { $$slots: slots = {}, $$scope } = $$props;
  let { plugin } = $$props;
  let lm;
  let automaticFlow = writable(true);
  component_subscribe($$self, automaticFlow, (value) => $$invalidate(3, $automaticFlow = value));
  let pending = writable(false);
  component_subscribe($$self, pending, (value) => $$invalidate(4, $pending = value));
  $$subscribe_lm(lm = plugin.loginManager);
  let timedOut = writable(false);
  component_subscribe($$self, timedOut, (value) => $$invalidate(13, $timedOut = value));
  let success = writable(false);
  let showLink = writable(false);
  let useCustomFetch = writable(true);
  component_subscribe($$self, useCustomFetch, (value) => $$invalidate(1, $useCustomFetch = value));
  let url = writable("please wait...");
  component_subscribe($$self, url, (value) => $$invalidate(6, $url = value));
  let provider;
  let authWithCode;
  let error = writable("");
  component_subscribe($$self, error, (value) => $$invalidate(5, $error = value));
  let debugLogs = writable(plugin.settings.debugging);
  component_subscribe($$self, debugLogs, (value) => $$invalidate(12, $debugLogs = value));
  function toggleDebug() {
    debugLogs.set(plugin.toggleDebugging(true));
  }
  function logout() {
    return __awaiter(this, void 0, void 0, function* () {
      yield plugin.loginManager.logout();
      success.set(false);
      timedOut.set(false);
    });
  }
  function login() {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        yield plugin.loginManager.login();
      } catch (e2) {
        automaticFlow.set(false);
        success.set(false);
      }
    });
  }
  let patched = writable(false);
  component_subscribe($$self, patched, (value) => $$invalidate(11, $patched = value));
  const responseImpl = writable(Response.toString());
  component_subscribe($$self, responseImpl, (value) => $$invalidate(8, $responseImpl = value));
  const fetchImpl = writable(fetch.toString());
  component_subscribe($$self, fetchImpl, (value) => $$invalidate(7, $fetchImpl = value));
  const usingBlink = writable((globalThis === null || globalThis === void 0 ? void 0 : globalThis.blinkfetch) !== void 0 ? "Yes" : "No");
  component_subscribe($$self, usingBlink, (value) => $$invalidate(9, $usingBlink = value));
  const anyPb = writable(plugin.loginManager.pb);
  component_subscribe($$self, anyPb, (value) => $$invalidate(10, $anyPb = value));
  function refresh2() {
    responseImpl.set(Response.toString());
    fetchImpl.set(fetch.toString());
    usingBlink.set((globalThis === null || globalThis === void 0 ? void 0 : globalThis.blinkfetch) !== void 0 ? "Yes" : "No");
    anyPb.set(plugin.loginManager.pb);
  }
  function initiate() {
    try {
      const whichFetch = $useCustomFetch ? customFetch : fetch;
      provider = void 0;
      url.set("please wait...");
      lm.initiateManualOAuth2CodeFlow(whichFetch).then(([url_, provider_, authWithCode_]) => {
        provider = provider_;
        authWithCode = authWithCode_;
        url.set(url_);
      }).catch((e2) => {
        let message = e2.message;
        message = message + "\n" + typeof Response;
        message = message + "\n" + Response.toString();
        error.set(message);
        throw e2;
      });
    } catch (e2) {
      error.set(e2.message);
    }
  }
  onMount(() => {
    success.set(false);
    initiate();
  });
  function poll() {
    return __awaiter(this, void 0, void 0, function* () {
      if (!provider || !authWithCode) {
        return;
      }
      return yield plugin.loginManager.poll(provider, authWithCode).then((authRecord) => {
        success.set(true);
        error.set("");
      }).catch((e2) => {
        timedOut.set(true);
        success.set(false);
        error.set(e2.message);
      });
    });
  }
  function selectText(event) {
    const inputEl = event.target;
    inputEl.focus();
    inputEl.select();
    navigator.clipboard.writeText(inputEl.value).then(() => new import_obsidian11.Notice("Invite link copied")).catch((err) => {
    });
    poll();
  }
  const click_handler = () => {
    logout();
  };
  const keypress_handler = (e2) => {
    if (e2.key === "Enter") {
      set_store_value(automaticFlow, $automaticFlow = !$automaticFlow, $automaticFlow);
    }
  };
  const click_handler_1 = () => {
    set_store_value(automaticFlow, $automaticFlow = !$automaticFlow, $automaticFlow);
  };
  const keydown_handler = (e2) => {
    if (e2.key === "Enter") {
      set_store_value(automaticFlow, $automaticFlow = !$automaticFlow, $automaticFlow);
    }
  };
  const click_handler_2 = () => {
    set_store_value(automaticFlow, $automaticFlow = !$automaticFlow, $automaticFlow);
  };
  const click_handler_3 = async () => {
    await login();
  };
  const click_handler_4 = () => {
    pending.set(false);
  };
  const click_handler_5 = () => {
    showLink.set(true);
    poll();
  };
  const click_handler_6 = () => {
    refresh2();
  };
  const click_handler_7 = () => {
    patchFetch();
    refresh2();
    patched.set(true);
  };
  function input_change_handler() {
    $useCustomFetch = this.checked;
    useCustomFetch.set($useCustomFetch);
  }
  const click_handler_8 = () => {
    useCustomFetch.set(!$useCustomFetch);
    initiate();
  };
  const keydown_handler_1 = (e2) => {
    if (e2.key === "Enter") {
      useCustomFetch.set(!$useCustomFetch);
      initiate();
    }
  };
  function input_change_handler_1() {
    $debugLogs = this.checked;
    debugLogs.set($debugLogs);
  }
  const click_handler_9 = () => {
    toggleDebug();
  };
  const keydown_handler_2 = (e2) => {
    if (e2.key === "Enter") {
      toggleDebug();
    }
  };
  const click_handler_10 = () => {
    poll();
  };
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(34, plugin = $$props2.plugin);
    if ("$$scope" in $$props2)
      $$invalidate(53, $$scope = $$props2.$$scope);
  };
  return [
    lm,
    $useCustomFetch,
    $lm,
    $automaticFlow,
    $pending,
    $error,
    $url,
    $fetchImpl,
    $responseImpl,
    $usingBlink,
    $anyPb,
    $patched,
    $debugLogs,
    $timedOut,
    automaticFlow,
    pending,
    timedOut,
    showLink,
    useCustomFetch,
    url,
    error,
    debugLogs,
    toggleDebug,
    logout,
    login,
    patched,
    responseImpl,
    fetchImpl,
    usingBlink,
    anyPb,
    refresh2,
    initiate,
    poll,
    selectText,
    plugin,
    slots,
    click_handler,
    keypress_handler,
    click_handler_1,
    keydown_handler,
    click_handler_2,
    click_handler_3,
    click_handler_4,
    click_handler_5,
    click_handler_6,
    click_handler_7,
    input_change_handler,
    click_handler_8,
    keydown_handler_1,
    input_change_handler_1,
    click_handler_9,
    keydown_handler_2,
    click_handler_10,
    $$scope
  ];
}
var LoggedIn = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance14, create_fragment14, safe_not_equal, { plugin: 34 }, add_css5, [-1, -1]);
  }
};
var LoggedIn_default = LoggedIn;

// src/components/SettingsControl.svelte
function create_fragment15(ctx) {
  let div;
  let settings;
  let current;
  let mounted;
  let dispose;
  settings = new settings_default({
    props: {
      class: "svg-icon lucide-settings",
      props: { class: "svg-icon lucide-settings" }
    }
  });
  return {
    c() {
      div = element2("div");
      create_component(settings.$$.fragment);
      attr(div, "class", "clickable-icon extra-setting-button");
      attr(div, "aria-label", "Options");
      attr(div, "role", "button");
      attr(div, "tabindex", "0");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(settings, div, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            div,
            "click",
            /*handleSettingsClick*/
            ctx[0]
          ),
          listen(
            div,
            "keydown",
            /*handleSettingsClick*/
            ctx[0]
          )
        ];
        mounted = true;
      }
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(settings.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settings.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(settings);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance15($$self) {
  const dispatch = createEventDispatcher();
  function handleSettingsClick(event) {
    if (event instanceof MouseEvent || event instanceof KeyboardEvent && (event.key === "Enter" || event.key === " ")) {
      dispatch("settings");
    }
  }
  return [handleSettingsClick];
}
var SettingsControl = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance15, create_fragment15, safe_not_equal, {});
  }
};
var SettingsControl_default = SettingsControl;

// src/components/SharedFolderSpan.svelte
function create_if_block5(ctx) {
  let arrowrightleft;
  let t0;
  let satellite;
  let t1_value = (
    /*folder*/
    ctx[0].remote.relay.name + ""
  );
  let t1;
  let current;
  arrowrightleft = new arrow_right_left_default({
    props: {
      class: "svg-icon",
      style: "margin: 0 1em"
    }
  });
  satellite = new satellite_default({ props: { class: "svg-icon" } });
  return {
    c() {
      create_component(arrowrightleft.$$.fragment);
      t0 = space();
      create_component(satellite.$$.fragment);
      t1 = text2(t1_value);
    },
    m(target, anchor) {
      mount_component(arrowrightleft, target, anchor);
      insert(target, t0, anchor);
      mount_component(satellite, target, anchor);
      insert(target, t1, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty & /*folder*/
      1) && t1_value !== (t1_value = /*folder*/
      ctx2[0].remote.relay.name + ""))
        set_data(t1, t1_value);
    },
    i(local) {
      if (current)
        return;
      transition_in(arrowrightleft.$$.fragment, local);
      transition_in(satellite.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(arrowrightleft.$$.fragment, local);
      transition_out(satellite.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
      destroy_component(arrowrightleft, detaching);
      destroy_component(satellite, detaching);
    }
  };
}
function create_fragment16(ctx) {
  let span;
  let folder_1;
  let t0_value = (
    /*folder*/
    ctx[0].name + ""
  );
  let t0;
  let t1;
  let current;
  folder_1 = new folder_default({
    props: {
      class: "svg-icon",
      style: "margin-right: .2em; width: 1em;"
    }
  });
  let if_block = (
    /*folder*/
    ctx[0].remote && create_if_block5(ctx)
  );
  return {
    c() {
      span = element2("span");
      create_component(folder_1.$$.fragment);
      t0 = text2(t0_value);
      t1 = space();
      if (if_block)
        if_block.c();
      set_style(span, "display", "inline-flex");
      set_style(span, "align-items", "center");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      mount_component(folder_1, span, null);
      append2(span, t0);
      append2(span, t1);
      if (if_block)
        if_block.m(span, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & /*folder*/
      1) && t0_value !== (t0_value = /*folder*/
      ctx2[0].name + ""))
        set_data(t0, t0_value);
      if (
        /*folder*/
        ctx2[0].remote
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*folder*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block5(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(span, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(folder_1.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(folder_1.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      destroy_component(folder_1);
      if (if_block)
        if_block.d();
    }
  };
}
function instance16($$self, $$props, $$invalidate) {
  let { folder } = $$props;
  $$self.$$set = ($$props2) => {
    if ("folder" in $$props2)
      $$invalidate(0, folder = $$props2.folder);
  };
  return [folder];
}
var SharedFolderSpan = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance16, create_fragment16, safe_not_equal, { folder: 0 });
  }
};
var SharedFolderSpan_default = SharedFolderSpan;

// src/components/Relays.svelte
var import_obsidian12 = require("obsidian");
function add_css6(target) {
  append_styles(target, "svelte-18nm1sp", "input.system3-input-invalid.svelte-18nm1sp{border:1px solid var(--color-red) !important}");
}
function get_each_context3(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[18] = list[i2];
  return child_ctx;
}
function get_each_context_1(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[21] = list[i2];
  return child_ctx;
}
function create_default_slot_32(ctx) {
  let input;
  let input_class_value;
  let t0;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      input = element2("input");
      t0 = space();
      button = element2("button");
      button.textContent = "Join relay";
      attr(input, "type", "text");
      attr(input, "placeholder", "Enter share key");
      attr(input, "class", input_class_value = null_to_empty(
        /*invalidShareKey*/
        ctx[2] ? "system3-input-invalid" : ""
      ) + " svelte-18nm1sp");
      attr(button, "class", "mod-cta");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(
        input,
        /*shareKey*/
        ctx[1]
      );
      insert(target, t0, anchor);
      insert(target, button, anchor);
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[12]
          ),
          listen(
            input,
            "input",
            /*handleShareKeyInput*/
            ctx[8]
          ),
          listen(button, "click", function() {
            if (is_function((0, import_obsidian12.debounce)(
              /*click_handler*/
              ctx[13]
            )))
              (0, import_obsidian12.debounce)(
                /*click_handler*/
                ctx[13]
              ).apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*invalidShareKey*/
      4 && input_class_value !== (input_class_value = null_to_empty(
        /*invalidShareKey*/
        ctx[2] ? "system3-input-invalid" : ""
      ) + " svelte-18nm1sp")) {
        attr(input, "class", input_class_value);
      }
      if (dirty & /*shareKey*/
      2 && input.value !== /*shareKey*/
      ctx[1]) {
        set_input_value(
          input,
          /*shareKey*/
          ctx[1]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
        detach(t0);
        detach(button);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_default_slot_22(ctx) {
  let settingscontrol;
  let current;
  function settings_handler() {
    return (
      /*settings_handler*/
      ctx[14](
        /*relay*/
        ctx[21]
      )
    );
  }
  settingscontrol = new SettingsControl_default({});
  settingscontrol.$on("settings", settings_handler);
  return {
    c() {
      create_component(settingscontrol.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingscontrol, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    i(local) {
      if (current)
        return;
      transition_in(settingscontrol.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingscontrol.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingscontrol, detaching);
    }
  };
}
function create_name_slot_1(ctx) {
  let span;
  let satellite;
  let t_value = (
    /*relay*/
    ctx[21].name + ""
  );
  let t2;
  let current;
  satellite = new satellite_default({ props: { class: "svg-icon" } });
  return {
    c() {
      span = element2("span");
      create_component(satellite.$$.fragment);
      t2 = text2(t_value);
      attr(span, "slot", "name");
      set_style(span, "display", "inline-flex");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      mount_component(satellite, span, null);
      append2(span, t2);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty & /*$relays*/
      8) && t_value !== (t_value = /*relay*/
      ctx2[21].name + ""))
        set_data(t2, t_value);
    },
    i(local) {
      if (current)
        return;
      transition_in(satellite.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(satellite.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      destroy_component(satellite);
    }
  };
}
function create_each_block_1(ctx) {
  let settingitem;
  let current;
  settingitem = new SettingItem_default({
    props: {
      description: "",
      $$slots: {
        name: [create_name_slot_1],
        default: [create_default_slot_22]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const settingitem_changes = {};
      if (dirty & /*$$scope, $relays*/
      16777224) {
        settingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem.$set(settingitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem, detaching);
    }
  };
}
function create_default_slot_17(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element2("button");
      button.textContent = "New relay";
      attr(button, "class", "mod-cta");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", (0, import_obsidian12.debounce)(
          /*click_handler_1*/
          ctx[15]
        ));
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot8(ctx) {
  let settingscontrol;
  let t2;
  let current;
  function settings_handler_1() {
    return (
      /*settings_handler_1*/
      ctx[16](
        /*folder*/
        ctx[18]
      )
    );
  }
  settingscontrol = new SettingsControl_default({});
  settingscontrol.$on("settings", function() {
    if (is_function((0, import_obsidian12.debounce)(settings_handler_1)))
      (0, import_obsidian12.debounce)(settings_handler_1).apply(this, arguments);
  });
  return {
    c() {
      create_component(settingscontrol.$$.fragment);
      t2 = space();
    },
    m(target, anchor) {
      mount_component(settingscontrol, target, anchor);
      insert(target, t2, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    i(local) {
      if (current)
        return;
      transition_in(settingscontrol.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingscontrol.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(settingscontrol, detaching);
    }
  };
}
function create_name_slot(ctx) {
  let sharedfolderspan;
  let current;
  sharedfolderspan = new SharedFolderSpan_default({
    props: { folder: (
      /*folder*/
      ctx[18]
    ), slot: "name" }
  });
  return {
    c() {
      create_component(sharedfolderspan.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sharedfolderspan, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sharedfolderspan_changes = {};
      if (dirty & /*$sharedFolders*/
      16)
        sharedfolderspan_changes.folder = /*folder*/
        ctx2[18];
      sharedfolderspan.$set(sharedfolderspan_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sharedfolderspan.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sharedfolderspan.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sharedfolderspan, detaching);
    }
  };
}
function create_each_block3(ctx) {
  let settingitem;
  let current;
  settingitem = new SettingItem_default({
    props: {
      description: "",
      $$slots: {
        name: [create_name_slot],
        default: [create_default_slot8]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const settingitem_changes = {};
      if (dirty & /*$$scope, $sharedFolders, $relays*/
      16777240) {
        settingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem.$set(settingitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem, detaching);
    }
  };
}
function create_fragment17(ctx) {
  let settingitemheading0;
  let t0;
  let settingitem0;
  let t1;
  let settingitemheading1;
  let t2;
  let t3;
  let settingitem1;
  let t4;
  let settingitemheading2;
  let t5;
  let each1_anchor;
  let current;
  settingitemheading0 = new SettingItemHeading_default({
    props: { name: "Join a relay", description: "" }
  });
  settingitem0 = new SettingItem_default({
    props: {
      name: "Share key",
      description: "Enter the code that was shared with you.",
      $$slots: { default: [create_default_slot_32] },
      $$scope: { ctx }
    }
  });
  settingitemheading1 = new SettingItemHeading_default({ props: { name: "Relays" } });
  let each_value_1 = ensure_array_like(
    /*$relays*/
    ctx[3].values().sort(sortFn)
  );
  let each_blocks_1 = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks_1[i2] = create_each_block_1(get_each_context_1(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks_1[i2], 1, 1, () => {
    each_blocks_1[i2] = null;
  });
  settingitem1 = new SettingItem_default({
    props: {
      name: "",
      description: "",
      $$slots: { default: [create_default_slot_17] },
      $$scope: { ctx }
    }
  });
  settingitemheading2 = new SettingItemHeading_default({ props: { name: "Shared folders" } });
  let each_value = ensure_array_like(
    /*$sharedFolders*/
    ctx[4].items()
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block3(get_each_context3(ctx, each_value, i2));
  }
  const out_1 = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      create_component(settingitemheading0.$$.fragment);
      t0 = space();
      create_component(settingitem0.$$.fragment);
      t1 = space();
      create_component(settingitemheading1.$$.fragment);
      t2 = space();
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        each_blocks_1[i2].c();
      }
      t3 = space();
      create_component(settingitem1.$$.fragment);
      t4 = space();
      create_component(settingitemheading2.$$.fragment);
      t5 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each1_anchor = empty();
    },
    m(target, anchor) {
      mount_component(settingitemheading0, target, anchor);
      insert(target, t0, anchor);
      mount_component(settingitem0, target, anchor);
      insert(target, t1, anchor);
      mount_component(settingitemheading1, target, anchor);
      insert(target, t2, anchor);
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        if (each_blocks_1[i2]) {
          each_blocks_1[i2].m(target, anchor);
        }
      }
      insert(target, t3, anchor);
      mount_component(settingitem1, target, anchor);
      insert(target, t4, anchor);
      mount_component(settingitemheading2, target, anchor);
      insert(target, t5, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each1_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const settingitem0_changes = {};
      if (dirty & /*$$scope, shareKey, invalidShareKey*/
      16777222) {
        settingitem0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem0.$set(settingitem0_changes);
      if (dirty & /*$relays, sortFn, handleManageRelay*/
      72) {
        each_value_1 = ensure_array_like(
          /*$relays*/
          ctx2[3].values().sort(sortFn)
        );
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i2);
          if (each_blocks_1[i2]) {
            each_blocks_1[i2].p(child_ctx, dirty);
            transition_in(each_blocks_1[i2], 1);
          } else {
            each_blocks_1[i2] = create_each_block_1(child_ctx);
            each_blocks_1[i2].c();
            transition_in(each_blocks_1[i2], 1);
            each_blocks_1[i2].m(t3.parentNode, t3);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks_1.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      const settingitem1_changes = {};
      if (dirty & /*$$scope*/
      16777216) {
        settingitem1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem1.$set(settingitem1_changes);
      if (dirty & /*$sharedFolders, $relays, handleManageSharedFolder*/
      152) {
        each_value = ensure_array_like(
          /*$sharedFolders*/
          ctx2[4].items()
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context3(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block3(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each1_anchor.parentNode, each1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out_1(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitemheading0.$$.fragment, local);
      transition_in(settingitem0.$$.fragment, local);
      transition_in(settingitemheading1.$$.fragment, local);
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks_1[i2]);
      }
      transition_in(settingitem1.$$.fragment, local);
      transition_in(settingitemheading2.$$.fragment, local);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      transition_out(settingitemheading0.$$.fragment, local);
      transition_out(settingitem0.$$.fragment, local);
      transition_out(settingitemheading1.$$.fragment, local);
      each_blocks_1 = each_blocks_1.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        transition_out(each_blocks_1[i2]);
      }
      transition_out(settingitem1.$$.fragment, local);
      transition_out(settingitemheading2.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(t4);
        detach(t5);
        detach(each1_anchor);
      }
      destroy_component(settingitemheading0, detaching);
      destroy_component(settingitem0, detaching);
      destroy_component(settingitemheading1, detaching);
      destroy_each(each_blocks_1, detaching);
      destroy_component(settingitem1, detaching);
      destroy_component(settingitemheading2, detaching);
      destroy_each(each_blocks, detaching);
    }
  };
}
function sortFn(a, b) {
  if (a.owner && !b.owner) {
    return -1;
  }
  if (b.owner && !a.owner) {
    return 1;
  }
  return a.name > b.name ? 1 : -1;
}
function instance17($$self, $$props, $$invalidate) {
  let $relays, $$unsubscribe_relays = noop, $$subscribe_relays = () => ($$unsubscribe_relays(), $$unsubscribe_relays = subscribe2(relays, ($$value) => $$invalidate(3, $relays = $$value)), relays);
  let $sharedFolders;
  $$self.$$.on_destroy.push(() => $$unsubscribe_relays());
  let { plugin } = $$props;
  let { relays } = $$props;
  $$subscribe_relays();
  const sharedFolders = plugin.sharedFolders;
  component_subscribe($$self, sharedFolders, (value) => $$invalidate(4, $sharedFolders = value));
  let shareKey = "";
  let invalidShareKey = false;
  const dispatch = createEventDispatcher();
  function handleManageRelay(relay) {
    if (!relay) {
      return;
    }
    dispatch("manageRelay", { relay });
  }
  function handleManageSharedFolder(folder, relay) {
    if (!folder) {
      return;
    }
    dispatch("manageSharedFolder", { folder, relay });
  }
  function handleShareKeyInput() {
    $$invalidate(2, invalidShareKey = false);
  }
  function handleJoinRelayFromInvite(shareKey2) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const relay = yield plugin.relayManager.acceptInvitation(shareKey2);
        dispatch("joinRelay", { relay });
      } catch (e2) {
        $$invalidate(2, invalidShareKey = true);
      }
    });
  }
  function handleCreateRelay() {
    dispatch("createRelay");
  }
  function input_input_handler() {
    shareKey = this.value;
    $$invalidate(1, shareKey);
  }
  const click_handler = () => handleJoinRelayFromInvite(shareKey);
  const settings_handler = (relay) => {
    handleManageRelay(relay);
  };
  const click_handler_1 = () => handleCreateRelay();
  const settings_handler_1 = (folder) => {
    const relay = $relays.values().find((relay2) => {
      var _a2;
      return ((_a2 = folder.remote) == null ? void 0 : _a2.relay.guid) === relay2.guid;
    });
    handleManageSharedFolder(folder, relay);
  };
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(11, plugin = $$props2.plugin);
    if ("relays" in $$props2)
      $$subscribe_relays($$invalidate(0, relays = $$props2.relays));
  };
  return [
    relays,
    shareKey,
    invalidShareKey,
    $relays,
    $sharedFolders,
    sharedFolders,
    handleManageRelay,
    handleManageSharedFolder,
    handleShareKeyInput,
    handleJoinRelayFromInvite,
    handleCreateRelay,
    plugin,
    input_input_handler,
    click_handler,
    settings_handler,
    click_handler_1,
    settings_handler_1
  ];
}
var Relays = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance17, create_fragment17, safe_not_equal, { plugin: 11, relays: 0 }, add_css6);
  }
};
var Relays_default = Relays;

// src/components/Folder.svelte
function create_fragment18(ctx) {
  let span;
  let folder_1;
  let t_value = (
    /*folder*/
    ctx[0].name + ""
  );
  let t2;
  let current;
  folder_1 = new folder_default({
    props: {
      class: "svg-icon",
      style: "margin-right: .2em; width: 1em;"
    }
  });
  return {
    c() {
      span = element2("span");
      create_component(folder_1.$$.fragment);
      t2 = text2(t_value);
      set_style(span, "display", "inline-flex");
      set_style(span, "align-items", "center");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      mount_component(folder_1, span, null);
      append2(span, t2);
      current = true;
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & /*folder*/
      1) && t_value !== (t_value = /*folder*/
      ctx2[0].name + ""))
        set_data(t2, t_value);
    },
    i(local) {
      if (current)
        return;
      transition_in(folder_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(folder_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      destroy_component(folder_1);
    }
  };
}
function instance18($$self, $$props, $$invalidate) {
  let { folder } = $$props;
  $$self.$$set = ($$props2) => {
    if ("folder" in $$props2)
      $$invalidate(0, folder = $$props2.folder);
  };
  return [folder];
}
var Folder_1 = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance18, create_fragment18, safe_not_equal, { folder: 0 });
  }
};
var Folder_default = Folder_1;

// src/components/ManageRelay.svelte
var import_obsidian18 = require("obsidian");
var import_path_browserify3 = __toESM(require_path_browserify());

// src/ui/FolderSuggestModal.ts
var import_obsidian13 = require("obsidian");

// src/components/FolderSuggestion.svelte
function create_else_block4(ctx) {
  let div;
  let current;
  let if_block = (
    /*suggestion*/
    ctx[0].shared && create_if_block_12(ctx)
  );
  return {
    c() {
      div = element2("div");
      if (if_block)
        if_block.c();
      attr(div, "class", "suggestion-icon");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*suggestion*/
        ctx2[0].shared
      ) {
        if (if_block) {
          if (dirty & /*suggestion*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_12(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block)
        if_block.d();
    }
  };
}
function create_if_block6(ctx) {
  let span;
  return {
    c() {
      span = element2("span");
      span.textContent = "Enter to create";
      attr(span, "class", "suggestion-action");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_12(ctx) {
  let layers;
  let current;
  layers = new layers_default({ props: { class: "svg-icon" } });
  return {
    c() {
      create_component(layers.$$.fragment);
    },
    m(target, anchor) {
      mount_component(layers, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(layers.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(layers.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(layers, detaching);
    }
  };
}
function create_fragment19(ctx) {
  let div1;
  let div0;
  let t0_value = (
    /*suggestion*/
    ctx[0].folder + ""
  );
  let t0;
  let t1;
  let div2;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block6, create_else_block4];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!/*suggestion*/
    ctx2[0].exists)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div1 = element2("div");
      div0 = element2("div");
      t0 = text2(t0_value);
      t1 = space();
      div2 = element2("div");
      if_block.c();
      attr(div0, "class", "suggestion-title");
      attr(div1, "class", "suggestion-content");
      attr(div2, "class", "suggestion-aux");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append2(div1, div0);
      append2(div0, t0);
      insert(target, t1, anchor);
      insert(target, div2, anchor);
      if_blocks[current_block_type_index].m(div2, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & /*suggestion*/
      1) && t0_value !== (t0_value = /*suggestion*/
      ctx2[0].folder + ""))
        set_data(t0, t0_value);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div2, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
        detach(t1);
        detach(div2);
      }
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance19($$self, $$props, $$invalidate) {
  let { suggestion } = $$props;
  $$self.$$set = ($$props2) => {
    if ("suggestion" in $$props2)
      $$invalidate(0, suggestion = $$props2.suggestion);
  };
  return [suggestion];
}
var FolderSuggestion = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance19, create_fragment19, safe_not_equal, { suggestion: 0 });
  }
};
var FolderSuggestion_default = FolderSuggestion;

// src/ui/FolderSuggestModal.ts
var FolderSuggestModal = class extends import_obsidian13.SuggestModal {
  constructor(app, sharedFolders, onChoose) {
    super(app);
    this.sharedFolders = sharedFolders;
    this.onChoose = onChoose;
    this.components = [];
    this.sharedPaths = new Set(
      this.sharedFolders.map((folder) => folder.path)
    );
    this.hasRemotes = new Set(
      this.sharedFolders.filter((folder) => folder.remote !== void 0).map((folder) => folder.path)
    );
    this.setInstructions([
      {
        command: "\u2191/\u2193",
        purpose: "Navigate"
      },
      {
        command: "Enter",
        purpose: "Choose and share folder"
      },
      {
        command: "Esc",
        purpose: "Cancel"
      }
    ]);
  }
  sortFn(a, b) {
    if (a.exists && !b.exists) {
      return -1;
    }
    if (!a.exists && b.exists) {
      return 1;
    }
    if (a.shared && !b.shared) {
      return -1;
    }
    if (b.shared && !a.shared) {
      return 1;
    }
    return a.folder.localeCompare(b.folder);
  }
  onClose() {
    super.onClose();
    this.components.forEach((component) => {
      component.$destroy();
    });
  }
  getSuggestions(inputStr) {
    this.components.forEach((component) => {
      component.$destroy();
    });
    const lowerCaseInputStr = inputStr.toLowerCase();
    const folders = [];
    const exists = this.app.vault.getAbstractFileByPath(inputStr) !== null;
    if (inputStr.length > 0 && !exists) {
      folders.push({
        folder: inputStr,
        exists: false,
        shared: false
      });
    }
    const getAllFoldersRecursively = (folder) => {
      const shared = this.sharedPaths.has(folder.path);
      const hasRemote = this.hasRemotes.has(folder.path);
      if (folder.path.toLowerCase().contains(lowerCaseInputStr) && folder.path.length > 1 && !hasRemote) {
        folders.push({
          folder: folder.path,
          exists: true,
          shared
        });
      }
      if (shared) {
        return;
      }
      for (const child of folder.children) {
        if (child instanceof import_obsidian13.TFolder) {
          getAllFoldersRecursively(child);
        }
      }
    };
    getAllFoldersRecursively(this.app.vault.getRoot());
    return folders.sort(this.sortFn);
  }
  renderSuggestion(suggestion, el) {
    el.addClass("mod-complex");
    const component = new FolderSuggestion_default({
      target: el,
      props: {
        suggestion
      }
    });
    this.components.push(component);
  }
  onChooseSuggestion(item, evt) {
    this.onChoose(item.folder);
  }
};

// src/ui/AddToVaultModal.ts
var import_obsidian17 = require("obsidian");

// src/components/AddToVaultModalContent.svelte
var import_obsidian16 = require("obsidian");

// src/ui/FolderSuggest.ts
var import_obsidian14 = require("obsidian");
var import_obsidian15 = require("obsidian");
var FolderSuggest = class extends import_obsidian15.AbstractInputSuggest {
  constructor(app, sharedFolders, inputEl) {
    super(app, inputEl);
    this.app = app;
    this.sharedFolders = sharedFolders;
    this.inputEl = inputEl;
    this.sharedPaths = new Set(
      this.sharedFolders.map((folder) => folder.path)
    );
  }
  getSuggestions(inputStr) {
    const lowerCaseInputStr = inputStr.toLowerCase();
    const folders = [];
    const getAllFoldersRecursively = (folder) => {
      const shared = this.sharedPaths.has(folder.path);
      if (shared) {
        return;
      }
      if (folder.path.toLowerCase().contains(lowerCaseInputStr)) {
        folders.push(folder.path);
      }
      for (const child of folder.children) {
        if (child instanceof import_obsidian14.TFolder) {
          getAllFoldersRecursively(child);
        }
      }
    };
    getAllFoldersRecursively(this.app.vault.getRoot());
    return folders;
  }
  renderSuggestion(folder, el) {
    el.setText(folder);
  }
  selectSuggestion(folder) {
    this.inputEl.value = folder;
    this.inputEl.trigger("input");
    this.close();
  }
};

// src/components/FolderSelectInput.svelte
function create_fragment20(ctx) {
  let div;
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      div = element2("div");
      input = element2("input");
      attr(input, "type", "text");
      attr(input, "placeholder", "/");
      attr(div, "class", "folder-suggest-container");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append2(div, input);
      ctx[5](input);
      set_input_value(
        input,
        /*$selectedFolder*/
        ctx[2]
      );
      if (!mounted) {
        dispose = [
          listen(input, "input", handleInput),
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[6]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$selectedFolder*/
      4 && input.value !== /*$selectedFolder*/
      ctx2[2]) {
        set_input_value(
          input,
          /*$selectedFolder*/
          ctx2[2]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      ctx[5](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function handleInput() {
}
function instance20($$self, $$props, $$invalidate) {
  let $selectedFolder, $$unsubscribe_selectedFolder = noop, $$subscribe_selectedFolder = () => ($$unsubscribe_selectedFolder(), $$unsubscribe_selectedFolder = subscribe2(selectedFolder, ($$value) => $$invalidate(2, $selectedFolder = $$value)), selectedFolder);
  $$self.$$.on_destroy.push(() => $$unsubscribe_selectedFolder());
  let { app } = $$props;
  let inputEl;
  let folderSuggest;
  let { sharedFolders } = $$props;
  let { selectedFolder = writable() } = $$props;
  $$subscribe_selectedFolder();
  onMount(() => {
    folderSuggest = new FolderSuggest(app, sharedFolders, inputEl);
    const handleFolderSelect = (event) => {
      $$subscribe_selectedFolder($$invalidate(0, selectedFolder = event.detail.folder.path));
    };
    inputEl.addEventListener("folder-selected", handleFolderSelect);
    return () => {
      inputEl.removeEventListener("folder-selected", handleFolderSelect);
    };
  });
  onDestroy(() => {
    if (folderSuggest) {
      folderSuggest.close();
    }
  });
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputEl = $$value;
      $$invalidate(1, inputEl);
    });
  }
  function input_input_handler() {
    $selectedFolder = this.value;
    selectedFolder.set($selectedFolder);
  }
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(3, app = $$props2.app);
    if ("sharedFolders" in $$props2)
      $$invalidate(4, sharedFolders = $$props2.sharedFolders);
    if ("selectedFolder" in $$props2)
      $$subscribe_selectedFolder($$invalidate(0, selectedFolder = $$props2.selectedFolder));
  };
  return [
    selectedFolder,
    inputEl,
    $selectedFolder,
    app,
    sharedFolders,
    input_binding,
    input_input_handler
  ];
}
var FolderSelectInput = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance20, create_fragment20, safe_not_equal, {
      app: 3,
      sharedFolders: 4,
      selectedFolder: 0
    });
  }
};
var FolderSelectInput_default = FolderSelectInput;

// src/components/AddToVaultModalContent.svelte
function add_css7(target) {
  append_styles(target, "svelte-hgd3zf", "span.error.svelte-hgd3zf{flex:auto;align-content:center}");
}
function create_default_slot_18(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element2("input");
      attr(input, "type", "text");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(
        input,
        /*folderName*/
        ctx[4]
      );
      if (!mounted) {
        dispose = listen(
          input,
          "input",
          /*input_input_handler*/
          ctx[8]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*folderName*/
      16 && input.value !== /*folderName*/
      ctx2[4]) {
        set_input_value(
          input,
          /*folderName*/
          ctx2[4]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot9(ctx) {
  let folderselect;
  let current;
  folderselect = new FolderSelectInput_default({
    props: {
      app: (
        /*app*/
        ctx[0]
      ),
      sharedFolders: (
        /*sharedFolders*/
        ctx[2]
      ),
      selectedFolder: (
        /*folderLocation*/
        ctx[7]
      )
    }
  });
  return {
    c() {
      create_component(folderselect.$$.fragment);
    },
    m(target, anchor) {
      mount_component(folderselect, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const folderselect_changes = {};
      if (dirty & /*app*/
      1)
        folderselect_changes.app = /*app*/
        ctx2[0];
      if (dirty & /*sharedFolders*/
      4)
        folderselect_changes.sharedFolders = /*sharedFolders*/
        ctx2[2];
      folderselect.$set(folderselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(folderselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(folderselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(folderselect, detaching);
    }
  };
}
function create_if_block7(ctx) {
  let span;
  let t2;
  return {
    c() {
      span = element2("span");
      t2 = text2(
        /*error*/
        ctx[5]
      );
      attr(span, "class", "mod-warning error svelte-hgd3zf");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append2(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*error*/
      32)
        set_data(
          t2,
          /*error*/
          ctx2[5]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_fragment21(ctx) {
  let div0;
  let t1;
  let div2;
  let settingitem0;
  let t2;
  let settingitem1;
  let t3;
  let div1;
  let t4;
  let button;
  let current;
  let mounted;
  let dispose;
  settingitem0 = new SettingItem_default({
    props: {
      name: "Folder name",
      description: "Set the name of the folder to be added.",
      $$slots: { default: [create_default_slot_18] },
      $$scope: { ctx }
    }
  });
  settingitem1 = new SettingItem_default({
    props: {
      name: "Folder location",
      description: "Set the location in your vault.",
      $$slots: { default: [create_default_slot9] },
      $$scope: { ctx }
    }
  });
  let if_block = (
    /*error*/
    ctx[5] && create_if_block7(ctx)
  );
  return {
    c() {
      div0 = element2("div");
      div0.textContent = "Add to vault";
      t1 = space();
      div2 = element2("div");
      create_component(settingitem0.$$.fragment);
      t2 = space();
      create_component(settingitem1.$$.fragment);
      t3 = space();
      div1 = element2("div");
      if (if_block)
        if_block.c();
      t4 = space();
      button = element2("button");
      button.textContent = "Confirm";
      attr(div0, "class", "modal-title");
      attr(button, "class", "mod-cta");
      attr(div1, "class", "modal-button-container");
      attr(div2, "class", "modal-content");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      insert(target, t1, anchor);
      insert(target, div2, anchor);
      mount_component(settingitem0, div2, null);
      append2(div2, t2);
      mount_component(settingitem1, div2, null);
      append2(div2, t3);
      append2(div2, div1);
      if (if_block)
        if_block.m(div1, null);
      append2(div1, t4);
      append2(div1, button);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function((0, import_obsidian16.debounce)(
            /*click_handler*/
            ctx[9]
          )))
            (0, import_obsidian16.debounce)(
              /*click_handler*/
              ctx[9]
            ).apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      const settingitem0_changes = {};
      if (dirty & /*$$scope, folderName*/
      1040) {
        settingitem0_changes.$$scope = { dirty, ctx };
      }
      settingitem0.$set(settingitem0_changes);
      const settingitem1_changes = {};
      if (dirty & /*$$scope, app, sharedFolders*/
      1029) {
        settingitem1_changes.$$scope = { dirty, ctx };
      }
      settingitem1.$set(settingitem1_changes);
      if (
        /*error*/
        ctx[5]
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block7(ctx);
          if_block.c();
          if_block.m(div1, t4);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem0.$$.fragment, local);
      transition_in(settingitem1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem0.$$.fragment, local);
      transition_out(settingitem1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div0);
        detach(t1);
        detach(div2);
      }
      destroy_component(settingitem0);
      destroy_component(settingitem1);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function instance21($$self, $$props, $$invalidate) {
  let $folderLocation;
  let { app } = $$props;
  let { remoteFolder } = $$props;
  let { sharedFolders } = $$props;
  let { onConfirm } = $$props;
  let folderName = remoteFolder.name;
  let folderLocation = writable();
  component_subscribe($$self, folderLocation, (value) => $$invalidate(6, $folderLocation = value));
  let error = "";
  function input_input_handler() {
    folderName = this.value;
    $$invalidate(4, folderName);
  }
  const click_handler = async () => {
    onConfirm(remoteFolder, folderName, $folderLocation || "").catch((e2) => {
      $$invalidate(5, error = e2.message);
    });
  };
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(0, app = $$props2.app);
    if ("remoteFolder" in $$props2)
      $$invalidate(1, remoteFolder = $$props2.remoteFolder);
    if ("sharedFolders" in $$props2)
      $$invalidate(2, sharedFolders = $$props2.sharedFolders);
    if ("onConfirm" in $$props2)
      $$invalidate(3, onConfirm = $$props2.onConfirm);
  };
  return [
    app,
    remoteFolder,
    sharedFolders,
    onConfirm,
    folderName,
    error,
    $folderLocation,
    folderLocation,
    input_input_handler,
    click_handler
  ];
}
var AddToVaultModalContent = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance21,
      create_fragment21,
      safe_not_equal,
      {
        app: 0,
        remoteFolder: 1,
        sharedFolders: 2,
        onConfirm: 3
      },
      add_css7
    );
  }
};
var AddToVaultModalContent_default = AddToVaultModalContent;

// src/ui/AddToVaultModal.ts
var AddToVaultModal = class extends import_obsidian17.Modal {
  constructor(app, sharedFolders, remoteFolder, onConfirm) {
    super(app);
    this.sharedFolders = sharedFolders;
    this.remoteFolder = remoteFolder;
    this.onConfirm = onConfirm;
    this.onConfirm = onConfirm;
  }
  onOpen() {
    const { contentEl } = this;
    this.component = new AddToVaultModalContent_default({
      target: contentEl,
      props: {
        remoteFolder: this.remoteFolder,
        sharedFolders: this.sharedFolders,
        onConfirm: async (remoteFolder, folderName, folderLocation) => {
          await this.onConfirm(
            remoteFolder,
            folderName,
            folderLocation
          );
          this.close();
        },
        app: this.app
      }
    });
  }
  onClose() {
    var _a2;
    const { contentEl } = this;
    contentEl.empty();
    (_a2 = this.component) == null ? void 0 : _a2.$destroy();
  }
};

// src/components/ManageRelay.svelte
var import_moment = __toESM(require_moment());
function add_css8(target) {
  append_styles(target, "svelte-1y54kws", ".system3-settings-danger-zone.svelte-1y54kws{margin-top:6em}input.system3-updating.svelte-1y54kws{border:1px solid var(--color-accent) !important}input.system3-input-invalid.svelte-1y54kws{border:1px solid var(--color-red) !important}");
}
function get_each_context4(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[47] = list[i2];
  return child_ctx;
}
function get_each_context_12(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[50] = list[i2];
  return child_ctx;
}
function create_if_block_7(ctx) {
  let settingitem;
  let current;
  settingitem = new SettingItem_default({
    props: {
      name: "Relay name",
      description: "Set the relay name.",
      $$slots: { default: [create_default_slot_112] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const settingitem_changes = {};
      if (dirty[0] & /*$updating, $nameValid, relay, nameInput*/
      297 | dirty[1] & /*$$scope*/
      4194304) {
        settingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem.$set(settingitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem, detaching);
    }
  };
}
function create_default_slot_112(ctx) {
  let input;
  let input_class_value;
  let mounted;
  let dispose;
  return {
    c() {
      input = element2("input");
      attr(input, "type", "text");
      attr(input, "spellcheck", "false");
      attr(input, "placeholder", "Example: Shared Notes");
      attr(input, "class", input_class_value = null_to_empty(
        /*$updating*/
        (ctx[8] ? "system3-updating" : "") + /*$nameValid*/
        (ctx[5] ? "" : " system3-input-invalid")
      ) + " svelte-1y54kws");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(
        input,
        /*relay*/
        ctx[0].name
      );
      ctx[34](input);
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[33]
          ),
          listen(
            input,
            "input",
            /*handleNameChange*/
            ctx[25]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$updating, $nameValid*/
      288 && input_class_value !== (input_class_value = null_to_empty(
        /*$updating*/
        (ctx2[8] ? "system3-updating" : "") + /*$nameValid*/
        (ctx2[5] ? "" : " system3-input-invalid")
      ) + " svelte-1y54kws")) {
        attr(input, "class", input_class_value);
      }
      if (dirty[0] & /*relay*/
      1 && input.value !== /*relay*/
      ctx2[0].name) {
        set_input_value(
          input,
          /*relay*/
          ctx2[0].name
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      ctx[34](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_else_block_32(ctx) {
  let settingitem;
  let current;
  settingitem = new SettingItem_default({
    props: {
      description: "",
      $$slots: {
        name: [create_name_slot_2],
        default: [create_default_slot_102]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const settingitem_changes = {};
      if (dirty[0] & /*$remoteFolders*/
      512 | dirty[1] & /*$$scope*/
      4194304) {
        settingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem.$set(settingitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem, detaching);
    }
  };
}
function create_if_block_6(ctx) {
  let settingitem;
  let current;
  settingitem = new SettingItem_default({
    props: {
      description: "",
      $$slots: {
        name: [create_name_slot_12],
        default: [create_default_slot_92]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const settingitem_changes = {};
      if (dirty[0] & /*$remoteFolders, $sharedFolders*/
      1536 | dirty[1] & /*$$scope*/
      4194304) {
        settingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem.$set(settingitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem, detaching);
    }
  };
}
function create_default_slot_102(ctx) {
  let button;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[36](
        /*remote*/
        ctx[50]
      )
    );
  }
  return {
    c() {
      button = element2("button");
      button.textContent = "Add to Vault";
      attr(button, "class", "mod-cta");
      attr(button, "aria-label", "Add shared folder to vault");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function((0, import_obsidian18.debounce)(click_handler)))
            (0, import_obsidian18.debounce)(click_handler).apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_name_slot_2(ctx) {
  let folder;
  let current;
  folder = new Folder_default({
    props: { folder: (
      /*remote*/
      ctx[50]
    ), slot: "name" }
  });
  return {
    c() {
      create_component(folder.$$.fragment);
    },
    m(target, anchor) {
      mount_component(folder, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const folder_changes = {};
      if (dirty[0] & /*$remoteFolders*/
      512)
        folder_changes.folder = /*remote*/
        ctx2[50];
      folder.$set(folder_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(folder.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(folder.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(folder, detaching);
    }
  };
}
function create_default_slot_92(ctx) {
  let settingscontrol;
  let current;
  function settings_handler() {
    return (
      /*settings_handler*/
      ctx[35](
        /*remote*/
        ctx[50]
      )
    );
  }
  settingscontrol = new SettingsControl_default({});
  settingscontrol.$on("settings", function() {
    if (is_function((0, import_obsidian18.debounce)(settings_handler)))
      (0, import_obsidian18.debounce)(settings_handler).apply(this, arguments);
  });
  return {
    c() {
      create_component(settingscontrol.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingscontrol, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    i(local) {
      if (current)
        return;
      transition_in(settingscontrol.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingscontrol.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingscontrol, detaching);
    }
  };
}
function create_name_slot_12(ctx) {
  let folder;
  let current;
  folder = new Folder_default({
    props: { folder: (
      /*remote*/
      ctx[50]
    ), slot: "name" }
  });
  return {
    c() {
      create_component(folder.$$.fragment);
    },
    m(target, anchor) {
      mount_component(folder, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const folder_changes = {};
      if (dirty[0] & /*$remoteFolders*/
      512)
        folder_changes.folder = /*remote*/
        ctx2[50];
      folder.$set(folder_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(folder.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(folder.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(folder, detaching);
    }
  };
}
function create_each_block_12(ctx) {
  let show_if;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  function func(...args3) {
    return (
      /*func*/
      ctx[32](
        /*remote*/
        ctx[50],
        ...args3
      )
    );
  }
  const if_block_creators = [create_if_block_6, create_else_block_32];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (dirty[0] & /*$sharedFolders, $remoteFolders*/
    1536)
      show_if = null;
    if (show_if == null)
      show_if = !!/*$sharedFolders*/
      ctx2[10].find(func);
    if (show_if)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block.c();
        } else {
          if_block.p(ctx, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_default_slot_82(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element2("button");
      button.textContent = "Add";
      attr(button, "class", "mod-cta");
      attr(button, "aria-label", "Select a folder to add to the relay");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", (0, import_obsidian18.debounce)(
          /*click_handler_1*/
          ctx[37]
        ));
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_72(ctx) {
  let t0_value = (
    /*$roles*/
    ctx[11].values().length + ""
  );
  let t0;
  let t1;
  let t2_value = (
    /*$relay*/
    ctx[7].user_limit + ""
  );
  let t2;
  return {
    c() {
      t0 = text2(t0_value);
      t1 = text2(" / ");
      t2 = text2(t2_value);
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$roles*/
      2048 && t0_value !== (t0_value = /*$roles*/
      ctx2[11].values().length + ""))
        set_data(t0, t0_value);
      if (dirty[0] & /*$relay*/
      128 && t2_value !== (t2_value = /*$relay*/
      ctx2[7].user_limit + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
      }
    }
  };
}
function create_if_block_52(ctx) {
  let button;
  let mounted;
  let dispose;
  function click_handler_2() {
    return (
      /*click_handler_2*/
      ctx[38](
        /*item*/
        ctx[47]
      )
    );
  }
  return {
    c() {
      button = element2("button");
      button.textContent = "Kick";
      attr(button, "class", "mod-destructive");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function((0, import_obsidian18.debounce)(click_handler_2)))
            (0, import_obsidian18.debounce)(click_handler_2).apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_62(ctx) {
  let t2;
  let if_block = (
    /*item*/
    ctx[47].role === "Member" && /*$relay*/
    ctx[7].owner && create_if_block_52(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      t2 = space();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (
        /*item*/
        ctx2[47].role === "Member" && /*$relay*/
        ctx2[7].owner
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_52(ctx2);
          if_block.c();
          if_block.m(t2.parentNode, t2);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_each_block4(ctx) {
  let settingitem;
  let current;
  settingitem = new SettingItem_default({
    props: {
      name: (
        /*item*/
        ctx[47].user.name
      ),
      description: (
        /*item*/
        ctx[47].role
      ),
      $$slots: { default: [create_default_slot_62] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const settingitem_changes = {};
      if (dirty[0] & /*$roles*/
      2048)
        settingitem_changes.name = /*item*/
        ctx2[47].user.name;
      if (dirty[0] & /*$roles*/
      2048)
        settingitem_changes.description = /*item*/
        ctx2[47].role;
      if (dirty[0] & /*$roles, $relay*/
      2176 | dirty[1] & /*$$scope*/
      4194304) {
        settingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem.$set(settingitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem, detaching);
    }
  };
}
function create_default_slot_52(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element2("input");
      input.value = /*relay_invitation_key*/
      ctx[4];
      attr(input, "type", "text");
      input.readOnly = true;
      attr(input, "id", "system3InviteLink");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      if (!mounted) {
        dispose = listen(input, "click", (0, import_obsidian18.debounce)(
          /*selectText*/
          ctx[29]
        ));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*relay_invitation_key*/
      16 && input.value !== /*relay_invitation_key*/
      ctx2[4]) {
        input.value = /*relay_invitation_key*/
        ctx2[4];
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_else_block_22(ctx) {
  let settingitemheading;
  let t2;
  let settingitem;
  let current;
  settingitemheading = new SettingItemHeading_default({
    props: { name: "Membership", description: "" }
  });
  settingitem = new SettingItem_default({
    props: {
      name: "Leave relay",
      description: "Leave the relay. Local data is preserved.",
      $$slots: { default: [create_default_slot_42] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingitemheading.$$.fragment);
      t2 = space();
      create_component(settingitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitemheading, target, anchor);
      insert(target, t2, anchor);
      mount_component(settingitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const settingitem_changes = {};
      if (dirty[1] & /*$$scope*/
      4194304) {
        settingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem.$set(settingitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitemheading.$$.fragment, local);
      transition_in(settingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitemheading.$$.fragment, local);
      transition_out(settingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(settingitemheading, detaching);
      destroy_component(settingitem, detaching);
    }
  };
}
function create_if_block8(ctx) {
  let current_block_type_index;
  let if_block;
  let t0;
  let settingitemheading;
  let t1;
  let settingitem;
  let current;
  const if_block_creators = [create_if_block_22, create_else_block_12];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (
      /*$subscription*/
      ctx2[12]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_2(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  settingitemheading = new SettingItemHeading_default({
    props: { name: "Storage", description: "" }
  });
  settingitem = new SettingItem_default({
    props: {
      name: "Destroy relay",
      description: "This will destroy the relay (deleting all data on the server). Local data is preserved.",
      $$slots: { default: [create_default_slot10] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      if_block.c();
      t0 = space();
      create_component(settingitemheading.$$.fragment);
      t1 = space();
      create_component(settingitem.$$.fragment);
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, t0, anchor);
      mount_component(settingitemheading, target, anchor);
      insert(target, t1, anchor);
      mount_component(settingitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(t0.parentNode, t0);
      }
      const settingitem_changes = {};
      if (dirty[0] & /*$subscriptions*/
      64 | dirty[1] & /*$$scope*/
      4194304) {
        settingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem.$set(settingitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(settingitemheading.$$.fragment, local);
      transition_in(settingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(settingitemheading.$$.fragment, local);
      transition_out(settingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
      if_blocks[current_block_type_index].d(detaching);
      destroy_component(settingitemheading, detaching);
      destroy_component(settingitem, detaching);
    }
  };
}
function create_default_slot_42(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element2("button");
      button.textContent = "Leave";
      attr(button, "class", "mod-warning");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", (0, import_obsidian18.debounce)(
          /*click_handler_6*/
          ctx[42]
        ));
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_else_block_12(ctx) {
  let settingitem;
  let current;
  settingitem = new SettingItem_default({
    props: {
      name: `Plan: ${/*$relay*/
      ctx[7].plan}`,
      description: "",
      $$slots: {
        description: [create_description_slot_1],
        default: [create_default_slot_33]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const settingitem_changes = {};
      if (dirty[0] & /*$relay*/
      128)
        settingitem_changes.name = `Plan: ${/*$relay*/
        ctx2[7].plan}`;
      if (dirty[0] & /*$relay*/
      128 | dirty[1] & /*$$scope*/
      4194304) {
        settingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem.$set(settingitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem, detaching);
    }
  };
}
function create_if_block_22(ctx) {
  let settingitem;
  let t2;
  let show_if = !/*$subscriptions*/
  ctx[6].values()[0].active || /*$subscriptions*/
  ctx[6].values()[0].cancel_at;
  let if_block_anchor;
  let current;
  settingitem = new SettingItem_default({
    props: {
      name: `Plan: ${/*$relay*/
      ctx[7].plan}`,
      description: "",
      $$slots: {
        description: [create_description_slot],
        default: [create_default_slot_23]
      },
      $$scope: { ctx }
    }
  });
  let if_block = show_if && create_if_block_32(ctx);
  return {
    c() {
      create_component(settingitem.$$.fragment);
      t2 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(settingitem, target, anchor);
      insert(target, t2, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const settingitem_changes = {};
      if (dirty[0] & /*$relay*/
      128)
        settingitem_changes.name = `Plan: ${/*$relay*/
        ctx2[7].plan}`;
      if (dirty[0] & /*$relay, $subscription, $subscriptions*/
      4288 | dirty[1] & /*$$scope*/
      4194304) {
        settingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem.$set(settingitem_changes);
      if (dirty[0] & /*$subscriptions*/
      64)
        show_if = !/*$subscriptions*/
        ctx2[6].values()[0].active || /*$subscriptions*/
        ctx2[6].values()[0].cancel_at;
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*$subscriptions*/
          64) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_32(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(settingitem.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(if_block_anchor);
      }
      destroy_component(settingitem, detaching);
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_default_slot_33(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element2("button");
      button.textContent = "Upgrade";
      attr(button, "class", "mod-cta");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function((0, import_obsidian18.debounce)(
            /*click_handler_5*/
            ctx[41]
          )))
            (0, import_obsidian18.debounce)(
              /*click_handler_5*/
              ctx[41]
            ).apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_description_slot_1(ctx) {
  let fragment2;
  let t_value = (
    /*$relay*/
    (ctx[7].cta || "Thanks for supporting Relay development <3") + ""
  );
  let t2;
  return {
    c() {
      fragment2 = element2("fragment");
      t2 = text2(t_value);
      attr(fragment2, "slot", "description");
    },
    m(target, anchor) {
      insert(target, fragment2, anchor);
      append2(fragment2, t2);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$relay*/
      128 && t_value !== (t_value = /*$relay*/
      (ctx2[7].cta || "Thanks for supporting Relay development <3") + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(fragment2);
      }
    }
  };
}
function create_if_block_42(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element2("button");
      button.textContent = "Cancel";
      attr(button, "class", "mod-destructive");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function((0, import_obsidian18.debounce)(
            /*click_handler_4*/
            ctx[40]
          )))
            (0, import_obsidian18.debounce)(
              /*click_handler_4*/
              ctx[40]
            ).apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_23(ctx) {
  let button;
  let t1;
  let show_if = (
    /*$subscriptions*/
    ctx[6].values()[0].active && !/*$subscriptions*/
    ctx[6].values()[0].cancel_at
  );
  let if_block_anchor;
  let mounted;
  let dispose;
  let if_block = show_if && create_if_block_42(ctx);
  return {
    c() {
      button = element2("button");
      button.textContent = "Manage";
      t1 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      insert(target, button, anchor);
      insert(target, t1, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function((0, import_obsidian18.debounce)(
            /*click_handler_3*/
            ctx[39]
          )))
            (0, import_obsidian18.debounce)(
              /*click_handler_3*/
              ctx[39]
            ).apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*$subscriptions*/
      64)
        show_if = /*$subscriptions*/
        ctx[6].values()[0].active && !/*$subscriptions*/
        ctx[6].values()[0].cancel_at;
      if (show_if) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block_42(ctx);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
        detach(t1);
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_description_slot(ctx) {
  let fragment2;
  let t_value = (
    /*$relay*/
    ctx[7].cta + ""
  );
  let t2;
  return {
    c() {
      fragment2 = element2("fragment");
      t2 = text2(t_value);
      attr(fragment2, "slot", "description");
    },
    m(target, anchor) {
      insert(target, fragment2, anchor);
      append2(fragment2, t2);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$relay*/
      128 && t_value !== (t_value = /*$relay*/
      ctx2[7].cta + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(fragment2);
      }
    }
  };
}
function create_if_block_32(ctx) {
  let settingitem;
  let current;
  settingitem = new SettingItem_default({
    props: {
      description: "",
      $$slots: {
        name: [create_name_slot2],
        default: [create_default_slot_19]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const settingitem_changes = {};
      if (dirty[0] & /*$subscriptions*/
      64 | dirty[1] & /*$$scope*/
      4194304) {
        settingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem.$set(settingitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem, detaching);
    }
  };
}
function create_default_slot_19(ctx) {
  let t_value = (
    /*getActiveForMessage*/
    ctx[14](
      /*$subscriptions*/
      ctx[6].values()[0].cancel_at
    ) + ""
  );
  let t2;
  return {
    c() {
      t2 = text2(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$subscriptions*/
      64 && t_value !== (t_value = /*getActiveForMessage*/
      ctx2[14](
        /*$subscriptions*/
        ctx2[6].values()[0].cancel_at
      ) + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_name_slot2(ctx) {
  let span;
  return {
    c() {
      span = element2("span");
      span.textContent = "Status: Cancelled";
      attr(span, "slot", "name");
      attr(span, "class", "mod-warning");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_else_block5(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element2("button");
      button.textContent = "Destroy";
      attr(button, "class", "mod-warning");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", (0, import_obsidian18.debounce)(
          /*handleDestroy*/
          ctx[26]
        ));
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_13(ctx) {
  let button;
  let button_disabled_value;
  return {
    c() {
      button = element2("button");
      button.textContent = "Destroy";
      button.disabled = button_disabled_value = true;
      attr(button, "class", "mod-warning");
      attr(button, "aria-label", "Cancel subscription to destroy relay.");
    },
    m(target, anchor) {
      insert(target, button, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
    }
  };
}
function create_default_slot10(ctx) {
  let show_if;
  let if_block_anchor;
  function select_block_type_3(ctx2, dirty) {
    if (dirty[0] & /*$subscriptions*/
    64)
      show_if = null;
    if (show_if == null)
      show_if = !!/*$subscriptions*/
      (ctx2[6].values().length > 0 && !/*$subscriptions*/
      ctx2[6].values()[0].cancel_at);
    if (show_if)
      return create_if_block_13;
    return create_else_block5;
  }
  let current_block_type = select_block_type_3(ctx, [-1, -1]);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_3(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
}
function create_fragment22(ctx) {
  let h3;
  let t0_value = (
    /*relay*/
    ctx[0].name + ""
  );
  let t0;
  let t1;
  let t2;
  let settingitemheading0;
  let t3;
  let t4;
  let settingitem0;
  let t5;
  let settingitemheading1;
  let t6;
  let t7;
  let settingitemheading2;
  let t8;
  let settingitem1;
  let t9;
  let current_block_type_index;
  let if_block1;
  let if_block1_anchor;
  let current;
  let if_block0 = (
    /*relay*/
    ctx[0].owner && create_if_block_7(ctx)
  );
  settingitemheading0 = new SettingItemHeading_default({ props: { name: "Shared folders" } });
  let each_value_1 = ensure_array_like(
    /*$remoteFolders*/
    ctx[9].values()
  );
  let each_blocks_1 = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks_1[i2] = create_each_block_12(get_each_context_12(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks_1[i2], 1, 1, () => {
    each_blocks_1[i2] = null;
  });
  settingitem0 = new SettingItem_default({
    props: {
      description: "",
      name: "",
      $$slots: { default: [create_default_slot_82] },
      $$scope: { ctx }
    }
  });
  settingitemheading1 = new SettingItemHeading_default({
    props: {
      name: "Users",
      $$slots: { default: [create_default_slot_72] },
      $$scope: { ctx }
    }
  });
  let each_value = ensure_array_like(
    /*$roles*/
    ctx[11].values().sort(userSort)
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block4(get_each_context4(ctx, each_value, i2));
  }
  const out_1 = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  settingitemheading2 = new SettingItemHeading_default({ props: { name: "Sharing" } });
  settingitem1 = new SettingItem_default({
    props: {
      name: "Share key",
      description: "Share this key with your collaborators.",
      $$slots: { default: [create_default_slot_52] },
      $$scope: { ctx }
    }
  });
  const if_block_creators = [create_if_block8, create_else_block_22];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*$relay*/
      ctx2[7].owner
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, [-1, -1]);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      h3 = element2("h3");
      t0 = text2(t0_value);
      t1 = space();
      if (if_block0)
        if_block0.c();
      t2 = space();
      create_component(settingitemheading0.$$.fragment);
      t3 = space();
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        each_blocks_1[i2].c();
      }
      t4 = space();
      create_component(settingitem0.$$.fragment);
      t5 = space();
      create_component(settingitemheading1.$$.fragment);
      t6 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t7 = space();
      create_component(settingitemheading2.$$.fragment);
      t8 = space();
      create_component(settingitem1.$$.fragment);
      t9 = space();
      if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      insert(target, h3, anchor);
      append2(h3, t0);
      insert(target, t1, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t2, anchor);
      mount_component(settingitemheading0, target, anchor);
      insert(target, t3, anchor);
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        if (each_blocks_1[i2]) {
          each_blocks_1[i2].m(target, anchor);
        }
      }
      insert(target, t4, anchor);
      mount_component(settingitem0, target, anchor);
      insert(target, t5, anchor);
      mount_component(settingitemheading1, target, anchor);
      insert(target, t6, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, t7, anchor);
      mount_component(settingitemheading2, target, anchor);
      insert(target, t8, anchor);
      mount_component(settingitem1, target, anchor);
      insert(target, t9, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*relay*/
      1) && t0_value !== (t0_value = /*relay*/
      ctx2[0].name + ""))
        set_data(t0, t0_value);
      if (
        /*relay*/
        ctx2[0].owner
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*relay*/
          1) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_7(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t2.parentNode, t2);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (dirty[0] & /*$remoteFolders, $sharedFolders, handleManageSharedFolder, showAddToVaultModal*/
      285214208) {
        each_value_1 = ensure_array_like(
          /*$remoteFolders*/
          ctx2[9].values()
        );
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_12(ctx2, each_value_1, i2);
          if (each_blocks_1[i2]) {
            each_blocks_1[i2].p(child_ctx, dirty);
            transition_in(each_blocks_1[i2], 1);
          } else {
            each_blocks_1[i2] = create_each_block_12(child_ctx);
            each_blocks_1[i2].c();
            transition_in(each_blocks_1[i2], 1);
            each_blocks_1[i2].m(t4.parentNode, t4);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks_1.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      const settingitem0_changes = {};
      if (dirty[1] & /*$$scope*/
      4194304) {
        settingitem0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem0.$set(settingitem0_changes);
      const settingitemheading1_changes = {};
      if (dirty[0] & /*$relay, $roles*/
      2176 | dirty[1] & /*$$scope*/
      4194304) {
        settingitemheading1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitemheading1.$set(settingitemheading1_changes);
      if (dirty[0] & /*$roles, handleKick, $relay*/
      134219904) {
        each_value = ensure_array_like(
          /*$roles*/
          ctx2[11].values().sort(userSort)
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context4(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block4(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(t7.parentNode, t7);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out_1(i2);
        }
        check_outros();
      }
      const settingitem1_changes = {};
      if (dirty[0] & /*relay_invitation_key*/
      16 | dirty[1] & /*$$scope*/
      4194304) {
        settingitem1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem1.$set(settingitem1_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(settingitemheading0.$$.fragment, local);
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks_1[i2]);
      }
      transition_in(settingitem0.$$.fragment, local);
      transition_in(settingitemheading1.$$.fragment, local);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(settingitemheading2.$$.fragment, local);
      transition_in(settingitem1.$$.fragment, local);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(settingitemheading0.$$.fragment, local);
      each_blocks_1 = each_blocks_1.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        transition_out(each_blocks_1[i2]);
      }
      transition_out(settingitem0.$$.fragment, local);
      transition_out(settingitemheading1.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(settingitemheading2.$$.fragment, local);
      transition_out(settingitem1.$$.fragment, local);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(h3);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(t4);
        detach(t5);
        detach(t6);
        detach(t7);
        detach(t8);
        detach(t9);
        detach(if_block1_anchor);
      }
      if (if_block0)
        if_block0.d(detaching);
      destroy_component(settingitemheading0, detaching);
      destroy_each(each_blocks_1, detaching);
      destroy_component(settingitem0, detaching);
      destroy_component(settingitemheading1, detaching);
      destroy_each(each_blocks, detaching);
      destroy_component(settingitemheading2, detaching);
      destroy_component(settingitem1, detaching);
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function userSort(a, b) {
  if (a.role === "Owner" && b.role !== "Owner") {
    return -1;
  }
  if (a.role !== "Owner" && b.role === "Owner") {
    return 1;
  }
  return a.user.name > b.user.name ? 1 : -1;
}
function isValidObsidianFolderName(path2) {
  const restrictedCharacters = /[\\:*?"<>|]/;
  if (restrictedCharacters.test(path2)) {
    return false;
  }
  const segments = path2.split("/");
  for (const segment of segments) {
    if (segment === "" || segment === "." || segment === "..") {
      return false;
    }
  }
  return true;
}
function instance22($$self, $$props, $$invalidate) {
  let $nameValid;
  let $relayRoles, $$unsubscribe_relayRoles = noop, $$subscribe_relayRoles = () => ($$unsubscribe_relayRoles(), $$unsubscribe_relayRoles = subscribe2(relayRoles, ($$value) => $$invalidate(43, $relayRoles = $$value)), relayRoles);
  let $subscriptions;
  let $relay, $$unsubscribe_relay = noop, $$subscribe_relay = () => ($$unsubscribe_relay(), $$unsubscribe_relay = subscribe2(relay, ($$value) => $$invalidate(7, $relay = $$value)), relay);
  let $updating;
  let $remoteFolders;
  let $sharedFolders, $$unsubscribe_sharedFolders = noop, $$subscribe_sharedFolders = () => ($$unsubscribe_sharedFolders(), $$unsubscribe_sharedFolders = subscribe2(sharedFolders, ($$value) => $$invalidate(10, $sharedFolders = $$value)), sharedFolders);
  let $roles;
  let $subscription;
  $$self.$$.on_destroy.push(() => $$unsubscribe_relayRoles());
  $$self.$$.on_destroy.push(() => $$unsubscribe_relay());
  $$self.$$.on_destroy.push(() => $$unsubscribe_sharedFolders());
  let { relay } = $$props;
  $$subscribe_relay();
  const remoteFolders = relay.folders;
  component_subscribe($$self, remoteFolders, (value) => $$invalidate(9, $remoteFolders = value));
  let { plugin } = $$props;
  let { sharedFolders } = $$props;
  $$subscribe_sharedFolders();
  let { relayRoles } = $$props;
  $$subscribe_relayRoles();
  function getActiveForMessage(cancelAtDate) {
    if (!cancelAtDate) {
      return "Active";
    }
    const now2 = (0, import_moment.default)();
    const cancelAt = (0, import_moment.default)(cancelAtDate);
    const daysRemaining = cancelAt.diff(now2, "days");
    if (daysRemaining <= 0) {
      return "Subscription has ended";
    } else if (daysRemaining === 1) {
      return "Active for 1 more day";
    } else {
      return `Active for ${daysRemaining} more days`;
    }
  }
  const subscriptions = $relay.subscriptions;
  component_subscribe($$self, subscriptions, (value) => $$invalidate(6, $subscriptions = value));
  const subscription = derived($subscriptions, ($subscriptions2) => {
    if ($subscriptions2.values().length === 0) {
      return void 0;
    }
    return $subscriptions2.values()[0];
  });
  component_subscribe($$self, subscription, (value) => $$invalidate(12, $subscription = value));
  const roles = $relayRoles.filter((role) => {
    var _a2;
    return ((_a2 = role.relay) === null || _a2 === void 0 ? void 0 : _a2.id) === relay.id;
  });
  component_subscribe($$self, roles, (value) => $$invalidate(11, $roles = value));
  let nameValid = writable(true);
  component_subscribe($$self, nameValid, (value) => $$invalidate(5, $nameValid = value));
  let nameInput;
  onMount(() => {
    if (nameInput && nameInput.value === "") {
      nameInput.focus();
    }
  });
  const dispatch = createEventDispatcher();
  function handleUpgrade(relay2) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a2;
      if (!((_a2 = plugin.loginManager) === null || _a2 === void 0 ? void 0 : _a2.user)) {
        return;
      }
      window.open(plugin.buildApiUrl(`/subscribe?relay=${relay2.id}&quantity=10&user_email=${plugin.loginManager.user.name}`), "_blank");
    });
  }
  function handleManage(subscription2) {
    return __awaiter(this, void 0, void 0, function* () {
      const token = subscription2.token;
      const sub_id = subscription2.id;
      window.open(plugin.buildApiUrl(`/subscriptions/${sub_id}/manage?token=${token}`), "_blank");
    });
  }
  function handleCancel(subscription2) {
    return __awaiter(this, void 0, void 0, function* () {
      const token = subscription2.token;
      const sub_id = subscription2.id;
      window.open(plugin.buildApiUrl(`/subscriptions/${sub_id}/cancel?token=${token}`), "_blank");
    });
  }
  function handleLeaveRelay() {
    return __awaiter(this, void 0, void 0, function* () {
      plugin.relayManager.leaveRelay(relay);
      dispatch("goBack", { clear: true });
    });
  }
  let relay_invitation_key;
  plugin.relayManager.getRelayInvitationKey(relay).then((key) => {
    $$invalidate(4, relay_invitation_key = key);
  });
  function addToVault(remoteFolder, name, location2) {
    return __awaiter(this, void 0, void 0, function* () {
      const vaultRelativePath = (0, import_obsidian18.normalizePath)((0, import_path_browserify3.join)(location2, name));
      if (plugin.vault.getFolderByPath(vaultRelativePath) === null) {
        yield plugin.vault.createFolder(vaultRelativePath);
      }
      return plugin.sharedFolders.new(vaultRelativePath, remoteFolder.guid, relay.guid, true).then((folder) => {
        folder.remote = remoteFolder;
        plugin.sharedFolders.notifyListeners();
        return folder;
      });
    });
  }
  let updating = writable(false);
  component_subscribe($$self, updating, (value) => $$invalidate(8, $updating = value));
  const updateRelay = (0, import_obsidian18.debounce)(
    () => {
      plugin.relayManager.updateRelay(relay);
      updating.set(false);
    },
    500,
    true
  );
  const showAddToVaultModal = (remoteFolder) => {
    new AddToVaultModal(plugin.app, sharedFolders, remoteFolder, addToVault).open();
  };
  function handleNameChange() {
    nameValid.set(isValidObsidianFolderName(nameInput.value));
    if ($nameValid && nameInput.value !== "") {
      updating.set(true);
      updateRelay();
    }
  }
  function handleDestroy() {
    plugin.relayManager.destroyRelay(relay);
    dispatch("goBack", {});
  }
  function handleKick(relay_role) {
    plugin.relayManager.kick(relay_role);
  }
  function handleManageSharedFolder(folder, relay2) {
    if (!folder) {
      return;
    }
    dispatch("manageSharedFolder", { folder, relay: relay2, mount: false });
  }
  function selectText(event) {
    const inputEl = event.target;
    inputEl.focus();
    inputEl.select();
    navigator.clipboard.writeText(inputEl.value).then(() => new import_obsidian18.Notice("Invite link copied")).catch((err) => {
    });
  }
  const folderSelect = new FolderSuggestModal(
    plugin.app,
    sharedFolders,
    (path2) => __awaiter(void 0, void 0, void 0, function* () {
      const normalizedPath = (0, import_obsidian18.normalizePath)(path2);
      const folder = sharedFolders.find((folder2) => folder2.path == path2);
      if (folder) {
        const remote2 = yield plugin.relayManager.createRemoteFolder(folder, relay);
        folder.remote = remote2;
        folder.connect();
        plugin.sharedFolders.notifyListeners();
        return;
      }
      if (plugin.vault.getFolderByPath(normalizedPath) === null) {
        yield plugin.vault.createFolder(normalizedPath);
      }
      const guid = uuidv4();
      const sharedFolder = yield plugin.sharedFolders.new((0, import_obsidian18.normalizePath)(path2), guid, relay.guid, false);
      const remote = yield plugin.relayManager.createRemoteFolder(sharedFolder, relay);
      sharedFolder.remote = remote;
      plugin.sharedFolders.notifyListeners();
    })
  );
  const func = (remote, local) => local.remote === remote;
  function input_input_handler() {
    relay.name = this.value;
    $$subscribe_relay($$invalidate(0, relay));
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      nameInput = $$value;
      $$invalidate(3, nameInput);
    });
  }
  const settings_handler = (remote) => {
    const local = $sharedFolders.find((local2) => local2.remote === remote);
    if (local) {
      handleManageSharedFolder(local, remote.relay);
    }
  };
  const click_handler = (remote) => {
    showAddToVaultModal(remote);
  };
  const click_handler_1 = () => {
    folderSelect.open();
  };
  const click_handler_2 = (item) => {
    handleKick(item);
  };
  const click_handler_3 = () => {
    handleManage($subscription);
  };
  const click_handler_4 = () => {
    handleCancel($subscription);
  };
  const click_handler_5 = () => {
    handleUpgrade($relay);
  };
  const click_handler_6 = () => {
    handleLeaveRelay();
  };
  $$self.$$set = ($$props2) => {
    if ("relay" in $$props2)
      $$subscribe_relay($$invalidate(0, relay = $$props2.relay));
    if ("plugin" in $$props2)
      $$invalidate(31, plugin = $$props2.plugin);
    if ("sharedFolders" in $$props2)
      $$subscribe_sharedFolders($$invalidate(1, sharedFolders = $$props2.sharedFolders));
    if ("relayRoles" in $$props2)
      $$subscribe_relayRoles($$invalidate(2, relayRoles = $$props2.relayRoles));
  };
  return [
    relay,
    sharedFolders,
    relayRoles,
    nameInput,
    relay_invitation_key,
    $nameValid,
    $subscriptions,
    $relay,
    $updating,
    $remoteFolders,
    $sharedFolders,
    $roles,
    $subscription,
    remoteFolders,
    getActiveForMessage,
    subscriptions,
    subscription,
    roles,
    nameValid,
    handleUpgrade,
    handleManage,
    handleCancel,
    handleLeaveRelay,
    updating,
    showAddToVaultModal,
    handleNameChange,
    handleDestroy,
    handleKick,
    handleManageSharedFolder,
    selectText,
    folderSelect,
    plugin,
    func,
    input_input_handler,
    input_binding,
    settings_handler,
    click_handler,
    click_handler_1,
    click_handler_2,
    click_handler_3,
    click_handler_4,
    click_handler_5,
    click_handler_6
  ];
}
var ManageRelay = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance22,
      create_fragment22,
      safe_not_equal,
      {
        relay: 0,
        plugin: 31,
        sharedFolders: 1,
        relayRoles: 2
      },
      add_css8,
      [-1, -1]
    );
  }
};
var ManageRelay_default = ManageRelay;

// src/components/ModalSettingsNav.svelte
function create_fragment23(ctx) {
  let div1;
  let div0;
  let chevronleft;
  let current;
  let mounted;
  let dispose;
  chevronleft = new chevron_left_default({});
  return {
    c() {
      div1 = element2("div");
      div0 = element2("div");
      create_component(chevronleft.$$.fragment);
      attr(div0, "class", "clickable-icon");
      attr(div0, "aria-label", "Back");
      attr(div0, "tabindex", "0");
      attr(div0, "role", "button");
      attr(div1, "class", "modal-setting-nav-bar");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append2(div1, div0);
      mount_component(chevronleft, div0, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            div0,
            "click",
            /*handleGoBack*/
            ctx[0]
          ),
          listen(
            div0,
            "keypress",
            /*handleKeypress*/
            ctx[1]
          )
        ];
        mounted = true;
      }
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(chevronleft.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(chevronleft.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(chevronleft);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance23($$self) {
  const dispatch = createEventDispatcher();
  function handleGoBack() {
    dispatch("goBack", {});
  }
  function handleKeypress(event) {
    if (event.key === "Escape") {
      dispatch("goBack", {});
      event.stopPropagation();
    }
  }
  return [handleGoBack, handleKeypress];
}
var ModalSettingsNav = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance23, create_fragment23, safe_not_equal, {});
  }
};
var ModalSettingsNav_default = ModalSettingsNav;

// src/components/ManageSharedFolder.svelte
var import_obsidian19 = require("obsidian");
function create_default_slot_34(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element2("button");
      button.textContent = "Delete local";
      attr(button, "class", "mod-warning");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", (0, import_obsidian19.debounce)(
          /*click_handler*/
          ctx[12]
        ));
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_24(ctx) {
  let button;
  let t2;
  let button_class_value;
  let button_disabled_value;
  let button_aria_label_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element2("button");
      t2 = text2("Delete metadata");
      attr(button, "class", button_class_value = /*$relayStore*/
      ctx[4] ? "mod-disabled" : "mod-warning");
      button.disabled = button_disabled_value = /*$relayStore*/
      ctx[4] ? true : false;
      attr(button, "aria-label", button_aria_label_value = /*$relayStore*/
      ctx[4] ? "Metadata is required for sharing." : "");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append2(button, t2);
      if (!mounted) {
        dispose = listen(button, "click", (0, import_obsidian19.debounce)(
          /*click_handler_1*/
          ctx[13]
        ));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$relayStore*/
      16 && button_class_value !== (button_class_value = /*$relayStore*/
      ctx2[4] ? "mod-disabled" : "mod-warning")) {
        attr(button, "class", button_class_value);
      }
      if (dirty & /*$relayStore*/
      16 && button_disabled_value !== (button_disabled_value = /*$relayStore*/
      ctx2[4] ? true : false)) {
        button.disabled = button_disabled_value;
      }
      if (dirty & /*$relayStore*/
      16 && button_aria_label_value !== (button_aria_label_value = /*$relayStore*/
      ctx2[4] ? "Metadata is required for sharing." : "")) {
        attr(button, "aria-label", button_aria_label_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_14(ctx) {
  var _a2, _b2, _c, _d, _e;
  let if_block_anchor;
  let current;
  let if_block = (
    /*$relayStore*/
    (((_a2 = ctx[4]) == null ? void 0 : _a2.owner) || /*$folderStore*/
    ((_d = (_c = (_b2 = ctx[3]) == null ? void 0 : _b2.remote) == null ? void 0 : _c.creator) == null ? void 0 : _d.id) === /*plugin*/
    ((_e = ctx[0].relayManager.user) == null ? void 0 : _e.id)) && create_if_block_23(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a3, _b3, _c2, _d2, _e2;
      if (
        /*$relayStore*/
        ((_a3 = ctx2[4]) == null ? void 0 : _a3.owner) || /*$folderStore*/
        ((_d2 = (_c2 = (_b3 = ctx2[3]) == null ? void 0 : _b3.remote) == null ? void 0 : _c2.creator) == null ? void 0 : _d2.id) === /*plugin*/
        ((_e2 = ctx2[0].relayManager.user) == null ? void 0 : _e2.id)
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$relayStore, $folderStore, plugin*/
          25) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_23(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_if_block_23(ctx) {
  let settingitemheading;
  let t2;
  let settingitem;
  let current;
  settingitemheading = new SettingItemHeading_default({ props: { name: "Remote Folder" } });
  settingitem = new SettingItem_default({
    props: {
      name: "Remove from relay",
      description: `Deletes the remote folder from the relay. Local files will be preserved.`,
      $$slots: { default: [create_default_slot_110] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingitemheading.$$.fragment);
      t2 = space();
      create_component(settingitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitemheading, target, anchor);
      insert(target, t2, anchor);
      mount_component(settingitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const settingitem_changes = {};
      if (dirty & /*$$scope*/
      262144) {
        settingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem.$set(settingitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitemheading.$$.fragment, local);
      transition_in(settingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitemheading.$$.fragment, local);
      transition_out(settingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(settingitemheading, detaching);
      destroy_component(settingitem, detaching);
    }
  };
}
function create_default_slot_110(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element2("button");
      button.textContent = "Delete remote";
      attr(button, "class", "mod-destructive");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", (0, import_obsidian19.debounce)(
          /*handleDeleteRemote*/
          ctx[8]
        ));
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block9(ctx) {
  let settingitem;
  let current;
  settingitem = new SettingItem_default({
    props: {
      description: "",
      $$slots: {
        name: [create_name_slot3],
        default: [create_default_slot11]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const settingitem_changes = {};
      if (dirty & /*$$scope, $relayStore*/
      262160) {
        settingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem.$set(settingitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem, detaching);
    }
  };
}
function create_default_slot11(ctx) {
  let settingscontrol;
  let current;
  settingscontrol = new SettingsControl_default({});
  settingscontrol.$on("settings", function() {
    if (is_function((0, import_obsidian19.debounce)(
      /*settings_handler*/
      ctx[14]
    )))
      (0, import_obsidian19.debounce)(
        /*settings_handler*/
        ctx[14]
      ).apply(this, arguments);
  });
  return {
    c() {
      create_component(settingscontrol.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingscontrol, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    i(local) {
      if (current)
        return;
      transition_in(settingscontrol.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingscontrol.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingscontrol, detaching);
    }
  };
}
function create_name_slot3(ctx) {
  let span;
  let satellite;
  let t_value = (
    /*$relayStore*/
    ctx[4].name + ""
  );
  let t2;
  let current;
  satellite = new satellite_default({ props: { class: "svg-icon" } });
  return {
    c() {
      span = element2("span");
      create_component(satellite.$$.fragment);
      t2 = text2(t_value);
      attr(span, "slot", "name");
      set_style(span, "display", "inline-flex");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      mount_component(satellite, span, null);
      append2(span, t2);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty & /*$relayStore*/
      16) && t_value !== (t_value = /*$relayStore*/
      ctx2[4].name + ""))
        set_data(t2, t_value);
    },
    i(local) {
      if (current)
        return;
      transition_in(satellite.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(satellite.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      destroy_component(satellite);
    }
  };
}
function create_fragment24(ctx) {
  let h3;
  let folder;
  let t0;
  let settingitemheading0;
  let t1;
  let settingitem0;
  let t2;
  let settingitem1;
  let t3;
  let t4;
  let settingitemheading1;
  let t5;
  let if_block1_anchor;
  let current;
  folder = new Folder_default({
    props: { folder: (
      /*sharedFolder*/
      ctx[1]
    ) }
  });
  settingitemheading0 = new SettingItemHeading_default({ props: { name: "Local folder" } });
  settingitem0 = new SettingItem_default({
    props: {
      name: "Delete from vault",
      description: "Delete the local Shared Folder and all of its contents.",
      $$slots: { default: [create_default_slot_34] },
      $$scope: { ctx }
    }
  });
  settingitem1 = new SettingItem_default({
    props: {
      name: "Delete metadata",
      description: "Deletes edit history and disables change tracking.",
      $$slots: { default: [create_default_slot_24] },
      $$scope: { ctx }
    }
  });
  let if_block0 = (
    /*$relayStore*/
    ctx[4] && create_if_block_14(ctx)
  );
  settingitemheading1 = new SettingItemHeading_default({ props: { name: "Relay" } });
  let if_block1 = (
    /*$relayStore*/
    ctx[4] && create_if_block9(ctx)
  );
  return {
    c() {
      h3 = element2("h3");
      create_component(folder.$$.fragment);
      t0 = space();
      create_component(settingitemheading0.$$.fragment);
      t1 = space();
      create_component(settingitem0.$$.fragment);
      t2 = space();
      create_component(settingitem1.$$.fragment);
      t3 = space();
      if (if_block0)
        if_block0.c();
      t4 = space();
      create_component(settingitemheading1.$$.fragment);
      t5 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      insert(target, h3, anchor);
      mount_component(folder, h3, null);
      insert(target, t0, anchor);
      mount_component(settingitemheading0, target, anchor);
      insert(target, t1, anchor);
      mount_component(settingitem0, target, anchor);
      insert(target, t2, anchor);
      mount_component(settingitem1, target, anchor);
      insert(target, t3, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t4, anchor);
      mount_component(settingitemheading1, target, anchor);
      insert(target, t5, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const folder_changes = {};
      if (dirty & /*sharedFolder*/
      2)
        folder_changes.folder = /*sharedFolder*/
        ctx2[1];
      folder.$set(folder_changes);
      const settingitem0_changes = {};
      if (dirty & /*$$scope*/
      262144) {
        settingitem0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem0.$set(settingitem0_changes);
      const settingitem1_changes = {};
      if (dirty & /*$$scope, $relayStore*/
      262160) {
        settingitem1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem1.$set(settingitem1_changes);
      if (
        /*$relayStore*/
        ctx2[4]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*$relayStore*/
          16) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_14(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t4.parentNode, t4);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*$relayStore*/
        ctx2[4]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*$relayStore*/
          16) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block9(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(folder.$$.fragment, local);
      transition_in(settingitemheading0.$$.fragment, local);
      transition_in(settingitem0.$$.fragment, local);
      transition_in(settingitem1.$$.fragment, local);
      transition_in(if_block0);
      transition_in(settingitemheading1.$$.fragment, local);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(folder.$$.fragment, local);
      transition_out(settingitemheading0.$$.fragment, local);
      transition_out(settingitem0.$$.fragment, local);
      transition_out(settingitem1.$$.fragment, local);
      transition_out(if_block0);
      transition_out(settingitemheading1.$$.fragment, local);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(h3);
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(t4);
        detach(t5);
        detach(if_block1_anchor);
      }
      destroy_component(folder);
      destroy_component(settingitemheading0, detaching);
      destroy_component(settingitem0, detaching);
      destroy_component(settingitem1, detaching);
      if (if_block0)
        if_block0.d(detaching);
      destroy_component(settingitemheading1, detaching);
      if (if_block1)
        if_block1.d(detaching);
    }
  };
}
function instance24($$self, $$props, $$invalidate) {
  let $folderStore;
  let $sharedFolders, $$unsubscribe_sharedFolders = noop, $$subscribe_sharedFolders = () => ($$unsubscribe_sharedFolders(), $$unsubscribe_sharedFolders = subscribe2(sharedFolders, ($$value) => $$invalidate(15, $sharedFolders = $$value)), sharedFolders);
  let $relayStore;
  $$self.$$.on_destroy.push(() => $$unsubscribe_sharedFolders());
  let { plugin } = $$props;
  let { sharedFolder } = $$props;
  let { sharedFolders } = $$props;
  $$subscribe_sharedFolders();
  let { relayRoles } = $$props;
  let folderStore = derived($sharedFolders, ($sharedFolders2) => {
    return $sharedFolders2.find((folder) => folder === sharedFolder);
  });
  component_subscribe($$self, folderStore, (value) => $$invalidate(3, $folderStore = value));
  let relayStore = derived([folderStore, relayRoles], ([$folderStore2, $relayRoles]) => {
    var _a2;
    return (_a2 = $relayRoles.find((role) => {
      var _a3;
      return role.relay === ((_a3 = $folderStore2 === null || $folderStore2 === void 0 ? void 0 : $folderStore2.remote) === null || _a3 === void 0 ? void 0 : _a3.relay);
    })) === null || _a2 === void 0 ? void 0 : _a2.relay;
  });
  component_subscribe($$self, relayStore, (value) => $$invalidate(4, $relayStore = value));
  let nameInput;
  onMount(() => {
    if (!sharedFolder && nameInput && nameInput.value === "") {
      nameInput.focus();
    }
  });
  const dispatch = createEventDispatcher();
  function handleManageRelay(relay) {
    if (!relay) {
      return;
    }
    dispatch("manageRelay", { relay });
  }
  function handleDeleteRemote() {
    return __awaiter(this, void 0, void 0, function* () {
      yield plugin.relayManager.deleteRemote(sharedFolder);
      plugin.sharedFolders.notifyListeners();
    });
  }
  function handleDeleteMetadata() {
    return __awaiter(this, void 0, void 0, function* () {
      if ($folderStore) {
        plugin.sharedFolders.delete($folderStore);
      }
      dispatch("goBack", { clear: true });
    });
  }
  function handleDeleteLocal() {
    const folder = plugin.vault.getFolderByPath(sharedFolder.path);
    if (folder) {
      plugin.app.vault.trash(folder, false);
    }
    dispatch("goBack", {});
  }
  const click_handler = () => {
    handleDeleteLocal();
  };
  const click_handler_1 = () => {
    handleDeleteMetadata();
  };
  const settings_handler = () => {
    handleManageRelay($relayStore);
  };
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(0, plugin = $$props2.plugin);
    if ("sharedFolder" in $$props2)
      $$invalidate(1, sharedFolder = $$props2.sharedFolder);
    if ("sharedFolders" in $$props2)
      $$subscribe_sharedFolders($$invalidate(2, sharedFolders = $$props2.sharedFolders));
    if ("relayRoles" in $$props2)
      $$invalidate(11, relayRoles = $$props2.relayRoles);
  };
  return [
    plugin,
    sharedFolder,
    sharedFolders,
    $folderStore,
    $relayStore,
    folderStore,
    relayStore,
    handleManageRelay,
    handleDeleteRemote,
    handleDeleteMetadata,
    handleDeleteLocal,
    relayRoles,
    click_handler,
    click_handler_1,
    settings_handler
  ];
}
var ManageSharedFolder = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance24, create_fragment24, safe_not_equal, {
      plugin: 0,
      sharedFolder: 1,
      sharedFolders: 2,
      relayRoles: 11
    });
  }
};
var ManageSharedFolder_default = ManageSharedFolder;

// src/components/PluginSettings.svelte
function add_css9(target) {
  append_styles(target, "svelte-p7bayo", ".vertical-tab-content.svelte-p7bayo{max-height:var(--modal-max-height)}");
}
function create_if_block_24(ctx) {
  let modalsettingsnav;
  let current;
  modalsettingsnav = new ModalSettingsNav_default({});
  modalsettingsnav.$on(
    "goBack",
    /*handleGoBack*/
    ctx[9]
  );
  return {
    c() {
      create_component(modalsettingsnav.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modalsettingsnav, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(modalsettingsnav.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modalsettingsnav.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modalsettingsnav, detaching);
    }
  };
}
function create_else_block6(ctx) {
  let loggedin;
  let current;
  loggedin = new LoggedIn_default({
    props: {
      plugin: (
        /*plugin*/
        ctx[0]
      ),
      $$slots: { default: [create_default_slot12] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(loggedin.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loggedin, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const loggedin_changes = {};
      if (dirty & /*plugin*/
      1)
        loggedin_changes.plugin = /*plugin*/
        ctx2[0];
      if (dirty & /*$$scope, plugin*/
      262145) {
        loggedin_changes.$$scope = { dirty, ctx: ctx2 };
      }
      loggedin.$set(loggedin_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(loggedin.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loggedin.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loggedin, detaching);
    }
  };
}
function create_if_block_15(ctx) {
  let managerelay;
  let current;
  managerelay = new ManageRelay_default({
    props: {
      plugin: (
        /*plugin*/
        ctx[0]
      ),
      relayRoles: (
        /*relayRoles*/
        ctx[3]
      ),
      relay: (
        /*currentRelay*/
        ctx[2]
      ),
      sharedFolders: (
        /*sharedFolders*/
        ctx[5]
      )
    }
  });
  managerelay.$on(
    "goBack",
    /*handleGoBack*/
    ctx[9]
  );
  managerelay.$on(
    "close",
    /*handleClose*/
    ctx[10]
  );
  managerelay.$on(
    "manageSharedFolder",
    /*handleManageSharedFolderEvent*/
    ctx[7]
  );
  return {
    c() {
      create_component(managerelay.$$.fragment);
    },
    m(target, anchor) {
      mount_component(managerelay, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const managerelay_changes = {};
      if (dirty & /*plugin*/
      1)
        managerelay_changes.plugin = /*plugin*/
        ctx2[0];
      if (dirty & /*currentRelay*/
      4)
        managerelay_changes.relay = /*currentRelay*/
        ctx2[2];
      managerelay.$set(managerelay_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(managerelay.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(managerelay.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(managerelay, detaching);
    }
  };
}
function create_if_block10(ctx) {
  let managesharedfolder;
  let current;
  managesharedfolder = new ManageSharedFolder_default({
    props: {
      plugin: (
        /*plugin*/
        ctx[0]
      ),
      relayRoles: (
        /*relayRoles*/
        ctx[3]
      ),
      sharedFolder: (
        /*sharedFolder*/
        ctx[1]
      ),
      sharedFolders: (
        /*sharedFolders*/
        ctx[5]
      )
    }
  });
  managesharedfolder.$on(
    "goBack",
    /*handleGoBack*/
    ctx[9]
  );
  managesharedfolder.$on(
    "close",
    /*handleClose*/
    ctx[10]
  );
  managesharedfolder.$on(
    "manageRelay",
    /*handleManageRelayEvent*/
    ctx[6]
  );
  return {
    c() {
      create_component(managesharedfolder.$$.fragment);
    },
    m(target, anchor) {
      mount_component(managesharedfolder, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const managesharedfolder_changes = {};
      if (dirty & /*plugin*/
      1)
        managesharedfolder_changes.plugin = /*plugin*/
        ctx2[0];
      if (dirty & /*sharedFolder*/
      2)
        managesharedfolder_changes.sharedFolder = /*sharedFolder*/
        ctx2[1];
      managesharedfolder.$set(managesharedfolder_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(managesharedfolder.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(managesharedfolder.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(managesharedfolder, detaching);
    }
  };
}
function create_default_slot12(ctx) {
  let relays_1;
  let current;
  relays_1 = new Relays_default({
    props: {
      relays: (
        /*relays*/
        ctx[4]
      ),
      plugin: (
        /*plugin*/
        ctx[0]
      )
    }
  });
  relays_1.$on(
    "manageRelay",
    /*handleManageRelayEvent*/
    ctx[6]
  );
  relays_1.$on(
    "manageSharedFolder",
    /*handleManageSharedFolderEvent*/
    ctx[7]
  );
  relays_1.$on(
    "createRelay",
    /*handleCreateRelayEvent*/
    ctx[8]
  );
  relays_1.$on(
    "joinRelay",
    /*handleJoinRelay*/
    ctx[11]
  );
  return {
    c() {
      create_component(relays_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(relays_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const relays_1_changes = {};
      if (dirty & /*plugin*/
      1)
        relays_1_changes.plugin = /*plugin*/
        ctx2[0];
      relays_1.$set(relays_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(relays_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(relays_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(relays_1, detaching);
    }
  };
}
function create_fragment25(ctx) {
  let t2;
  let div;
  let current_block_type_index;
  let if_block1;
  let current;
  let if_block0 = (
    /*currentRelay*/
    (ctx[2] || /*sharedFolder*/
    ctx[1]) && create_if_block_24(ctx)
  );
  const if_block_creators = [create_if_block10, create_if_block_15, create_else_block6];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*sharedFolder*/
      ctx2[1]
    )
      return 0;
    if (
      /*currentRelay*/
      ctx2[2]
    )
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t2 = space();
      div = element2("div");
      if_block1.c();
      attr(div, "class", "vertical-tab-content svelte-p7bayo");
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t2, anchor);
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*currentRelay*/
        ctx2[2] || /*sharedFolder*/
        ctx2[1]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*currentRelay, sharedFolder*/
          6) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_24(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t2.parentNode, t2);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(div, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(div);
      }
      if (if_block0)
        if_block0.d(detaching);
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance25($$self, $$props, $$invalidate) {
  let $relays;
  let { plugin } = $$props;
  const app = plugin.app;
  const relayManager = plugin.relayManager;
  const relayRoles = relayManager.relayRoles;
  const relays = relayManager.relays;
  component_subscribe($$self, relays, (value) => $$invalidate(13, $relays = value));
  const sharedFolders = plugin.sharedFolders;
  let sharedFolder;
  let currentComponent = Relays_default;
  let currentRelay;
  const history = [{ component: Relays_default }];
  let { close } = $$props;
  function handleManageRelayEvent(event) {
    history.push({
      currentRelay,
      sharedFolder,
      component: currentComponent
    });
    $$invalidate(2, currentRelay = event.detail.relay);
    $$invalidate(1, sharedFolder = void 0);
    currentComponent = ManageRelay_default;
  }
  function handleManageSharedFolderEvent(event) {
    history.push({
      currentRelay,
      sharedFolder,
      component: currentComponent
    });
    $$invalidate(1, sharedFolder = event.detail.folder);
    $$invalidate(2, currentRelay = event.detail.relay);
  }
  function handleCreateRelayEvent(event) {
    return __awaiter(this, void 0, void 0, function* () {
      history.push({
        currentRelay,
        sharedFolder,
        component: currentComponent
      });
      $$invalidate(2, currentRelay = yield plugin.relayManager.createRelay(""));
      currentComponent = ManageRelay_default;
    });
  }
  function handleGoBack(event) {
    if (event.detail.clear) {
      history.length = 0;
      $$invalidate(2, currentRelay = void 0);
      $$invalidate(1, sharedFolder = void 0);
      currentComponent = Relays_default;
      return;
    }
    let view = history.pop();
    if (view) {
      while (view) {
        if (!view.currentRelay && !view.sharedFolder) {
          $$invalidate(2, currentRelay = view.currentRelay);
          $$invalidate(1, sharedFolder = view.sharedFolder);
          currentComponent = view.component;
        } else if (view.sharedFolder && sharedFolders.has(view.sharedFolder)) {
          $$invalidate(2, currentRelay = view.currentRelay);
          $$invalidate(1, sharedFolder = view.sharedFolder);
          currentComponent = view.component;
          break;
        } else if (view.currentRelay && relayManager.relays.get(view.currentRelay.id)) {
          $$invalidate(2, currentRelay = view.currentRelay);
          $$invalidate(1, sharedFolder = view.sharedFolder);
          currentComponent = view.component;
          break;
        }
        view = history.pop();
      }
    } else {
      $$invalidate(2, currentRelay = void 0);
      $$invalidate(1, sharedFolder = void 0);
      currentComponent = Relays_default;
    }
  }
  function handleClose(event) {
    history.length = 0;
    close();
  }
  function handleJoinRelay(event) {
    $$invalidate(2, currentRelay = event.detail.relay);
    currentComponent = ManageRelay_default;
  }
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(0, plugin = $$props2.plugin);
    if ("close" in $$props2)
      $$invalidate(12, close = $$props2.close);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*currentRelay, $relays*/
    8196) {
      $: {
        if (currentRelay && !$relays.has(currentRelay.id)) {
          $$invalidate(2, currentRelay = void 0);
          currentComponent = Relays_default;
        }
      }
    }
    if ($$self.$$.dirty & /*sharedFolder*/
    2) {
      $: {
        if (sharedFolder && !sharedFolders.has(sharedFolder)) {
          $$invalidate(1, sharedFolder = void 0);
          currentComponent = Relays_default;
        }
      }
    }
  };
  return [
    plugin,
    sharedFolder,
    currentRelay,
    relayRoles,
    relays,
    sharedFolders,
    handleManageRelayEvent,
    handleManageSharedFolderEvent,
    handleCreateRelayEvent,
    handleGoBack,
    handleClose,
    handleJoinRelay,
    close,
    $relays
  ];
}
var PluginSettings = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance25, create_fragment25, safe_not_equal, { plugin: 0, close: 12 }, add_css9);
  }
};
var PluginSettings_default = PluginSettings;

// src/ui/SettingsTab.ts
var LiveSettingsTab = class extends import_obsidian20.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    this.targetEl = containerEl.parentElement;
    this.targetEl.empty();
    this.plugin.relayManager.update();
    this.component = new PluginSettings_default({
      target: this.targetEl,
      props: {
        plugin: this.plugin,
        close: () => {
          this.setting.close();
        }
      }
    });
  }
  hide() {
    var _a2;
    try {
      (_a2 = this.component) == null ? void 0 : _a2.$destroy();
    } catch (e2) {
    }
  }
};

// src/LoginManager.ts
var import_obsidian21 = require("obsidian");

// src/User.ts
var usercolors = [
  { color: "#30bced", light: "#30bced33" },
  { color: "#6eeb83", light: "#6eeb8333" },
  { color: "#ffbc42", light: "#ffbc4233" },
  { color: "#ecd444", light: "#ecd44433" },
  { color: "#ee6352", light: "#ee635233" },
  { color: "#9ac2c9", light: "#9ac2c933" },
  { color: "#8acb88", light: "#8acb8833" },
  { color: "#1be7ff", light: "#1be7ff33" }
];
var User = class {
  constructor(id2, name, token) {
    this.id = id2;
    this.name = name;
    this.token = token;
    this.color = usercolors[uint32() % usercolors.length];
  }
};

// node_modules/pocketbase/dist/pocketbase.es.mjs
var ClientResponseError = class extends Error {
  constructor(e2) {
    var _a2, _b2, _c, _d;
    super("ClientResponseError"), this.url = "", this.status = 0, this.response = {}, this.isAbort = false, this.originalError = null, Object.setPrototypeOf(this, ClientResponseError.prototype), null !== e2 && "object" == typeof e2 && (this.url = "string" == typeof e2.url ? e2.url : "", this.status = "number" == typeof e2.status ? e2.status : 0, this.isAbort = !!e2.isAbort, this.originalError = e2.originalError, null !== e2.response && "object" == typeof e2.response ? this.response = e2.response : null !== e2.data && "object" == typeof e2.data ? this.response = e2.data : this.response = {}), this.originalError || e2 instanceof ClientResponseError || (this.originalError = e2), "undefined" != typeof DOMException && e2 instanceof DOMException && (this.isAbort = true), this.name = "ClientResponseError " + this.status, this.message = (_a2 = this.response) == null ? void 0 : _a2.message, this.message || (this.isAbort ? this.message = "The request was autocancelled. You can find more info in https://github.com/pocketbase/js-sdk#auto-cancellation." : ((_d = (_c = (_b2 = this.originalError) == null ? void 0 : _b2.cause) == null ? void 0 : _c.message) == null ? void 0 : _d.includes("ECONNREFUSED ::1")) ? this.message = "Failed to connect to the PocketBase server. Try changing the SDK URL from localhost to 127.0.0.1 (https://github.com/pocketbase/js-sdk/issues/21)." : this.message = "Something went wrong while processing your request.");
  }
  get data() {
    return this.response;
  }
  toJSON() {
    return { ...this };
  }
};
var e = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
function cookieParse(e2, t2) {
  const s2 = {};
  if ("string" != typeof e2)
    return s2;
  const i2 = Object.assign({}, t2 || {}).decode || defaultDecode;
  let n = 0;
  for (; n < e2.length; ) {
    const t3 = e2.indexOf("=", n);
    if (-1 === t3)
      break;
    let r = e2.indexOf(";", n);
    if (-1 === r)
      r = e2.length;
    else if (r < t3) {
      n = e2.lastIndexOf(";", t3 - 1) + 1;
      continue;
    }
    const o = e2.slice(n, t3).trim();
    if (void 0 === s2[o]) {
      let n2 = e2.slice(t3 + 1, r).trim();
      34 === n2.charCodeAt(0) && (n2 = n2.slice(1, -1));
      try {
        s2[o] = i2(n2);
      } catch (e3) {
        s2[o] = n2;
      }
    }
    n = r + 1;
  }
  return s2;
}
function cookieSerialize(t2, s2, i2) {
  const n = Object.assign({}, i2 || {}), r = n.encode || defaultEncode;
  if (!e.test(t2))
    throw new TypeError("argument name is invalid");
  const o = r(s2);
  if (o && !e.test(o))
    throw new TypeError("argument val is invalid");
  let a = t2 + "=" + o;
  if (null != n.maxAge) {
    const e2 = n.maxAge - 0;
    if (isNaN(e2) || !isFinite(e2))
      throw new TypeError("option maxAge is invalid");
    a += "; Max-Age=" + Math.floor(e2);
  }
  if (n.domain) {
    if (!e.test(n.domain))
      throw new TypeError("option domain is invalid");
    a += "; Domain=" + n.domain;
  }
  if (n.path) {
    if (!e.test(n.path))
      throw new TypeError("option path is invalid");
    a += "; Path=" + n.path;
  }
  if (n.expires) {
    if (!function isDate(e2) {
      return "[object Date]" === Object.prototype.toString.call(e2) || e2 instanceof Date;
    }(n.expires) || isNaN(n.expires.valueOf()))
      throw new TypeError("option expires is invalid");
    a += "; Expires=" + n.expires.toUTCString();
  }
  if (n.httpOnly && (a += "; HttpOnly"), n.secure && (a += "; Secure"), n.priority) {
    switch ("string" == typeof n.priority ? n.priority.toLowerCase() : n.priority) {
      case "low":
        a += "; Priority=Low";
        break;
      case "medium":
        a += "; Priority=Medium";
        break;
      case "high":
        a += "; Priority=High";
        break;
      default:
        throw new TypeError("option priority is invalid");
    }
  }
  if (n.sameSite) {
    switch ("string" == typeof n.sameSite ? n.sameSite.toLowerCase() : n.sameSite) {
      case true:
        a += "; SameSite=Strict";
        break;
      case "lax":
        a += "; SameSite=Lax";
        break;
      case "strict":
        a += "; SameSite=Strict";
        break;
      case "none":
        a += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return a;
}
function defaultDecode(e2) {
  return -1 !== e2.indexOf("%") ? decodeURIComponent(e2) : e2;
}
function defaultEncode(e2) {
  return encodeURIComponent(e2);
}
var t;
function getTokenPayload(e2) {
  if (e2)
    try {
      const s2 = decodeURIComponent(t(e2.split(".")[1]).split("").map(function(e3) {
        return "%" + ("00" + e3.charCodeAt(0).toString(16)).slice(-2);
      }).join(""));
      return JSON.parse(s2) || {};
    } catch (e3) {
    }
  return {};
}
function isTokenExpired(e2, t2 = 0) {
  let s2 = getTokenPayload(e2);
  return !(Object.keys(s2).length > 0 && (!s2.exp || s2.exp - t2 > Date.now() / 1e3));
}
t = "function" == typeof atob ? atob : (e2) => {
  let t2 = String(e2).replace(/=+$/, "");
  if (t2.length % 4 == 1)
    throw new Error("'atob' failed: The string to be decoded is not correctly encoded.");
  for (var s2, i2, n = 0, r = 0, o = ""; i2 = t2.charAt(r++); ~i2 && (s2 = n % 4 ? 64 * s2 + i2 : i2, n++ % 4) ? o += String.fromCharCode(255 & s2 >> (-2 * n & 6)) : 0)
    i2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(i2);
  return o;
};
var s = "pb_auth";
var BaseAuthStore = class {
  constructor() {
    this.baseToken = "", this.baseModel = null, this._onChangeCallbacks = [];
  }
  get token() {
    return this.baseToken;
  }
  get model() {
    return this.baseModel;
  }
  get isValid() {
    return !isTokenExpired(this.token);
  }
  get isAdmin() {
    return "admin" === getTokenPayload(this.token).type;
  }
  get isAuthRecord() {
    return "authRecord" === getTokenPayload(this.token).type;
  }
  save(e2, t2) {
    this.baseToken = e2 || "", this.baseModel = t2 || null, this.triggerChange();
  }
  clear() {
    this.baseToken = "", this.baseModel = null, this.triggerChange();
  }
  loadFromCookie(e2, t2 = s) {
    const i2 = cookieParse(e2 || "")[t2] || "";
    let n = {};
    try {
      n = JSON.parse(i2), (null === typeof n || "object" != typeof n || Array.isArray(n)) && (n = {});
    } catch (e3) {
    }
    this.save(n.token || "", n.model || null);
  }
  exportToCookie(e2, t2 = s) {
    var _a2, _b2;
    const i2 = { secure: true, sameSite: true, httpOnly: true, path: "/" }, n = getTokenPayload(this.token);
    i2.expires = (n == null ? void 0 : n.exp) ? new Date(1e3 * n.exp) : new Date("1970-01-01"), e2 = Object.assign({}, i2, e2);
    const r = { token: this.token, model: this.model ? JSON.parse(JSON.stringify(this.model)) : null };
    let o = cookieSerialize(t2, JSON.stringify(r), e2);
    const a = "undefined" != typeof Blob ? new Blob([o]).size : o.length;
    if (r.model && a > 4096) {
      r.model = { id: (_a2 = r == null ? void 0 : r.model) == null ? void 0 : _a2.id, email: (_b2 = r == null ? void 0 : r.model) == null ? void 0 : _b2.email };
      const s2 = ["collectionId", "username", "verified"];
      for (const e3 in this.model)
        s2.includes(e3) && (r.model[e3] = this.model[e3]);
      o = cookieSerialize(t2, JSON.stringify(r), e2);
    }
    return o;
  }
  onChange(e2, t2 = false) {
    return this._onChangeCallbacks.push(e2), t2 && e2(this.token, this.model), () => {
      for (let t3 = this._onChangeCallbacks.length - 1; t3 >= 0; t3--)
        if (this._onChangeCallbacks[t3] == e2)
          return delete this._onChangeCallbacks[t3], void this._onChangeCallbacks.splice(t3, 1);
    };
  }
  triggerChange() {
    for (const e2 of this._onChangeCallbacks)
      e2 && e2(this.token, this.model);
  }
};
var LocalAuthStore = class extends BaseAuthStore {
  constructor(e2 = "pocketbase_auth") {
    super(), this.storageFallback = {}, this.storageKey = e2, this._bindStorageEvent();
  }
  get token() {
    return (this._storageGet(this.storageKey) || {}).token || "";
  }
  get model() {
    return (this._storageGet(this.storageKey) || {}).model || null;
  }
  save(e2, t2) {
    this._storageSet(this.storageKey, { token: e2, model: t2 }), super.save(e2, t2);
  }
  clear() {
    this._storageRemove(this.storageKey), super.clear();
  }
  _storageGet(e2) {
    if ("undefined" != typeof window && (window == null ? void 0 : window.localStorage)) {
      const t2 = window.localStorage.getItem(e2) || "";
      try {
        return JSON.parse(t2);
      } catch (e3) {
        return t2;
      }
    }
    return this.storageFallback[e2];
  }
  _storageSet(e2, t2) {
    if ("undefined" != typeof window && (window == null ? void 0 : window.localStorage)) {
      let s2 = t2;
      "string" != typeof t2 && (s2 = JSON.stringify(t2)), window.localStorage.setItem(e2, s2);
    } else
      this.storageFallback[e2] = t2;
  }
  _storageRemove(e2) {
    var _a2;
    "undefined" != typeof window && (window == null ? void 0 : window.localStorage) && ((_a2 = window.localStorage) == null ? void 0 : _a2.removeItem(e2)), delete this.storageFallback[e2];
  }
  _bindStorageEvent() {
    "undefined" != typeof window && (window == null ? void 0 : window.localStorage) && window.addEventListener && window.addEventListener("storage", (e2) => {
      if (e2.key != this.storageKey)
        return;
      const t2 = this._storageGet(this.storageKey) || {};
      super.save(t2.token || "", t2.model || null);
    });
  }
};
var BaseService = class {
  constructor(e2) {
    this.client = e2;
  }
};
var SettingsService = class extends BaseService {
  async getAll(e2) {
    return e2 = Object.assign({ method: "GET" }, e2), this.client.send("/api/settings", e2);
  }
  async update(e2, t2) {
    return t2 = Object.assign({ method: "PATCH", body: e2 }, t2), this.client.send("/api/settings", t2);
  }
  async testS3(e2 = "storage", t2) {
    return t2 = Object.assign({ method: "POST", body: { filesystem: e2 } }, t2), this.client.send("/api/settings/test/s3", t2).then(() => true);
  }
  async testEmail(e2, t2, s2) {
    return s2 = Object.assign({ method: "POST", body: { email: e2, template: t2 } }, s2), this.client.send("/api/settings/test/email", s2).then(() => true);
  }
  async generateAppleClientSecret(e2, t2, s2, i2, n, r) {
    return r = Object.assign({ method: "POST", body: { clientId: e2, teamId: t2, keyId: s2, privateKey: i2, duration: n } }, r), this.client.send("/api/settings/apple/generate-client-secret", r);
  }
};
var CrudService = class extends BaseService {
  decode(e2) {
    return e2;
  }
  async getFullList(e2, t2) {
    if ("number" == typeof e2)
      return this._getFullList(e2, t2);
    let s2 = 500;
    return (t2 = Object.assign({}, e2, t2)).batch && (s2 = t2.batch, delete t2.batch), this._getFullList(s2, t2);
  }
  async getList(e2 = 1, t2 = 30, s2) {
    return (s2 = Object.assign({ method: "GET" }, s2)).query = Object.assign({ page: e2, perPage: t2 }, s2.query), this.client.send(this.baseCrudPath, s2).then((e3) => {
      var _a2;
      return e3.items = ((_a2 = e3.items) == null ? void 0 : _a2.map((e4) => this.decode(e4))) || [], e3;
    });
  }
  async getFirstListItem(e2, t2) {
    return (t2 = Object.assign({ requestKey: "one_by_filter_" + this.baseCrudPath + "_" + e2 }, t2)).query = Object.assign({ filter: e2, skipTotal: 1 }, t2.query), this.getList(1, 1, t2).then((e3) => {
      var _a2;
      if (!((_a2 = e3 == null ? void 0 : e3.items) == null ? void 0 : _a2.length))
        throw new ClientResponseError({ status: 404, response: { code: 404, message: "The requested resource wasn't found.", data: {} } });
      return e3.items[0];
    });
  }
  async getOne(e2, t2) {
    if (!e2)
      throw new ClientResponseError({ url: this.client.buildUrl(this.baseCrudPath + "/"), status: 404, response: { code: 404, message: "Missing required record id.", data: {} } });
    return t2 = Object.assign({ method: "GET" }, t2), this.client.send(this.baseCrudPath + "/" + encodeURIComponent(e2), t2).then((e3) => this.decode(e3));
  }
  async create(e2, t2) {
    return t2 = Object.assign({ method: "POST", body: e2 }, t2), this.client.send(this.baseCrudPath, t2).then((e3) => this.decode(e3));
  }
  async update(e2, t2, s2) {
    return s2 = Object.assign({ method: "PATCH", body: t2 }, s2), this.client.send(this.baseCrudPath + "/" + encodeURIComponent(e2), s2).then((e3) => this.decode(e3));
  }
  async delete(e2, t2) {
    return t2 = Object.assign({ method: "DELETE" }, t2), this.client.send(this.baseCrudPath + "/" + encodeURIComponent(e2), t2).then(() => true);
  }
  _getFullList(e2 = 500, t2) {
    (t2 = t2 || {}).query = Object.assign({ skipTotal: 1 }, t2.query);
    let s2 = [], request = async (i2) => this.getList(i2, e2 || 500, t2).then((e3) => {
      const t3 = e3.items;
      return s2 = s2.concat(t3), t3.length == e3.perPage ? request(i2 + 1) : s2;
    });
    return request(1);
  }
};
function normalizeLegacyOptionsArgs(e2, t2, s2, i2) {
  const n = void 0 !== i2;
  return n || void 0 !== s2 ? n ? (console.warn(e2), t2.body = Object.assign({}, t2.body, s2), t2.query = Object.assign({}, t2.query, i2), t2) : Object.assign(t2, s2) : t2;
}
function resetAutoRefresh(e2) {
  var _a2;
  (_a2 = e2._resetAutoRefresh) == null ? void 0 : _a2.call(e2);
}
var AdminService = class extends CrudService {
  get baseCrudPath() {
    return "/api/admins";
  }
  async update(e2, t2, s2) {
    return super.update(e2, t2, s2).then((e3) => {
      var _a2, _b2;
      return ((_a2 = this.client.authStore.model) == null ? void 0 : _a2.id) === e3.id && void 0 === ((_b2 = this.client.authStore.model) == null ? void 0 : _b2.collectionId) && this.client.authStore.save(this.client.authStore.token, e3), e3;
    });
  }
  async delete(e2, t2) {
    return super.delete(e2, t2).then((t3) => {
      var _a2, _b2;
      return t3 && ((_a2 = this.client.authStore.model) == null ? void 0 : _a2.id) === e2 && void 0 === ((_b2 = this.client.authStore.model) == null ? void 0 : _b2.collectionId) && this.client.authStore.clear(), t3;
    });
  }
  authResponse(e2) {
    const t2 = this.decode((e2 == null ? void 0 : e2.admin) || {});
    return (e2 == null ? void 0 : e2.token) && (e2 == null ? void 0 : e2.admin) && this.client.authStore.save(e2.token, t2), Object.assign({}, e2, { token: (e2 == null ? void 0 : e2.token) || "", admin: t2 });
  }
  async authWithPassword(e2, t2, s2, i2) {
    let n = { method: "POST", body: { identity: e2, password: t2 } };
    n = normalizeLegacyOptionsArgs("This form of authWithPassword(email, pass, body?, query?) is deprecated. Consider replacing it with authWithPassword(email, pass, options?).", n, s2, i2);
    const r = n.autoRefreshThreshold;
    delete n.autoRefreshThreshold, n.autoRefresh || resetAutoRefresh(this.client);
    let o = await this.client.send(this.baseCrudPath + "/auth-with-password", n);
    return o = this.authResponse(o), r && function registerAutoRefresh(e3, t3, s3, i3) {
      resetAutoRefresh(e3);
      const n2 = e3.beforeSend, r2 = e3.authStore.model, o2 = e3.authStore.onChange((t4, s4) => {
        (!t4 || (s4 == null ? void 0 : s4.id) != (r2 == null ? void 0 : r2.id) || ((s4 == null ? void 0 : s4.collectionId) || (r2 == null ? void 0 : r2.collectionId)) && (s4 == null ? void 0 : s4.collectionId) != (r2 == null ? void 0 : r2.collectionId)) && resetAutoRefresh(e3);
      });
      e3._resetAutoRefresh = function() {
        o2(), e3.beforeSend = n2, delete e3._resetAutoRefresh;
      }, e3.beforeSend = async (r3, o3) => {
        var _a2;
        const a = e3.authStore.token;
        if ((_a2 = o3.query) == null ? void 0 : _a2.autoRefresh)
          return n2 ? n2(r3, o3) : { url: r3, sendOptions: o3 };
        let c = e3.authStore.isValid;
        if (c && isTokenExpired(e3.authStore.token, t3))
          try {
            await s3();
          } catch (e4) {
            c = false;
          }
        c || await i3();
        const l = o3.headers || {};
        for (let t4 in l)
          if ("authorization" == t4.toLowerCase() && a == l[t4] && e3.authStore.token) {
            l[t4] = e3.authStore.token;
            break;
          }
        return o3.headers = l, n2 ? n2(r3, o3) : { url: r3, sendOptions: o3 };
      };
    }(this.client, r, () => this.authRefresh({ autoRefresh: true }), () => this.authWithPassword(e2, t2, Object.assign({ autoRefresh: true }, n))), o;
  }
  async authRefresh(e2, t2) {
    let s2 = { method: "POST" };
    return s2 = normalizeLegacyOptionsArgs("This form of authRefresh(body?, query?) is deprecated. Consider replacing it with authRefresh(options?).", s2, e2, t2), this.client.send(this.baseCrudPath + "/auth-refresh", s2).then(this.authResponse.bind(this));
  }
  async requestPasswordReset(e2, t2, s2) {
    let i2 = { method: "POST", body: { email: e2 } };
    return i2 = normalizeLegacyOptionsArgs("This form of requestPasswordReset(email, body?, query?) is deprecated. Consider replacing it with requestPasswordReset(email, options?).", i2, t2, s2), this.client.send(this.baseCrudPath + "/request-password-reset", i2).then(() => true);
  }
  async confirmPasswordReset(e2, t2, s2, i2, n) {
    let r = { method: "POST", body: { token: e2, password: t2, passwordConfirm: s2 } };
    return r = normalizeLegacyOptionsArgs("This form of confirmPasswordReset(resetToken, password, passwordConfirm, body?, query?) is deprecated. Consider replacing it with confirmPasswordReset(resetToken, password, passwordConfirm, options?).", r, i2, n), this.client.send(this.baseCrudPath + "/confirm-password-reset", r).then(() => true);
  }
};
var i = ["requestKey", "$cancelKey", "$autoCancel", "fetch", "headers", "body", "query", "params", "cache", "credentials", "headers", "integrity", "keepalive", "method", "mode", "redirect", "referrer", "referrerPolicy", "signal", "window"];
function normalizeUnknownQueryParams(e2) {
  if (e2) {
    e2.query = e2.query || {};
    for (let t2 in e2)
      i.includes(t2) || (e2.query[t2] = e2[t2], delete e2[t2]);
  }
}
var RealtimeService = class extends BaseService {
  constructor() {
    super(...arguments), this.clientId = "", this.eventSource = null, this.subscriptions = {}, this.lastSentSubscriptions = [], this.maxConnectTimeout = 15e3, this.reconnectAttempts = 0, this.maxReconnectAttempts = 1 / 0, this.predefinedReconnectIntervals = [200, 300, 500, 1e3, 1200, 1500, 2e3], this.pendingConnects = [];
  }
  get isConnected() {
    return !!this.eventSource && !!this.clientId && !this.pendingConnects.length;
  }
  async subscribe(e2, t2, s2) {
    var _a2;
    if (!e2)
      throw new Error("topic must be set.");
    let i2 = e2;
    if (s2) {
      normalizeUnknownQueryParams(s2);
      const e3 = "options=" + encodeURIComponent(JSON.stringify({ query: s2.query, headers: s2.headers }));
      i2 += (i2.includes("?") ? "&" : "?") + e3;
    }
    const listener = function(e3) {
      const s3 = e3;
      let i3;
      try {
        i3 = JSON.parse(s3 == null ? void 0 : s3.data);
      } catch (e4) {
      }
      t2(i3 || {});
    };
    return this.subscriptions[i2] || (this.subscriptions[i2] = []), this.subscriptions[i2].push(listener), this.isConnected ? 1 === this.subscriptions[i2].length ? await this.submitSubscriptions() : (_a2 = this.eventSource) == null ? void 0 : _a2.addEventListener(i2, listener) : await this.connect(), async () => this.unsubscribeByTopicAndListener(e2, listener);
  }
  async unsubscribe(e2) {
    var _a2;
    let t2 = false;
    if (e2) {
      const s2 = this.getSubscriptionsByTopic(e2);
      for (let e3 in s2)
        if (this.hasSubscriptionListeners(e3)) {
          for (let t3 of this.subscriptions[e3])
            (_a2 = this.eventSource) == null ? void 0 : _a2.removeEventListener(e3, t3);
          delete this.subscriptions[e3], t2 || (t2 = true);
        }
    } else
      this.subscriptions = {};
    this.hasSubscriptionListeners() ? t2 && await this.submitSubscriptions() : this.disconnect();
  }
  async unsubscribeByPrefix(e2) {
    var _a2;
    let t2 = false;
    for (let s2 in this.subscriptions)
      if ((s2 + "?").startsWith(e2)) {
        t2 = true;
        for (let e3 of this.subscriptions[s2])
          (_a2 = this.eventSource) == null ? void 0 : _a2.removeEventListener(s2, e3);
        delete this.subscriptions[s2];
      }
    t2 && (this.hasSubscriptionListeners() ? await this.submitSubscriptions() : this.disconnect());
  }
  async unsubscribeByTopicAndListener(e2, t2) {
    var _a2;
    let s2 = false;
    const i2 = this.getSubscriptionsByTopic(e2);
    for (let e3 in i2) {
      if (!Array.isArray(this.subscriptions[e3]) || !this.subscriptions[e3].length)
        continue;
      let i3 = false;
      for (let s3 = this.subscriptions[e3].length - 1; s3 >= 0; s3--)
        this.subscriptions[e3][s3] === t2 && (i3 = true, delete this.subscriptions[e3][s3], this.subscriptions[e3].splice(s3, 1), (_a2 = this.eventSource) == null ? void 0 : _a2.removeEventListener(e3, t2));
      i3 && (this.subscriptions[e3].length || delete this.subscriptions[e3], s2 || this.hasSubscriptionListeners(e3) || (s2 = true));
    }
    this.hasSubscriptionListeners() ? s2 && await this.submitSubscriptions() : this.disconnect();
  }
  hasSubscriptionListeners(e2) {
    var _a2, _b2;
    if (this.subscriptions = this.subscriptions || {}, e2)
      return !!((_a2 = this.subscriptions[e2]) == null ? void 0 : _a2.length);
    for (let e3 in this.subscriptions)
      if ((_b2 = this.subscriptions[e3]) == null ? void 0 : _b2.length)
        return true;
    return false;
  }
  async submitSubscriptions() {
    if (this.clientId)
      return this.addAllSubscriptionListeners(), this.lastSentSubscriptions = this.getNonEmptySubscriptionKeys(), this.client.send("/api/realtime", { method: "POST", body: { clientId: this.clientId, subscriptions: this.lastSentSubscriptions }, requestKey: this.getSubscriptionsCancelKey() }).catch((e2) => {
        if (!(e2 == null ? void 0 : e2.isAbort))
          throw e2;
      });
  }
  getSubscriptionsCancelKey() {
    return "realtime_" + this.clientId;
  }
  getSubscriptionsByTopic(e2) {
    const t2 = {};
    e2 = e2.includes("?") ? e2 : e2 + "?";
    for (let s2 in this.subscriptions)
      (s2 + "?").startsWith(e2) && (t2[s2] = this.subscriptions[s2]);
    return t2;
  }
  getNonEmptySubscriptionKeys() {
    const e2 = [];
    for (let t2 in this.subscriptions)
      this.subscriptions[t2].length && e2.push(t2);
    return e2;
  }
  addAllSubscriptionListeners() {
    if (this.eventSource) {
      this.removeAllSubscriptionListeners();
      for (let e2 in this.subscriptions)
        for (let t2 of this.subscriptions[e2])
          this.eventSource.addEventListener(e2, t2);
    }
  }
  removeAllSubscriptionListeners() {
    if (this.eventSource)
      for (let e2 in this.subscriptions)
        for (let t2 of this.subscriptions[e2])
          this.eventSource.removeEventListener(e2, t2);
  }
  async connect() {
    if (!(this.reconnectAttempts > 0))
      return new Promise((e2, t2) => {
        this.pendingConnects.push({ resolve: e2, reject: t2 }), this.pendingConnects.length > 1 || this.initConnect();
      });
  }
  initConnect() {
    this.disconnect(true), clearTimeout(this.connectTimeoutId), this.connectTimeoutId = setTimeout(() => {
      this.connectErrorHandler(new Error("EventSource connect took too long."));
    }, this.maxConnectTimeout), this.eventSource = new EventSource(this.client.buildUrl("/api/realtime")), this.eventSource.onerror = (e2) => {
      this.connectErrorHandler(new Error("Failed to establish realtime connection."));
    }, this.eventSource.addEventListener("PB_CONNECT", (e2) => {
      const t2 = e2;
      this.clientId = t2 == null ? void 0 : t2.lastEventId, this.submitSubscriptions().then(async () => {
        let e3 = 3;
        for (; this.hasUnsentSubscriptions() && e3 > 0; )
          e3--, await this.submitSubscriptions();
      }).then(() => {
        for (let e3 of this.pendingConnects)
          e3.resolve();
        this.pendingConnects = [], this.reconnectAttempts = 0, clearTimeout(this.reconnectTimeoutId), clearTimeout(this.connectTimeoutId);
        const t3 = this.getSubscriptionsByTopic("PB_CONNECT");
        for (let s2 in t3)
          for (let i2 of t3[s2])
            i2(e2);
      }).catch((e3) => {
        this.clientId = "", this.connectErrorHandler(e3);
      });
    });
  }
  hasUnsentSubscriptions() {
    const e2 = this.getNonEmptySubscriptionKeys();
    if (e2.length != this.lastSentSubscriptions.length)
      return true;
    for (const t2 of e2)
      if (!this.lastSentSubscriptions.includes(t2))
        return true;
    return false;
  }
  connectErrorHandler(e2) {
    if (clearTimeout(this.connectTimeoutId), clearTimeout(this.reconnectTimeoutId), !this.clientId && !this.reconnectAttempts || this.reconnectAttempts > this.maxReconnectAttempts) {
      for (let t3 of this.pendingConnects)
        t3.reject(new ClientResponseError(e2));
      return this.pendingConnects = [], void this.disconnect();
    }
    this.disconnect(true);
    const t2 = this.predefinedReconnectIntervals[this.reconnectAttempts] || this.predefinedReconnectIntervals[this.predefinedReconnectIntervals.length - 1];
    this.reconnectAttempts++, this.reconnectTimeoutId = setTimeout(() => {
      this.initConnect();
    }, t2);
  }
  disconnect(e2 = false) {
    var _a2;
    if (clearTimeout(this.connectTimeoutId), clearTimeout(this.reconnectTimeoutId), this.removeAllSubscriptionListeners(), this.client.cancelRequest(this.getSubscriptionsCancelKey()), (_a2 = this.eventSource) == null ? void 0 : _a2.close(), this.eventSource = null, this.clientId = "", !e2) {
      this.reconnectAttempts = 0;
      for (let e3 of this.pendingConnects)
        e3.resolve();
      this.pendingConnects = [];
    }
  }
};
var RecordService = class extends CrudService {
  constructor(e2, t2) {
    super(e2), this.collectionIdOrName = t2;
  }
  get baseCrudPath() {
    return this.baseCollectionPath + "/records";
  }
  get baseCollectionPath() {
    return "/api/collections/" + encodeURIComponent(this.collectionIdOrName);
  }
  async subscribe(e2, t2, s2) {
    if (!e2)
      throw new Error("Missing topic.");
    if (!t2)
      throw new Error("Missing subscription callback.");
    return this.client.realtime.subscribe(this.collectionIdOrName + "/" + e2, t2, s2);
  }
  async unsubscribe(e2) {
    return e2 ? this.client.realtime.unsubscribe(this.collectionIdOrName + "/" + e2) : this.client.realtime.unsubscribeByPrefix(this.collectionIdOrName);
  }
  async getFullList(e2, t2) {
    if ("number" == typeof e2)
      return super.getFullList(e2, t2);
    const s2 = Object.assign({}, e2, t2);
    return super.getFullList(s2);
  }
  async getList(e2 = 1, t2 = 30, s2) {
    return super.getList(e2, t2, s2);
  }
  async getFirstListItem(e2, t2) {
    return super.getFirstListItem(e2, t2);
  }
  async getOne(e2, t2) {
    return super.getOne(e2, t2);
  }
  async create(e2, t2) {
    return super.create(e2, t2);
  }
  async update(e2, t2, s2) {
    return super.update(e2, t2, s2).then((e3) => {
      var _a2, _b2, _c;
      return ((_a2 = this.client.authStore.model) == null ? void 0 : _a2.id) !== (e3 == null ? void 0 : e3.id) || ((_b2 = this.client.authStore.model) == null ? void 0 : _b2.collectionId) !== this.collectionIdOrName && ((_c = this.client.authStore.model) == null ? void 0 : _c.collectionName) !== this.collectionIdOrName || this.client.authStore.save(this.client.authStore.token, e3), e3;
    });
  }
  async delete(e2, t2) {
    return super.delete(e2, t2).then((t3) => {
      var _a2, _b2, _c;
      return !t3 || ((_a2 = this.client.authStore.model) == null ? void 0 : _a2.id) !== e2 || ((_b2 = this.client.authStore.model) == null ? void 0 : _b2.collectionId) !== this.collectionIdOrName && ((_c = this.client.authStore.model) == null ? void 0 : _c.collectionName) !== this.collectionIdOrName || this.client.authStore.clear(), t3;
    });
  }
  authResponse(e2) {
    const t2 = this.decode((e2 == null ? void 0 : e2.record) || {});
    return this.client.authStore.save(e2 == null ? void 0 : e2.token, t2), Object.assign({}, e2, { token: (e2 == null ? void 0 : e2.token) || "", record: t2 });
  }
  async listAuthMethods(e2) {
    return e2 = Object.assign({ method: "GET" }, e2), this.client.send(this.baseCollectionPath + "/auth-methods", e2).then((e3) => Object.assign({}, e3, { usernamePassword: !!(e3 == null ? void 0 : e3.usernamePassword), emailPassword: !!(e3 == null ? void 0 : e3.emailPassword), authProviders: Array.isArray(e3 == null ? void 0 : e3.authProviders) ? e3 == null ? void 0 : e3.authProviders : [] }));
  }
  async authWithPassword(e2, t2, s2, i2) {
    let n = { method: "POST", body: { identity: e2, password: t2 } };
    return n = normalizeLegacyOptionsArgs("This form of authWithPassword(usernameOrEmail, pass, body?, query?) is deprecated. Consider replacing it with authWithPassword(usernameOrEmail, pass, options?).", n, s2, i2), this.client.send(this.baseCollectionPath + "/auth-with-password", n).then((e3) => this.authResponse(e3));
  }
  async authWithOAuth2Code(e2, t2, s2, i2, n, r, o) {
    let a = { method: "POST", body: { provider: e2, code: t2, codeVerifier: s2, redirectUrl: i2, createData: n } };
    return a = normalizeLegacyOptionsArgs("This form of authWithOAuth2Code(provider, code, codeVerifier, redirectUrl, createData?, body?, query?) is deprecated. Consider replacing it with authWithOAuth2Code(provider, code, codeVerifier, redirectUrl, createData?, options?).", a, r, o), this.client.send(this.baseCollectionPath + "/auth-with-oauth2", a).then((e3) => this.authResponse(e3));
  }
  async authWithOAuth2(...e2) {
    if (e2.length > 1 || "string" == typeof (e2 == null ? void 0 : e2[0]))
      return console.warn("PocketBase: This form of authWithOAuth2() is deprecated and may get removed in the future. Please replace with authWithOAuth2Code() OR use the authWithOAuth2() realtime form as shown in https://pocketbase.io/docs/authentication/#oauth2-integration."), this.authWithOAuth2Code((e2 == null ? void 0 : e2[0]) || "", (e2 == null ? void 0 : e2[1]) || "", (e2 == null ? void 0 : e2[2]) || "", (e2 == null ? void 0 : e2[3]) || "", (e2 == null ? void 0 : e2[4]) || {}, (e2 == null ? void 0 : e2[5]) || {}, (e2 == null ? void 0 : e2[6]) || {});
    const t2 = (e2 == null ? void 0 : e2[0]) || {}, s2 = (await this.listAuthMethods()).authProviders.find((e3) => e3.name === t2.provider);
    if (!s2)
      throw new ClientResponseError(new Error(`Missing or invalid provider "${t2.provider}".`));
    const i2 = this.client.buildUrl("/api/oauth2-redirect"), n = new RealtimeService(this.client);
    let r = null;
    function cleanup() {
      r == null ? void 0 : r.close(), n.unsubscribe();
    }
    return t2.urlCallback || (r = openBrowserPopup(void 0)), new Promise(async (e3, o) => {
      var _a2;
      try {
        await n.subscribe("@oauth2", async (r2) => {
          const a2 = n.clientId;
          try {
            if (!r2.state || a2 !== r2.state)
              throw new Error("State parameters don't match.");
            const n2 = Object.assign({}, t2);
            delete n2.provider, delete n2.scopes, delete n2.createData, delete n2.urlCallback;
            const o2 = await this.authWithOAuth2Code(s2.name, r2.code, s2.codeVerifier, i2, t2.createData, n2);
            e3(o2);
          } catch (e4) {
            o(new ClientResponseError(e4));
          }
          cleanup();
        });
        const a = { state: n.clientId };
        ((_a2 = t2.scopes) == null ? void 0 : _a2.length) && (a.scope = t2.scopes.join(" "));
        const c = this._replaceQueryParams(s2.authUrl + i2, a);
        let l = t2.urlCallback || function(e4) {
          r ? r.location.href = e4 : r = openBrowserPopup(e4);
        };
        await l(c);
      } catch (e4) {
        cleanup(), o(new ClientResponseError(e4));
      }
    });
  }
  async authRefresh(e2, t2) {
    let s2 = { method: "POST" };
    return s2 = normalizeLegacyOptionsArgs("This form of authRefresh(body?, query?) is deprecated. Consider replacing it with authRefresh(options?).", s2, e2, t2), this.client.send(this.baseCollectionPath + "/auth-refresh", s2).then((e3) => this.authResponse(e3));
  }
  async requestPasswordReset(e2, t2, s2) {
    let i2 = { method: "POST", body: { email: e2 } };
    return i2 = normalizeLegacyOptionsArgs("This form of requestPasswordReset(email, body?, query?) is deprecated. Consider replacing it with requestPasswordReset(email, options?).", i2, t2, s2), this.client.send(this.baseCollectionPath + "/request-password-reset", i2).then(() => true);
  }
  async confirmPasswordReset(e2, t2, s2, i2, n) {
    let r = { method: "POST", body: { token: e2, password: t2, passwordConfirm: s2 } };
    return r = normalizeLegacyOptionsArgs("This form of confirmPasswordReset(token, password, passwordConfirm, body?, query?) is deprecated. Consider replacing it with confirmPasswordReset(token, password, passwordConfirm, options?).", r, i2, n), this.client.send(this.baseCollectionPath + "/confirm-password-reset", r).then(() => true);
  }
  async requestVerification(e2, t2, s2) {
    let i2 = { method: "POST", body: { email: e2 } };
    return i2 = normalizeLegacyOptionsArgs("This form of requestVerification(email, body?, query?) is deprecated. Consider replacing it with requestVerification(email, options?).", i2, t2, s2), this.client.send(this.baseCollectionPath + "/request-verification", i2).then(() => true);
  }
  async confirmVerification(e2, t2, s2) {
    let i2 = { method: "POST", body: { token: e2 } };
    return i2 = normalizeLegacyOptionsArgs("This form of confirmVerification(token, body?, query?) is deprecated. Consider replacing it with confirmVerification(token, options?).", i2, t2, s2), this.client.send(this.baseCollectionPath + "/confirm-verification", i2).then(() => true);
  }
  async requestEmailChange(e2, t2, s2) {
    let i2 = { method: "POST", body: { newEmail: e2 } };
    return i2 = normalizeLegacyOptionsArgs("This form of requestEmailChange(newEmail, body?, query?) is deprecated. Consider replacing it with requestEmailChange(newEmail, options?).", i2, t2, s2), this.client.send(this.baseCollectionPath + "/request-email-change", i2).then(() => true);
  }
  async confirmEmailChange(e2, t2, s2, i2) {
    let n = { method: "POST", body: { token: e2, password: t2 } };
    return n = normalizeLegacyOptionsArgs("This form of confirmEmailChange(token, password, body?, query?) is deprecated. Consider replacing it with confirmEmailChange(token, password, options?).", n, s2, i2), this.client.send(this.baseCollectionPath + "/confirm-email-change", n).then(() => true);
  }
  async listExternalAuths(e2, t2) {
    return t2 = Object.assign({ method: "GET" }, t2), this.client.send(this.baseCrudPath + "/" + encodeURIComponent(e2) + "/external-auths", t2);
  }
  async unlinkExternalAuth(e2, t2, s2) {
    return s2 = Object.assign({ method: "DELETE" }, s2), this.client.send(this.baseCrudPath + "/" + encodeURIComponent(e2) + "/external-auths/" + encodeURIComponent(t2), s2).then(() => true);
  }
  _replaceQueryParams(e2, t2 = {}) {
    let s2 = e2, i2 = "";
    e2.indexOf("?") >= 0 && (s2 = e2.substring(0, e2.indexOf("?")), i2 = e2.substring(e2.indexOf("?") + 1));
    const n = {}, r = i2.split("&");
    for (const e3 of r) {
      if ("" == e3)
        continue;
      const t3 = e3.split("=");
      n[decodeURIComponent(t3[0].replace(/\+/g, " "))] = decodeURIComponent((t3[1] || "").replace(/\+/g, " "));
    }
    for (let e3 in t2)
      t2.hasOwnProperty(e3) && (null == t2[e3] ? delete n[e3] : n[e3] = t2[e3]);
    i2 = "";
    for (let e3 in n)
      n.hasOwnProperty(e3) && ("" != i2 && (i2 += "&"), i2 += encodeURIComponent(e3.replace(/%20/g, "+")) + "=" + encodeURIComponent(n[e3].replace(/%20/g, "+")));
    return "" != i2 ? s2 + "?" + i2 : s2;
  }
};
function openBrowserPopup(e2) {
  if ("undefined" == typeof window || !(window == null ? void 0 : window.open))
    throw new ClientResponseError(new Error("Not in a browser context - please pass a custom urlCallback function."));
  let t2 = 1024, s2 = 768, i2 = window.innerWidth, n = window.innerHeight;
  t2 = t2 > i2 ? i2 : t2, s2 = s2 > n ? n : s2;
  let r = i2 / 2 - t2 / 2, o = n / 2 - s2 / 2;
  return window.open(e2, "popup_window", "width=" + t2 + ",height=" + s2 + ",top=" + o + ",left=" + r + ",resizable,menubar=no");
}
var CollectionService = class extends CrudService {
  get baseCrudPath() {
    return "/api/collections";
  }
  async import(e2, t2 = false, s2) {
    return s2 = Object.assign({ method: "PUT", body: { collections: e2, deleteMissing: t2 } }, s2), this.client.send(this.baseCrudPath + "/import", s2).then(() => true);
  }
};
var LogService = class extends BaseService {
  async getList(e2 = 1, t2 = 30, s2) {
    return (s2 = Object.assign({ method: "GET" }, s2)).query = Object.assign({ page: e2, perPage: t2 }, s2.query), this.client.send("/api/logs", s2);
  }
  async getOne(e2, t2) {
    if (!e2)
      throw new ClientResponseError({ url: this.client.buildUrl("/api/logs/"), status: 404, response: { code: 404, message: "Missing required log id.", data: {} } });
    return t2 = Object.assign({ method: "GET" }, t2), this.client.send("/api/logs/" + encodeURIComponent(e2), t2);
  }
  async getStats(e2) {
    return e2 = Object.assign({ method: "GET" }, e2), this.client.send("/api/logs/stats", e2);
  }
};
var HealthService = class extends BaseService {
  async check(e2) {
    return e2 = Object.assign({ method: "GET" }, e2), this.client.send("/api/health", e2);
  }
};
var FileService = class extends BaseService {
  getUrl(e2, t2, s2 = {}) {
    if (!t2 || !(e2 == null ? void 0 : e2.id) || !(e2 == null ? void 0 : e2.collectionId) && !(e2 == null ? void 0 : e2.collectionName))
      return "";
    const i2 = [];
    i2.push("api"), i2.push("files"), i2.push(encodeURIComponent(e2.collectionId || e2.collectionName)), i2.push(encodeURIComponent(e2.id)), i2.push(encodeURIComponent(t2));
    let n = this.client.buildUrl(i2.join("/"));
    if (Object.keys(s2).length) {
      false === s2.download && delete s2.download;
      const e3 = new URLSearchParams(s2);
      n += (n.includes("?") ? "&" : "?") + e3;
    }
    return n;
  }
  async getToken(e2) {
    return e2 = Object.assign({ method: "POST" }, e2), this.client.send("/api/files/token", e2).then((e3) => (e3 == null ? void 0 : e3.token) || "");
  }
};
var BackupService = class extends BaseService {
  async getFullList(e2) {
    return e2 = Object.assign({ method: "GET" }, e2), this.client.send("/api/backups", e2);
  }
  async create(e2, t2) {
    return t2 = Object.assign({ method: "POST", body: { name: e2 } }, t2), this.client.send("/api/backups", t2).then(() => true);
  }
  async upload(e2, t2) {
    return t2 = Object.assign({ method: "POST", body: e2 }, t2), this.client.send("/api/backups/upload", t2).then(() => true);
  }
  async delete(e2, t2) {
    return t2 = Object.assign({ method: "DELETE" }, t2), this.client.send(`/api/backups/${encodeURIComponent(e2)}`, t2).then(() => true);
  }
  async restore(e2, t2) {
    return t2 = Object.assign({ method: "POST" }, t2), this.client.send(`/api/backups/${encodeURIComponent(e2)}/restore`, t2).then(() => true);
  }
  getDownloadUrl(e2, t2) {
    return this.client.buildUrl(`/api/backups/${encodeURIComponent(t2)}?token=${encodeURIComponent(e2)}`);
  }
};
var Client = class {
  constructor(e2 = "/", t2, s2 = "en-US") {
    this.cancelControllers = {}, this.recordServices = {}, this.enableAutoCancellation = true, this.baseUrl = e2, this.lang = s2, this.authStore = t2 || new LocalAuthStore(), this.admins = new AdminService(this), this.collections = new CollectionService(this), this.files = new FileService(this), this.logs = new LogService(this), this.settings = new SettingsService(this), this.realtime = new RealtimeService(this), this.health = new HealthService(this), this.backups = new BackupService(this);
  }
  collection(e2) {
    return this.recordServices[e2] || (this.recordServices[e2] = new RecordService(this, e2)), this.recordServices[e2];
  }
  autoCancellation(e2) {
    return this.enableAutoCancellation = !!e2, this;
  }
  cancelRequest(e2) {
    return this.cancelControllers[e2] && (this.cancelControllers[e2].abort(), delete this.cancelControllers[e2]), this;
  }
  cancelAllRequests() {
    for (let e2 in this.cancelControllers)
      this.cancelControllers[e2].abort();
    return this.cancelControllers = {}, this;
  }
  filter(e2, t2) {
    if (!t2)
      return e2;
    for (let s2 in t2) {
      let i2 = t2[s2];
      switch (typeof i2) {
        case "boolean":
        case "number":
          i2 = "" + i2;
          break;
        case "string":
          i2 = "'" + i2.replace(/'/g, "\\'") + "'";
          break;
        default:
          i2 = null === i2 ? "null" : i2 instanceof Date ? "'" + i2.toISOString().replace("T", " ") + "'" : "'" + JSON.stringify(i2).replace(/'/g, "\\'") + "'";
      }
      e2 = e2.replaceAll("{:" + s2 + "}", i2);
    }
    return e2;
  }
  getFileUrl(e2, t2, s2 = {}) {
    return this.files.getUrl(e2, t2, s2);
  }
  buildUrl(e2) {
    var _a2;
    let t2 = this.baseUrl;
    return "undefined" == typeof window || !window.location || t2.startsWith("https://") || t2.startsWith("http://") || (t2 = ((_a2 = window.location.origin) == null ? void 0 : _a2.endsWith("/")) ? window.location.origin.substring(0, window.location.origin.length - 1) : window.location.origin || "", this.baseUrl.startsWith("/") || (t2 += window.location.pathname || "/", t2 += t2.endsWith("/") ? "" : "/"), t2 += this.baseUrl), e2 && (t2 += t2.endsWith("/") ? "" : "/", t2 += e2.startsWith("/") ? e2.substring(1) : e2), t2;
  }
  async send(e2, t2) {
    t2 = this.initSendOptions(e2, t2);
    let s2 = this.buildUrl(e2);
    if (this.beforeSend) {
      const e3 = Object.assign({}, await this.beforeSend(s2, t2));
      void 0 !== e3.url || void 0 !== e3.options ? (s2 = e3.url || s2, t2 = e3.options || t2) : Object.keys(e3).length && (t2 = e3, (console == null ? void 0 : console.warn) && console.warn("Deprecated format of beforeSend return: please use `return { url, options }`, instead of `return options`."));
    }
    if (void 0 !== t2.query) {
      const e3 = this.serializeQueryParams(t2.query);
      e3 && (s2 += (s2.includes("?") ? "&" : "?") + e3), delete t2.query;
    }
    "application/json" == this.getHeader(t2.headers, "Content-Type") && t2.body && "string" != typeof t2.body && (t2.body = JSON.stringify(t2.body));
    return (t2.fetch || fetch)(s2, t2).then(async (e3) => {
      let t3 = {};
      try {
        t3 = await e3.json();
      } catch (e4) {
      }
      if (this.afterSend && (t3 = await this.afterSend(e3, t3)), e3.status >= 400)
        throw new ClientResponseError({ url: e3.url, status: e3.status, data: t3 });
      return t3;
    }).catch((e3) => {
      throw new ClientResponseError(e3);
    });
  }
  initSendOptions(e2, t2) {
    if ((t2 = Object.assign({ method: "GET" }, t2)).body = this.convertToFormDataIfNeeded(t2.body), normalizeUnknownQueryParams(t2), t2.query = Object.assign({}, t2.params, t2.query), void 0 === t2.requestKey && (false === t2.$autoCancel || false === t2.query.$autoCancel ? t2.requestKey = null : (t2.$cancelKey || t2.query.$cancelKey) && (t2.requestKey = t2.$cancelKey || t2.query.$cancelKey)), delete t2.$autoCancel, delete t2.query.$autoCancel, delete t2.$cancelKey, delete t2.query.$cancelKey, null !== this.getHeader(t2.headers, "Content-Type") || this.isFormData(t2.body) || (t2.headers = Object.assign({}, t2.headers, { "Content-Type": "application/json" })), null === this.getHeader(t2.headers, "Accept-Language") && (t2.headers = Object.assign({}, t2.headers, { "Accept-Language": this.lang })), this.authStore.token && null === this.getHeader(t2.headers, "Authorization") && (t2.headers = Object.assign({}, t2.headers, { Authorization: this.authStore.token })), this.enableAutoCancellation && null !== t2.requestKey) {
      const s2 = t2.requestKey || (t2.method || "GET") + e2;
      delete t2.requestKey, this.cancelRequest(s2);
      const i2 = new AbortController();
      this.cancelControllers[s2] = i2, t2.signal = i2.signal;
    }
    return t2;
  }
  convertToFormDataIfNeeded(e2) {
    if ("undefined" == typeof FormData || void 0 === e2 || "object" != typeof e2 || null === e2 || this.isFormData(e2) || !this.hasBlobField(e2))
      return e2;
    const t2 = new FormData();
    for (let s2 in e2) {
      const i2 = this.normalizeFormDataValue(e2[s2]), n = Array.isArray(i2) ? i2 : [i2];
      if (n.length)
        for (const e3 of n)
          t2.append(s2, e3);
      else
        t2.append(s2, "");
    }
    return t2;
  }
  normalizeFormDataValue(e2) {
    return null === e2 || "object" != typeof e2 || e2 instanceof Date || this.hasBlobField({ data: e2 }) || Array.isArray(e2) && !e2.filter((e3) => "string" != typeof e3).length ? e2 : JSON.stringify(e2);
  }
  hasBlobField(e2) {
    for (let t2 in e2) {
      const s2 = Array.isArray(e2[t2]) ? e2[t2] : [e2[t2]];
      for (let e3 of s2)
        if ("undefined" != typeof Blob && e3 instanceof Blob || "undefined" != typeof File && e3 instanceof File)
          return true;
    }
    return false;
  }
  getHeader(e2, t2) {
    e2 = e2 || {}, t2 = t2.toLowerCase();
    for (let s2 in e2)
      if (s2.toLowerCase() == t2)
        return e2[s2];
    return null;
  }
  isFormData(e2) {
    return e2 && ("FormData" === e2.constructor.name || "undefined" != typeof FormData && e2 instanceof FormData);
  }
  serializeQueryParams(e2) {
    const t2 = [];
    for (const s2 in e2) {
      if (null === e2[s2])
        continue;
      const i2 = e2[s2], n = encodeURIComponent(s2);
      if (Array.isArray(i2))
        for (const e3 of i2)
          t2.push(n + "=" + encodeURIComponent(e3));
      else
        i2 instanceof Date ? t2.push(n + "=" + encodeURIComponent(i2.toISOString())) : null !== typeof i2 && "object" == typeof i2 ? t2.push(n + "=" + encodeURIComponent(JSON.stringify(i2))) : t2.push(n + "=" + encodeURIComponent(i2));
    }
    return t2.join("&");
  }
};

// src/LoginManager.ts
var LoginManager = class extends Observable3 {
  constructor(openSettings) {
    super();
    this._log = curryLog("[LoginManager]");
    const pbLog = curryLog("[Pocketbase]");
    this.pb = new Client("https://auth.system3.md");
    this.pb.beforeSend = (url, options) => {
      pbLog(url, this.pb, options);
      options.fetch = customFetch;
      options.headers = Object.assign({}, options.headers, {
        "Relay-Version": "0.2.13"
      });
      return { url, options };
    };
    this.openSettings = openSettings;
    this.user = this.pb.authStore.isValid ? this.makeUser(this.pb.authStore) : void 0;
    this._log("instance", this);
  }
  log(message, ...args3) {
    this._log(message, ...args3);
  }
  setup(authData) {
    var _a2;
    if (!this.pb.authStore.isValid) {
      this.notifyListeners();
      return false;
    }
    this.log("LoginManager", this);
    this.user = this.makeUser(this.pb.authStore);
    this.notifyListeners();
    if (authData) {
      this.pb.collection("oauth2_response").create({
        user: authData.record.id,
        oauth_response: (_a2 = authData.meta) == null ? void 0 : _a2.rawUser
      }).then(() => {
        this.notifyListeners();
      }).catch((reason) => {
        this.log(reason);
      });
    }
    return true;
  }
  whoami() {
    const headers = {
      Authorization: `Bearer ${this.pb.authStore.token}`
    };
    (0, import_obsidian21.requestUrl)({
      url: `${"https://api.system3.md"}/whoami`,
      method: "GET",
      headers
    }).then((response) => {
      this.log(response.json);
    }).catch((reason) => {
      this.log(reason);
    });
  }
  get loggedIn() {
    return this.user !== void 0;
  }
  get hasUser() {
    return this.user !== void 0;
  }
  makeUser(authStore) {
    var _a2, _b2;
    return new User(
      (_a2 = authStore.model) == null ? void 0 : _a2.id,
      (_b2 = authStore.model) == null ? void 0 : _b2.email,
      authStore.token
    );
  }
  get anon() {
    return new User("", "Anonymous", "");
  }
  logout() {
    this.pb.cancelAllRequests();
    this.pb.authStore.clear();
    this.user = void 0;
    this.notifyListeners();
  }
  async initiateManualOAuth2CodeFlow(whichFetch) {
    const authMethods = await this.pb.collection("users").listAuthMethods({ fetch: whichFetch }).catch((e2) => {
      throw e2.originalError;
    });
    const provider = authMethods.authProviders[0];
    const redirectUrl = this.pb.buildUrl("/api/oauth2-redirect");
    return [
      provider.authUrl + redirectUrl,
      provider,
      async (code) => {
        return this.pb.collection("users").authWithOAuth2Code(
          provider.name,
          code,
          provider.codeVerifier,
          redirectUrl,
          {
            fetch: whichFetch
          }
        ).then((authData) => {
          this.setup(authData);
          return authData;
        });
      }
    ];
  }
  async poll(provider, authWithCode) {
    let counter = 0;
    const interval = 1e3;
    return new Promise((resolve, reject) => {
      const timer = setInterval(() => {
        counter += 1;
        if (counter > 30) {
          clearInterval(timer);
          return reject(
            new Error(
              `Auth timeout: Timed out after ${counter * interval / 1e3} seconds`
            )
          );
        }
        this.pb.collection("code_exchange").getOne(provider.state.slice(0, 15)).then((response) => {
          if (response) {
            clearInterval(timer);
            return resolve(authWithCode(response.code));
          }
        }).catch((e2) => {
        });
      }, interval);
    });
  }
  async login() {
    try {
      const authData = await this.pb.collection("users").authWithOAuth2({
        provider: "google"
      });
      return this.setup(authData);
    } catch (e2) {
      this.log("request failed", e2);
      console.error("Authenticating failed", e2);
      return false;
    }
  }
  async openLoginPage() {
    await this.openSettings();
    const promise = new Promise((resolve, reject) => {
      const isLoggedIn = () => {
        if (this.loggedIn) {
          this.off(isLoggedIn);
          resolve(true);
        }
        resolve(false);
      };
      this.on(isLoggedIn);
    });
    return await promise;
  }
};

// node_modules/monkey-around/dist/index.mjs
function around(obj, factories) {
  const removers = Object.keys(factories).map((key) => around1(obj, key, factories[key]));
  return removers.length === 1 ? removers[0] : function() {
    removers.forEach((r) => r());
  };
}
function around1(obj, method, createWrapper) {
  const inherited = obj[method], hadOwn = obj.hasOwnProperty(method), original = hadOwn ? inherited : function() {
    return Object.getPrototypeOf(obj)[method].apply(this, arguments);
  };
  let current = createWrapper(original);
  if (inherited)
    Object.setPrototypeOf(current, inherited);
  Object.setPrototypeOf(wrapper, current);
  obj[method] = wrapper;
  return remove;
  function wrapper(...args3) {
    if (current === original && obj[method] === wrapper)
      remove();
    return current.apply(this, args3);
  }
  function remove() {
    if (obj[method] === wrapper) {
      if (hadOwn)
        obj[method] = original;
      else
        delete obj[method];
    }
    if (current === original)
      return;
    current = original;
    Object.setPrototypeOf(wrapper, inherited || Function);
  }
}

// node_modules/jose/dist/browser/runtime/webcrypto.js
var webcrypto_default = crypto;

// node_modules/jose/dist/browser/lib/buffer_utils.js
var encoder = new TextEncoder();
var decoder = new TextDecoder();
var MAX_INT32 = 2 ** 32;

// node_modules/jose/dist/browser/runtime/base64url.js
var encodeBase64 = (input) => {
  let unencoded = input;
  if (typeof unencoded === "string") {
    unencoded = encoder.encode(unencoded);
  }
  const CHUNK_SIZE = 32768;
  const arr = [];
  for (let i2 = 0; i2 < unencoded.length; i2 += CHUNK_SIZE) {
    arr.push(String.fromCharCode.apply(null, unencoded.subarray(i2, i2 + CHUNK_SIZE)));
  }
  return btoa(arr.join(""));
};
var encode = (input) => {
  return encodeBase64(input).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
};
var decodeBase64 = (encoded) => {
  const binary = atob(encoded);
  const bytes = new Uint8Array(binary.length);
  for (let i2 = 0; i2 < binary.length; i2++) {
    bytes[i2] = binary.charCodeAt(i2);
  }
  return bytes;
};
var decode = (input) => {
  let encoded = input;
  if (encoded instanceof Uint8Array) {
    encoded = decoder.decode(encoded);
  }
  encoded = encoded.replace(/-/g, "+").replace(/_/g, "/").replace(/\s/g, "");
  try {
    return decodeBase64(encoded);
  } catch (e2) {
    throw new TypeError("The input to be decoded is not correctly encoded.");
  }
};

// node_modules/jose/dist/browser/util/errors.js
var errors_exports = {};
__export(errors_exports, {
  JOSEAlgNotAllowed: () => JOSEAlgNotAllowed,
  JOSEError: () => JOSEError,
  JOSENotSupported: () => JOSENotSupported,
  JWEDecryptionFailed: () => JWEDecryptionFailed,
  JWEInvalid: () => JWEInvalid,
  JWKInvalid: () => JWKInvalid,
  JWKSInvalid: () => JWKSInvalid,
  JWKSMultipleMatchingKeys: () => JWKSMultipleMatchingKeys,
  JWKSNoMatchingKey: () => JWKSNoMatchingKey,
  JWKSTimeout: () => JWKSTimeout,
  JWSInvalid: () => JWSInvalid,
  JWSSignatureVerificationFailed: () => JWSSignatureVerificationFailed,
  JWTClaimValidationFailed: () => JWTClaimValidationFailed,
  JWTExpired: () => JWTExpired,
  JWTInvalid: () => JWTInvalid
});
var JOSEError = class extends Error {
  static get code() {
    return "ERR_JOSE_GENERIC";
  }
  constructor(message) {
    var _a2;
    super(message);
    this.code = "ERR_JOSE_GENERIC";
    this.name = this.constructor.name;
    (_a2 = Error.captureStackTrace) == null ? void 0 : _a2.call(Error, this, this.constructor);
  }
};
var JWTClaimValidationFailed = class extends JOSEError {
  static get code() {
    return "ERR_JWT_CLAIM_VALIDATION_FAILED";
  }
  constructor(message, claim = "unspecified", reason = "unspecified") {
    super(message);
    this.code = "ERR_JWT_CLAIM_VALIDATION_FAILED";
    this.claim = claim;
    this.reason = reason;
  }
};
var JWTExpired = class extends JOSEError {
  static get code() {
    return "ERR_JWT_EXPIRED";
  }
  constructor(message, claim = "unspecified", reason = "unspecified") {
    super(message);
    this.code = "ERR_JWT_EXPIRED";
    this.claim = claim;
    this.reason = reason;
  }
};
var JOSEAlgNotAllowed = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JOSE_ALG_NOT_ALLOWED";
  }
  static get code() {
    return "ERR_JOSE_ALG_NOT_ALLOWED";
  }
};
var JOSENotSupported = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JOSE_NOT_SUPPORTED";
  }
  static get code() {
    return "ERR_JOSE_NOT_SUPPORTED";
  }
};
var JWEDecryptionFailed = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWE_DECRYPTION_FAILED";
    this.message = "decryption operation failed";
  }
  static get code() {
    return "ERR_JWE_DECRYPTION_FAILED";
  }
};
var JWEInvalid = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWE_INVALID";
  }
  static get code() {
    return "ERR_JWE_INVALID";
  }
};
var JWSInvalid = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWS_INVALID";
  }
  static get code() {
    return "ERR_JWS_INVALID";
  }
};
var JWTInvalid = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWT_INVALID";
  }
  static get code() {
    return "ERR_JWT_INVALID";
  }
};
var JWKInvalid = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWK_INVALID";
  }
  static get code() {
    return "ERR_JWK_INVALID";
  }
};
var JWKSInvalid = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWKS_INVALID";
  }
  static get code() {
    return "ERR_JWKS_INVALID";
  }
};
var JWKSNoMatchingKey = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWKS_NO_MATCHING_KEY";
    this.message = "no applicable key found in the JSON Web Key Set";
  }
  static get code() {
    return "ERR_JWKS_NO_MATCHING_KEY";
  }
};
var JWKSMultipleMatchingKeys = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
    this.message = "multiple matching keys found in the JSON Web Key Set";
  }
  static get code() {
    return "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
  }
};
var JWKSTimeout = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWKS_TIMEOUT";
    this.message = "request timed out";
  }
  static get code() {
    return "ERR_JWKS_TIMEOUT";
  }
};
var JWSSignatureVerificationFailed = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
    this.message = "signature verification failed";
  }
  static get code() {
    return "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
  }
};

// node_modules/jose/dist/browser/runtime/random.js
var random_default = webcrypto_default.getRandomValues.bind(webcrypto_default);

// node_modules/jose/dist/browser/lib/is_object.js
function isObjectLike(value) {
  return typeof value === "object" && value !== null;
}
function isObject(input) {
  if (!isObjectLike(input) || Object.prototype.toString.call(input) !== "[object Object]") {
    return false;
  }
  if (Object.getPrototypeOf(input) === null) {
    return true;
  }
  let proto = input;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(input) === proto;
}

// node_modules/jose/dist/browser/jwe/flattened/encrypt.js
var unprotected = Symbol();

// node_modules/jose/dist/browser/lib/secs.js
var minute = 60;
var hour = minute * 60;
var day = hour * 24;
var week = day * 7;
var year = day * 365.25;

// node_modules/jose/dist/browser/jwks/remote.js
var USER_AGENT;
var _a, _b;
if (typeof navigator === "undefined" || !((_b = (_a = navigator.userAgent) == null ? void 0 : _a.startsWith) == null ? void 0 : _b.call(_a, "Mozilla/5.0 "))) {
  const NAME = "jose";
  const VERSION2 = "v5.3.0";
  USER_AGENT = `${NAME}/${VERSION2}`;
}

// node_modules/jose/dist/browser/util/base64url.js
var base64url_exports2 = {};
__export(base64url_exports2, {
  decode: () => decode2,
  encode: () => encode2
});
var encode2 = encode;
var decode2 = decode;

// node_modules/jose/dist/browser/util/decode_jwt.js
function decodeJwt(jwt) {
  if (typeof jwt !== "string")
    throw new JWTInvalid("JWTs must use Compact JWS serialization, JWT must be a string");
  const { 1: payload, length: length4 } = jwt.split(".");
  if (length4 === 5)
    throw new JWTInvalid("Only JWTs using Compact JWS serialization can be decoded");
  if (length4 !== 3)
    throw new JWTInvalid("Invalid JWT");
  if (!payload)
    throw new JWTInvalid("JWTs must contain a payload");
  let decoded;
  try {
    decoded = decode2(payload);
  } catch (e2) {
    throw new JWTInvalid("Failed to base64url decode the payload");
  }
  let result;
  try {
    result = JSON.parse(decoder.decode(decoded));
  } catch (e2) {
    throw new JWTInvalid("Failed to parse the decoded payload as JSON");
  }
  if (!isObject(result))
    throw new JWTInvalid("Invalid JWT Claims Set");
  return result;
}

// src/TokenStore.ts
function formatTime(milliseconds) {
  if (milliseconds < 1e3) {
    return `${milliseconds}ms`;
  } else if (milliseconds < 6e4) {
    return `${Math.round(milliseconds / 1e3)}s`;
  } else if (milliseconds < 36e5) {
    return `${Math.round(milliseconds / 6e4)}m`;
  } else {
    return `${Math.round(milliseconds / 36e5)}h`;
  }
}
function _getJwtExpiry(token) {
  const decoded = decodeJwt(token.token);
  if (typeof decoded === "string") {
    return 0;
  }
  const exp = decoded == null ? void 0 : decoded.exp;
  if (!exp) {
    return 0;
  }
  return exp * 1e3;
}
var TokenStore = class {
  constructor(config, maxConnections = 5) {
    this.expiryMargin = 5 * 60 * 1e3;
    // 5 minutes in milliseconds
    this.activeConnections = 0;
    this._activePromises = /* @__PURE__ */ new Map();
    if (config.getStorage) {
      this.tokenMap = config.getStorage();
    } else {
      this.tokenMap = /* @__PURE__ */ new Map();
    }
    this.callbacks = /* @__PURE__ */ new Map();
    this.refreshQueue = /* @__PURE__ */ new Set();
    this._log = config.log;
    this.refresh = config.refresh;
    this.timeProvider = config.getTimeProvider();
    if (config.getJwtExpiry) {
      this.getJwtExpiry = config.getJwtExpiry;
    } else {
      this.getJwtExpiry = _getJwtExpiry;
    }
    this.maxConnections = maxConnections;
    this.refreshInterval = null;
  }
  onRefresh(documentId) {
    const promise = new Promise((resolve, reject) => {
      const onSuccess = (token) => {
        resolve(token);
      };
      const onError = (error) => {
        reject(error);
      };
      this.refresh(documentId, onSuccess, onError);
    });
    return promise;
  }
  start() {
    this.log("starting");
    this.report();
    this.refreshInterval = this.timeProvider.setInterval(
      () => this.checkAndRefreshTokens(),
      60 * 1e3
    );
    this.checkAndRefreshTokens();
  }
  stop() {
    this.log("stopping");
    if (this.refreshInterval) {
      this.timeProvider.clearInterval(this.refreshInterval);
      this.refreshInterval = null;
    }
  }
  _cleanupInvalidTokens() {
    const toDelete = [];
    for (const [documentId, tokenInfo] of this.tokenMap.entries()) {
      if (!this.isTokenValid(tokenInfo)) {
        toDelete.push(documentId);
      }
    }
    for (const documentId of toDelete) {
      this.tokenMap.delete(documentId);
    }
  }
  checkAndRefreshTokens() {
    this.log("check and refresh tokens");
    this._cleanupInvalidTokens();
    for (const [documentId, tokenInfo] of this.tokenMap.entries()) {
      if (this.callbacks.has(documentId) && this.shouldRefresh(tokenInfo)) {
        this.log("adding to refresh queue");
        this.addToRefreshQueue(documentId);
      }
    }
    this.log(this.report());
  }
  dequeue() {
    this.log("getting next item in queue");
    if (this.refreshQueue.size > 0) {
      const nextDocumentId = this.refreshQueue.values().next().value;
      this.refreshQueue.delete(nextDocumentId);
      return nextDocumentId;
    }
    return null;
  }
  addToRefreshQueue(documentId) {
    if (this.activeConnections < this.maxConnections) {
      this.log(`immediate refresh of ${documentId}`);
      this.activeConnections++;
      const onSuccess = (newToken) => {
        this.onTokenRefreshed(documentId, newToken);
        this.activeConnections--;
        const next = this.dequeue();
        if (next) {
          this.addToRefreshQueue(next);
        }
      };
      const onError = () => {
        this.onRefreshFailure(documentId);
        this.activeConnections--;
        const next = this.dequeue();
        if (next) {
          this.addToRefreshQueue(next);
        }
      };
      this.refresh(documentId, onSuccess, onError);
    } else {
      this.log(`enqueued refresh of ${documentId}`);
      this.refreshQueue.add(documentId);
    }
  }
  log(text3) {
    this._log(text3);
  }
  onTokenRefreshed(documentId, token) {
    const expiryTime = this.getJwtExpiry(token);
    if (this.tokenMap.has(documentId)) {
      const existing = this.tokenMap.get(documentId);
      const callback = this.callbacks.get(documentId);
      this.log(`new expiry time is ${expiryTime}`);
      this.tokenMap.set(documentId, {
        ...existing,
        token,
        expiryTime
      });
      callback(token);
      this.log(
        `Token refreshed for ${existing.friendlyName} (${documentId})`
      );
    }
  }
  onRefreshFailure(documentId) {
    const existing = this.tokenMap.get(documentId);
    const attempts = (existing == null ? void 0 : existing.attempts) || 0 + 1;
    if (attempts <= 3) {
      this.tokenMap.set(documentId, {
        ...existing,
        attempts
      });
    } else {
      this.tokenMap.delete(documentId);
    }
  }
  isTokenValid(token) {
    const currentTime = this.timeProvider.getTime();
    return currentTime < token.expiryTime;
  }
  shouldRefresh(token) {
    const currentTime = this.timeProvider.getTime();
    return currentTime + this.expiryMargin > token.expiryTime;
  }
  getTokenSync(documentId) {
    var _a2;
    return (_a2 = this.tokenMap.get(documentId)) == null ? void 0 : _a2.token;
  }
  getTokenFromNetwork(documentId, friendlyName, callback) {
    const activePromise = this._activePromises.get(documentId);
    if (activePromise) {
      return activePromise;
    }
    this.tokenMap.set(documentId, {
      token: null,
      friendlyName,
      expiryTime: 0,
      attempts: 0
    });
    this.callbacks.set(documentId, callback);
    const sharedPromise = this.onRefresh(documentId).then((newToken) => {
      this.onTokenRefreshed(documentId, newToken);
      this._activePromises.delete(documentId);
      return newToken;
    }).catch((err) => {
      this.onRefreshFailure(documentId);
      this._activePromises.delete(documentId);
      throw err;
    });
    this._activePromises.set(documentId, sharedPromise);
    return sharedPromise;
  }
  async getToken(documentId, friendlyName, callback) {
    this.log(`getting token ${friendlyName}`);
    if (this.tokenMap.has(documentId)) {
      const tokenInfo = this.tokenMap.get(documentId);
      if (tokenInfo.token && this.isTokenValid(tokenInfo)) {
        this.callbacks.set(documentId, callback);
        tokenInfo.friendlyName = friendlyName;
        callback(tokenInfo.token);
        this.log("token was valid, cache hit!");
        this._activePromises.delete(documentId);
        return Promise.resolve(tokenInfo.token);
      }
    }
    return this.getTokenFromNetwork(documentId, friendlyName, callback);
  }
  _reportWithFilter(filter) {
    const reportLines = [];
    const currentTime = this.timeProvider.getTime();
    const tokens = Array.from(this.tokenMap.entries()).sort((a, b) => {
      return a[1].expiryTime - b[1].expiryTime;
    });
    for (const [
      documentId,
      { friendlyName, expiryTime, attempts }
    ] of tokens) {
      if (!filter(documentId)) {
        continue;
      }
      const timeUntilExpiry = expiryTime - currentTime;
      let timeReport = "";
      if (timeUntilExpiry > 0) {
        timeReport = `expires in ${formatTime(
          timeUntilExpiry - this.expiryMargin
        )}`;
      } else {
        timeReport = "expired";
      }
      reportLines.push(
        `${documentId} (${friendlyName}): ${attempts} attempts, (${timeReport})`
      );
    }
    return reportLines;
  }
  report() {
    const reportLines = [];
    reportLines.push("Token Store Report:");
    reportLines.push(`Expiry Margin: ${formatTime(this.expiryMargin)}`);
    reportLines.push("Active Tokens:");
    reportLines.push(
      ...this._reportWithFilter((documentId) => {
        return this.callbacks.has(documentId);
      })
    );
    reportLines.push("Stale Tokens:");
    reportLines.push(
      ...this._reportWithFilter((documentId) => {
        return !this.callbacks.has(documentId);
      })
    );
    reportLines.push(`Queue size: ${this.refreshQueue.size}`);
    return reportLines.join("\n");
  }
  async waitForQueue() {
    return new Promise((resolve) => {
      setInterval(() => {
        if (this.refreshQueue.size == 0) {
          return resolve();
        }
      }, 100);
    });
  }
  clearState() {
    this.refreshQueue.clear();
    for (const [documentId, tokenInfo] of this.tokenMap.entries()) {
      if (this.isTokenValid(tokenInfo)) {
        this.tokenMap.set(documentId, { ...tokenInfo, attempts: 0 });
      } else {
        this.tokenMap.delete(documentId);
      }
    }
  }
  clear() {
    this.tokenMap.clear();
    this.refreshQueue.clear();
  }
};

// src/LiveTokenStore.ts
var import_obsidian22 = require("obsidian");

// src/LocalStorage.ts
var LocalStorage = class {
  constructor(namespace) {
    this.seperator = "/";
    this.namespace = namespace;
  }
  fullKey(key) {
    return `${this.namespace}${this.seperator}${key}`;
  }
  get size() {
    return Object.keys(localStorage).filter(
      (key) => key.startsWith(this.namespace + this.seperator)
    ).length;
  }
  clear() {
    Object.keys(localStorage).filter(
      (key) => key.startsWith(this.namespace + this.seperator)
    ).forEach((key) => localStorage.removeItem(key));
  }
  delete(key) {
    const storageKey = this.fullKey(key);
    const exists = localStorage.getItem(storageKey) !== null;
    localStorage.removeItem(storageKey);
    return exists;
  }
  forEach(callbackfn, thisArg) {
    Object.keys(localStorage).filter(
      (key) => key.startsWith(this.namespace + this.seperator)
    ).forEach((key) => {
      const storageKey = key.split(
        `${this.namespace}${this.seperator}`
      )[1];
      const value = this.get(storageKey);
      callbackfn.call(thisArg, value, storageKey, this);
    });
  }
  get(key) {
    const storageKey = this.fullKey(key);
    const item = localStorage.getItem(storageKey);
    return item ? JSON.parse(item) : void 0;
  }
  has(key) {
    const storageKey = this.fullKey(key);
    return localStorage.getItem(storageKey) !== null;
  }
  set(key, value) {
    const storageKey = this.fullKey(key);
    localStorage.setItem(storageKey, JSON.stringify(value));
    return this;
  }
  keys() {
    const keys2 = Object.keys(localStorage).filter(
      (key) => key.startsWith(this.namespace + this.seperator)
    ).map(
      (key) => key.split(`${this.namespace}${this.seperator}`)[1]
    );
    return keys2.values();
  }
  values() {
    const values = Array.from(this.keys()).map((key) => this.get(key));
    return values.values();
  }
  entries() {
    const entries = Array.from(this.keys()).map(
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      (key) => [key, this.get(key)]
    );
    return entries.values();
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  get [Symbol.toStringTag]() {
    return "LocalStorage";
  }
};

// src/LiveTokenStore.ts
function getJwtExpiryFromClientToken(clientToken) {
  return clientToken.expiryTime || 0;
}
function withLoginManager(loginManager, fn) {
  return (...args3) => fn(loginManager, ...args3);
}
async function refresh(loginManager, documentId, onSuccess, onError) {
  var _a2;
  const log = curryLog("[TokenStore][Refresh]", "log");
  const error = curryLog("[TokenStore][Refresh]", "error");
  log(`${documentId}`);
  const entity = S3RN.decode(documentId);
  let payload;
  if (entity instanceof S3RemoteDocument) {
    payload = JSON.stringify({
      docId: entity.documentId,
      relay: entity.relayId
    });
  } else if (entity instanceof S3RemoteFolder) {
    payload = JSON.stringify({
      docId: entity.folderId,
      relay: entity.relayId
    });
  } else {
    onError(new Error("No remote to connect to"));
    return;
  }
  if (!loginManager.loggedIn) {
    onError(Error("Not logged in"));
    return;
  }
  const headers = {
    Authorization: `Bearer ${(_a2 = loginManager.user) == null ? void 0 : _a2.token}`
  };
  (0, import_obsidian22.requestUrl)({
    url: `${"https://api.system3.md"}/token`,
    method: "POST",
    headers,
    body: payload
  }).then((response) => {
    if (response.status !== 200) {
      log(response.status, response.text);
      onError(
        Error(
          `Received status code ${response.status} from an API.`
        )
      );
    }
    const clientToken = response.json;
    onSuccess(clientToken);
  }).catch((reason) => {
    error(reason, payload);
    onError(reason);
  });
}
var LiveTokenStore = class extends TokenStore {
  constructor(loginManager, timeProvider, vaultName, maxConnections = 5) {
    super(
      {
        log: curryLog("[LiveTokenStore]"),
        refresh: withLoginManager(loginManager, refresh),
        getJwtExpiry: getJwtExpiryFromClientToken,
        getStorage: function() {
          return new LocalStorage(
            "TokenStore/" + vaultName
          );
        },
        getTimeProvider: () => {
          return timeProvider;
        }
      },
      maxConnections
    );
  }
};

// src/NetworkStatus.ts
var import_obsidian23 = require("obsidian");
var NetworkStatus = class {
  constructor(url, interval = 1e4) {
    this.onOnline = [];
    this.onOffline = [];
    this.online = true;
    this._log = curryLog("[NetworkStatus]");
    this.url = url;
    this.interval = interval;
    this._onceOnline = /* @__PURE__ */ new Set();
  }
  log(message, ...args3) {
    this._log(message, ...args3);
  }
  start() {
    if (!this.timer) {
      this.timer = this.checkStatusRepeatedly();
    }
  }
  stop() {
    if (this.timer) {
      clearInterval(this.timer);
    }
  }
  checkStatusRepeatedly() {
    return setInterval(this._checkStatus.bind(this), this.interval);
  }
  checkStatus() {
    if (this.online) {
      return Promise.resolve(true);
    }
    return new Promise((resolve) => {
      this._checkStatus().then(() => {
        resolve(this.online);
      });
    });
  }
  async _checkStatus() {
    return (0, import_obsidian23.requestUrl)({ url: this.url, method: "HEAD" }).then((response) => {
      if (response.status === 200 && !this.online) {
        this.log("back online");
        this.online = true;
        this.onOnline.forEach((callback) => callback());
        this._onceOnline.forEach((callback) => callback());
        this._onceOnline.clear();
        return;
      } else if (response.status !== 200 && this.online) {
        throw new Error("disconnected");
      }
    }).catch((error) => {
      if (error.message.includes("ERR_NETWORK_CHANGED")) {
        this._checkStatus();
        return;
      }
      this.online = false;
      this.onOffline.forEach((callback) => callback());
    });
  }
  onceOnline(callback) {
    this._onceOnline.add(callback);
  }
  addEventListener(eventType, callback) {
    if (eventType === "online") {
      this.onOnline.push(callback);
    } else if (eventType === "offline") {
      this.onOffline.push(callback);
    }
  }
};
var NetworkStatus_default = NetworkStatus;

// src/Exceptions.ts
var ObsidianLiveException = class extends Error {
  constructor(message) {
    super(message);
    this.name = "[System3] Relay Error";
  }
};

// src/obsidian-api/FileManager.ts
var FileManagerFacade = class {
  constructor(app) {
    this.app = app;
  }
  renameFile(file, newName) {
    return this.app.fileManager.renameFile(file, newName);
  }
};

// src/observable/ObservableMap.ts
var ObservableMap = class extends Observable3 {
  constructor(observableName) {
    super();
    this.observableName = observableName;
    this._map = /* @__PURE__ */ new Map();
    this._derivedMaps = /* @__PURE__ */ new WeakMap();
  }
  set(key, value) {
    this._map.set(key, value);
    this.notifyListeners();
    return this;
  }
  delete(key) {
    const result = this._map.delete(key);
    if (result) {
      this.notifyListeners();
    }
    return result;
  }
  clear() {
    this._map.clear();
    this.notifyListeners();
  }
  has(key) {
    return this._map.has(key);
  }
  get(key) {
    return this._map.get(key);
  }
  keys() {
    return [...this._map.keys()];
  }
  values() {
    return [...this._map.values()];
  }
  entries() {
    return [...this._map.entries()];
  }
  get size() {
    return this._map.size;
  }
  forEach(callbackfn) {
    this._map.forEach(callbackfn);
  }
  find(predicate) {
    for (const [key, value] of this._map) {
      if (predicate(value, key)) {
        return value;
      }
    }
    return void 0;
  }
  some(predicate) {
    for (const [key, value] of this._map) {
      if (predicate(value, key)) {
        return true;
      }
    }
    return false;
  }
  filter(predicate) {
    const existing = this._derivedMaps.get(predicate);
    if (existing) {
      return existing;
    }
    const derivedMap = new DerivedMap(this, predicate);
    this._derivedMaps.set(predicate, derivedMap);
    return derivedMap;
  }
};
var DerivedMap = class extends ObservableMap {
  constructor(parentMap, predicate) {
    super();
    this.parentMap = parentMap;
    this.predicate = predicate;
    this.sub();
    this.observableName = parentMap.observableName + "(filter: " + predicate.toString() + ")";
  }
  sub() {
    if (this.unsub) {
      return;
    }
    this.unsub = this.parentMap.subscribe(() => {
      const newMap = /* @__PURE__ */ new Map();
      this.parentMap.forEach((value, key) => {
        if (this.predicate(value, key)) {
          newMap.set(key, value);
        }
      });
      this._map = newMap;
      this.notifyListeners();
    });
  }
  subscribe(run2) {
    this.sub();
    super.subscribe(run2);
    return () => {
      this.unsubscribe(run2);
    };
  }
  unsubscribe(run2) {
    super.unsubscribe(run2);
    if ([...this._listeners.values()].length === 0 && this.unsub) {
      this.unsub();
      this.unsub = void 0;
    }
  }
  destroy() {
    if (this.unsub) {
      this.unsub();
    }
  }
};

// src/RelayManager.ts
function hasId(obj) {
  return typeof obj.id === "string";
}
function hasName(obj) {
  return typeof obj.name === "string";
}
var RoleCollection = class {
  constructor(roles) {
    this.collectionName = "roles";
    this.roles = roles;
  }
  items() {
    return this.roles.values();
  }
  clear() {
    this.roles.clear();
  }
  get(id2) {
    return this.roles.get(id2);
  }
  ingest(update2) {
    this.roles.set(update2.id, update2);
    return update2;
  }
  delete(id2) {
    this.roles.delete(id2);
  }
};
function hasRoot(obj) {
  return typeof obj.aggregate_root === "object";
}
function hasACL(obj) {
  return typeof obj.acl === "object";
}
var Auto = class {
  get aggregate_root() {
    return;
  }
  get acl() {
    return;
  }
};
var RelayUserAuto = class extends Auto {
  constructor(user) {
    super();
    this.user = user;
  }
  get id() {
    return this.user.id;
  }
  get name() {
    return this.user.name;
  }
  update(update2) {
    this.user = update2;
    return this;
  }
};
var RemoteFolderAuto = class extends Auto {
  constructor(remoteFolder, relays, users) {
    super();
    this.remoteFolder = remoteFolder;
    this.relays = relays;
    this.users = users;
  }
  update(update2) {
    this.remoteFolder = update2;
    return this;
  }
  get id() {
    return this.remoteFolder.id;
  }
  get guid() {
    return this.remoteFolder.guid;
  }
  get name() {
    return this.remoteFolder.name;
  }
  get private() {
    return this.remoteFolder.private;
  }
  get creator() {
    const user = this.users.get(this.remoteFolder.creator);
    if (!user) {
      throw new Error("invalid remote folder");
    }
    return user;
  }
  get relay() {
    const relay = this.relays.get(this.remoteFolder.relay);
    if (!relay) {
      throw new Error("invalid remote folder");
    }
    return relay;
  }
  get aggregate_root() {
    return ["relays", this.remoteFolder.relay];
  }
  get acl() {
    return ["relays", this.remoteFolder.relay];
  }
};
var RemoteFolderCollection = class {
  constructor(remoteFolders, relays, users) {
    this.remoteFolders = remoteFolders;
    this.relays = relays;
    this.users = users;
    this.collectionName = "shared_folders";
  }
  items() {
    return this.remoteFolders.values();
  }
  clear() {
    this.remoteFolders.clear();
  }
  get(id2) {
    return this.remoteFolders.get(id2);
  }
  ingest(update2) {
    const existingFolder = this.remoteFolders.get(update2.id);
    if (existingFolder) {
      existingFolder.update(update2);
      this.remoteFolders.notifyListeners();
      return existingFolder;
    }
    const folder = new RemoteFolderAuto(update2, this.relays, this.users);
    this.remoteFolders.set(update2.id, folder);
    return folder;
  }
  delete(id2) {
    this.remoteFolders.delete(id2);
  }
};
var RelayCollection = class {
  constructor(relays, roles, relayRoles, relayInvitations, remoteFolders, subscriptions, user) {
    this.relays = relays;
    this.roles = roles;
    this.relayRoles = relayRoles;
    this.relayInvitations = relayInvitations;
    this.remoteFolders = remoteFolders;
    this.subscriptions = subscriptions;
    this.user = user;
    this.collectionName = "relays";
  }
  items() {
    return this.relays.values();
  }
  clear() {
    this.relays.clear();
  }
  get(id2) {
    return this.relays.get(id2);
  }
  ingest(update2) {
    const existingRelay = this.relays.get(update2.id);
    if (existingRelay) {
      existingRelay.update(update2);
      this.relays.notifyListeners();
      return existingRelay;
    }
    const relay = new RelayAuto(
      update2,
      this.relayRoles,
      this.relayInvitations,
      this.remoteFolders,
      this.subscriptions,
      this.user
    );
    this.relays.set(relay.id, relay);
    return relay;
  }
  delete(id2) {
    this.relays.delete(id2);
  }
};
var RelayRolesCollection = class {
  constructor(relayRoles, relays, users, roles) {
    this.collectionName = "relay_roles";
    this.relayRoles = relayRoles;
    this.relays = relays;
    this.users = users;
    this.roles = roles;
  }
  items() {
    return this.relayRoles.values();
  }
  clear() {
    this.relayRoles.clear();
  }
  get(id2) {
    return this.relayRoles.get(id2);
  }
  ingest(update2) {
    const existingRole = this.relayRoles.get(update2.id);
    if (existingRole) {
      existingRole.update(update2);
      this.relayRoles.notifyListeners();
      return existingRole;
    }
    const role = new RelayRoleAuto(
      update2,
      this.relays,
      this.users,
      this.roles
    );
    this.relayRoles.set(role.id, role);
    return role;
  }
  delete(id2) {
    const relayRole = this.relayRoles.get(id2);
    if (!relayRole) {
      return;
    }
    this.relayRoles.delete(id2);
  }
};
var RelayInvitationsCollection = class {
  constructor(relayInvitations, relays, roles) {
    this.collectionName = "relay_invitations";
    this.relayInvitations = relayInvitations;
    this.relays = relays;
    this.roles = roles;
  }
  items() {
    return this.relayInvitations.values();
  }
  clear() {
    this.relayInvitations.clear();
  }
  get(id2) {
    return this.relayInvitations.get(id2);
  }
  ingest(update2) {
    const existingInvitation = this.relayInvitations.get(update2.id);
    if (existingInvitation) {
      existingInvitation.update(update2);
      this.relayInvitations.notifyListeners();
      return existingInvitation;
    }
    const invitation = new RelayInvitationAuto(
      update2,
      this.relays,
      this.roles
    );
    this.relayInvitations.set(invitation.id, invitation);
    return invitation;
  }
  delete(id2) {
    this.relayInvitations.delete(id2);
  }
};
var UserCollection = class {
  constructor(users) {
    this.users = users;
    this.collectionName = "users";
  }
  items() {
    return this.users.values();
  }
  clear() {
    this.users.clear();
  }
  get(id2) {
    return this.users.get(id2);
  }
  ingest(update2) {
    const existingUser = this.users.get(update2.id);
    if (existingUser) {
      existingUser.update(update2);
      this.users.notifyListeners();
      return existingUser;
    }
    const user = new RelayUserAuto(update2);
    this.users.set(update2.id, user);
    return user;
  }
  delete(id2) {
    this.users.delete(id2);
  }
};
var RelaySubscriptionCollection = class {
  constructor(subscriptions, relays, users) {
    this.subscriptions = subscriptions;
    this.relays = relays;
    this.users = users;
    this.collectionName = "subscriptions";
  }
  items() {
    return this.subscriptions.values();
  }
  clear() {
    this.subscriptions.clear();
  }
  get(id2) {
    return this.subscriptions.get(id2);
  }
  ingest(update2) {
    const existingsubscription = this.subscriptions.get(update2.id);
    if (existingsubscription) {
      existingsubscription.update(update2);
      this.subscriptions.notifyListeners();
      return existingsubscription;
    }
    const subscription = new RelaySubscriptionAuto(
      update2,
      this.relays,
      this.users
    );
    this.subscriptions.set(update2.id, subscription);
    return subscription;
  }
  delete(id2) {
    this.subscriptions.delete(id2);
  }
};
var Store = class {
  constructor(collections) {
    this.collections = /* @__PURE__ */ new Map();
    this.relationships = /* @__PURE__ */ new Map();
    for (const collection of collections) {
      this.collections.set(collection.collectionName, collection);
    }
    this.error = curryLog("[Store]", "error");
    this.warn = curryLog("[Store]", "warn");
    this.warn("instance", this);
  }
  getCollection(collecitonName) {
    const collection = this.collections.get(collecitonName);
    if (!collection) {
      this.error("No collection found for", collecitonName);
      throw new Error("No collection found for " + collecitonName);
    }
    return collection;
  }
  clear() {
    const postie = PostOffice.getInstance();
    postie.beginTransaction();
    this.collections.forEach((collection) => {
      collection.clear();
    });
    this.collections.clear();
    this.relationships.clear();
    postie.commitTransaction();
  }
  ingestPage(result) {
    return this.ingestBatch(result == null ? void 0 : result.items);
  }
  ingestBatch(records) {
    if (!records) {
      return;
    }
    return records.map((record) => {
      return this.ingest(record);
    });
  }
  ingest(record) {
    const postie = PostOffice.getInstance();
    postie.beginTransaction();
    const result = this._ingest(record);
    postie.commitTransaction();
    return result;
  }
  _ingest(record) {
    if (!record) {
      return;
    }
    let result;
    const collection = this.collections.get(record.collectionName);
    if (collection) {
      result = collection.ingest(record);
    } else {
      this.error("No collection found for record", record);
    }
    if (hasRoot(result)) {
      const aggregate_root = result.aggregate_root;
      if (aggregate_root) {
        const pointer = record.id;
        const refs = this.relationships.get(aggregate_root.join(":")) || /* @__PURE__ */ new Set();
        refs.add([record.collectionName, pointer].join(":"));
        this.relationships.set(aggregate_root.join(":"), refs);
      }
    }
    if (hasACL(result)) {
      const acl = result.acl;
      if (acl) {
        const pointer = record.id;
        const refs = this.relationships.get(acl.join(":")) || /* @__PURE__ */ new Set();
        refs.add([record.collectionName, pointer].join(":"));
        this.relationships.set(acl.join(":"), refs);
      }
    }
    if (record.expand) {
      for (const [, value] of Object.entries(record.expand)) {
        if (Array.isArray(value)) {
          this.ingestBatch(value);
        } else {
          this.ingest(value);
        }
      }
    }
    return result;
  }
  delete(record) {
    this.cascade(record.collectionName, record.id);
  }
  graphviz() {
    let dot = "digraph G {\n";
    for (const [collectionName, collection] of this.collections) {
      for (const record of collection.items()) {
        if (!hasId(record)) {
          this.warn("record has no id", record);
          continue;
        }
        let name = collectionName + "_" + record.id;
        if (hasName(record)) {
          name = collectionName + "_" + record.name;
        }
        dot += `  ${collectionName}_${record.id} [label="${name}"];
`;
        if (hasId(record) && hasRoot(record)) {
          if (record.aggregate_root) {
            const [rootCollection, rootId] = record.aggregate_root;
            dot += `  ${collectionName}_${record.id} -> ${rootCollection}_${rootId};
`;
          }
        }
        if (hasId(record) && hasACL(record)) {
          if (record.acl) {
            const [aclCollection, aclId] = record.acl;
            dot += `  ${collectionName}_${record.id} -> ${aclCollection}_${aclId} [style=dotted];
`;
          }
        }
      }
    }
    dot += "}";
    return dot;
  }
  cascade(collectionName, id2) {
    const collection = this.collections.get(collectionName);
    const children2 = this.relationships.get([collectionName, id2].join(":"));
    const postie = PostOffice.getInstance();
    postie.beginTransaction();
    if (collection) {
      this.warn("cascade delete parent", collectionName, id2);
      collection.delete(id2);
    }
    this.relationships.delete([collectionName, id2].join(":"));
    for (const fqid of children2 || []) {
      const [childCollection, childId] = fqid.split(":");
      this.warn("cascade delete child", childCollection, childId);
      const collection2 = this.getCollection(childCollection);
      if (collection2) {
        this.cascade(childCollection, childId);
      }
    }
    postie.commitTransaction();
  }
};
var RelayRoleAuto = class extends Auto {
  constructor(relayRole, relays, users, roles) {
    super();
    this.users = users;
    this.roles = roles;
    this.relays = relays;
    this.relayRole = relayRole;
  }
  update(relayRole) {
    this.relayRole = relayRole;
    return this;
  }
  get id() {
    return this.relayRole.id;
  }
  get userId() {
    return this.relayRole.user;
  }
  get user() {
    const user = this.users.get(this.relayRole.user);
    if (!user) {
      throw new Error(`Unable to find user: ${this.relayRole.user}`);
    }
    return user;
  }
  get role() {
    var _a2;
    return (_a2 = this.roles.get(this.relayRole.role)) == null ? void 0 : _a2.name;
  }
  get relayId() {
    return this.relayRole.relay;
  }
  get relay() {
    const relay = this.relays.get(this.relayRole.relay);
    if (!relay) {
      throw new Error("invalid role");
    }
    return relay;
  }
  get aggregate_root() {
    return ["relays", this.relayRole.relay];
  }
  get acl() {
    return ["users", this.relayRole.user];
  }
};
var RelayInvitationAuto = class {
  constructor(relayInvitation, relays, roles) {
    this.relayInvitation = relayInvitation;
    this.roles = roles;
    this.relays = relays;
  }
  update(relayInvitation) {
    this.relayInvitation = relayInvitation;
    return this;
  }
  get key() {
    return this.relayInvitation.key;
  }
  get id() {
    return this.relayInvitation.id;
  }
  get role() {
    var _a2;
    return (_a2 = this.roles.get(this.relayInvitation.role)) == null ? void 0 : _a2.name;
  }
  get relayId() {
    return this.relayInvitation.relay;
  }
  get relay() {
    const relay = this.relays.get(this.relayInvitation.relay);
    if (!relay) {
      throw new Error("invalid invitation");
    }
    return relay;
  }
  get aggregate_root() {
    return ["relays", this.relayInvitation.relay];
  }
};
var RelaySubscriptionAuto = class extends Observable3 {
  constructor(subscription, relays, users) {
    super();
    this.subscription = subscription;
    this.relays = relays;
    this.users = users;
  }
  update(subscription) {
    this.subscription = subscription;
    this.notifyListeners();
    return this;
  }
  get id() {
    return this.subscription.id;
  }
  get token() {
    return this.subscription.token;
  }
  get active() {
    return this.subscription.active;
  }
  get user() {
    const user = this.users.get(this.subscription.user);
    if (!user) {
      throw new Error("invalid subscription");
    }
    return user;
  }
  get relayId() {
    return this.subscription.relay;
  }
  get relay() {
    const relay = this.relays.get(this.subscription.relay);
    if (!relay) {
      throw new Error("invalid subscription");
    }
    return relay;
  }
  get stripe_cancel_at() {
    return this.subscription.stripe_cancel_at;
  }
  get cancel_at() {
    return this.subscription.stripe_cancel_at !== 0 ? new Date(this.subscription.stripe_cancel_at * 1e3) : null;
  }
  get quantity() {
    return this.subscription.stripe_quantity;
  }
  get aggregate_root() {
    return ["relays", this.subscription.relay];
  }
  get acl() {
    return ["users", this.subscription.user];
  }
};
var RelayAuto = class extends Observable3 {
  constructor(relay, relayRoles, relayInvitations, remoteFolders, _subscriptions, user) {
    super();
    this.relay = relay;
    this.relayRoles = relayRoles;
    this.relayInvitations = relayInvitations;
    this.remoteFolders = remoteFolders;
    this._subscriptions = _subscriptions;
    this.user = user;
    this.log = curryLog("[RelayAuto]", "log");
    this.warn = curryLog("[RelayAuto]", "warn");
  }
  update(update2) {
    this.relay = update2;
    this.notifyListeners();
    return this;
  }
  get cta() {
    return this.relay.cta;
  }
  get plan() {
    return this.relay.plan;
  }
  get id() {
    return this.relay.id;
  }
  get guid() {
    return this.relay.guid;
  }
  get name() {
    return this.relay.name;
  }
  set name(value) {
    this.relay.name = value;
  }
  get user_limit() {
    return this.relay.user_limit;
  }
  get role() {
    var _a2;
    const isCreator = this.relay.creator === this.user.id;
    const role = (_a2 = this.relayRoles.find(
      (role2) => {
        var _a3;
        return ((_a3 = role2.relay) == null ? void 0 : _a3.id) === this.relay.id && role2.user.id === this.user.id;
      }
    )) == null ? void 0 : _a2.role;
    if (role) {
      return role;
    }
    this.warn("couldn't find role", this.relay.id, this.user, isCreator);
    return isCreator ? "Owner" : "Member";
  }
  get owner() {
    return this.role === "Owner";
  }
  get invitation() {
    return this.relayInvitations.find(
      (invite) => invite.relay.id === this.relay.id
    );
  }
  get folders() {
    return this.remoteFolders.filter(
      (folder) => folder.relay.id === this.id
    );
  }
  get subscriptions() {
    return this._subscriptions.filter(
      (subscription) => subscription.relay.id === this.id
    );
  }
  get acl() {
    var _a2;
    const id2 = (_a2 = this.relayRoles.find((role) => {
      return role.relay.id === this.id && role.user.id === this.user.id;
    })) == null ? void 0 : _a2.id;
    if (id2) {
      return ["relay_roles", id2];
    }
  }
};
var RelayManager = class {
  constructor(loginManager) {
    this.loginManager = loginManager;
    this.log = curryLog("[RelayManager]", "log");
    this.warn = curryLog("[RelayManager]", "warn");
    this.pb = this.loginManager.pb;
    this.users = new ObservableMap("users");
    this.relays = new ObservableMap("relays");
    this.remoteFolders = new ObservableMap(
      "remote folders"
    );
    this.relayInvitations = new ObservableMap(
      "relay invitations"
    );
    this.relayRoles = new ObservableMap("relay roles");
    this.roles = new ObservableMap("roles");
    this.roles.set("2arnubkcv7jpce8", {
      name: "Owner",
      id: "2arnubkcv7jpce8"
    });
    this.roles.set("x6lllh2qsf9lxk6", {
      name: "Member",
      id: "x6lllh2qsf9lxk6"
    });
    this.subscriptions = new ObservableMap(
      "subscriptions"
    );
    this._offLoginManager = this.loginManager.subscribe(() => {
      this.login();
    });
    this.setUser();
    if (!this.user) {
      return;
    }
    this.buildGraph();
    this.subscribe();
    this.update();
  }
  buildGraph() {
    if (!this.user) {
      return;
    }
    if (this.store) {
      return;
    }
    const roleCollection = new RoleCollection(this.roles);
    const userCollection = new UserCollection(this.users);
    const relayCollection = new RelayCollection(
      this.relays,
      this.roles,
      this.relayRoles,
      this.relayInvitations,
      this.remoteFolders,
      this.subscriptions,
      this.user
    );
    const relayRolesCollection = new RelayRolesCollection(
      this.relayRoles,
      this.relays,
      this.users,
      this.roles
    );
    const relayInvitationsCollection = new RelayInvitationsCollection(
      this.relayInvitations,
      this.relays,
      this.roles
    );
    const sharedFolderCollection = new RemoteFolderCollection(
      this.remoteFolders,
      this.relays,
      this.users
    );
    const subscriptionCollection = new RelaySubscriptionCollection(
      this.subscriptions,
      this.relays,
      this.users
    );
    this.store = new Store([
      roleCollection,
      userCollection,
      relayCollection,
      relayRolesCollection,
      relayInvitationsCollection,
      sharedFolderCollection,
      subscriptionCollection
    ]);
  }
  setUser() {
    this.authUser = this.pb.authStore.model;
    if (this.authUser) {
      this.user = new RelayUserAuto(this.authUser);
      this.users.set(this.user.id, this.user);
    }
  }
  login() {
    this.setUser();
    this.buildGraph();
    this.subscribe();
    this.update();
  }
  logout() {
    var _a2;
    (_a2 = this.store) == null ? void 0 : _a2.clear();
    this.user = void 0;
    this.store = void 0;
  }
  async getRelayInvitationKey(relay) {
    const relayInvitation = this.relayInvitations.find((invite) => {
      return invite.relay.id === relay.id;
    });
    if (relayInvitation == null ? void 0 : relayInvitation.key) {
      return relayInvitation.key;
    }
    return this.pb.collection("relay_invitations").getList(0, 200).then((invitations) => {
      invitations.items.forEach((invite2) => {
        var _a2;
        (_a2 = this.store) == null ? void 0 : _a2.ingest(invite2);
      });
      const invite = this.relayInvitations.find((invite2) => {
        return invite2.relay.id === relay.id;
      });
      if (invite) {
        return invite.key;
      }
      return "";
    });
  }
  async subscribe() {
    var _a2;
    if (!this.pb.authStore.isValid || ((_a2 = this.pb.authStore.model) == null ? void 0 : _a2.id) === void 0) {
      return;
    }
    const collections = [
      {
        name: "relays",
        expand: [
          "relay_invitations_via_relay",
          "shared_folders_via_relay",
          "shared_folders_via_relay.creator",
          "subscriptions_via_relay",
          "subscriptions_via_relay.relay",
          "creator"
        ]
      },
      { name: "relay_invitations", expand: ["relay"] },
      { name: "relay_roles", expand: ["user", "relay"] },
      { name: "shared_folders", expand: ["relay", "creator"] },
      { name: "subscriptions", expand: ["user", "relay"] }
    ];
    const handleEvent = (collectionName, e2) => {
      var _a3, _b2;
      this.log(`[Event]: ${collectionName}`, e2.action, e2.record);
      if (e2.action === "delete") {
        (_a3 = this.store) == null ? void 0 : _a3.delete(e2.record);
      } else {
        (_b2 = this.store) == null ? void 0 : _b2.ingest(e2.record);
      }
    };
    for (const collection of collections) {
      this.pb.collection(collection.name).subscribe("*", (e2) => handleEvent(collection.name, e2), {
        expand: collection.expand.join(","),
        fetch: customFetch
      });
    }
  }
  async update() {
    var _a2;
    if (!this.pb.authStore.isValid || ((_a2 = this.pb.authStore.model) == null ? void 0 : _a2.id) === void 0) {
      return;
    }
    await this.pb.collection("users").getOne(this.pb.authStore.model.id, {
      expand: "relay_roles_via_user,relay_roles_via_user.relay,relay_roles_via_user.role,subscriptions_via_user,subscriptions_via_user.relay"
    }).then((user) => {
      var _a3;
      (_a3 = this.store) == null ? void 0 : _a3.ingest(user);
    }).catch((e2) => {
      if (e2.status === 404) {
        this.loginManager.logout();
      }
    });
    await this.pb.collection("relay_roles").getFullList({
      expand: "user"
    }).then((roles) => {
      roles.forEach((record) => {
        var _a3;
        (_a3 = this.store) == null ? void 0 : _a3.ingest(record);
      });
    });
    await this.pb.collection("relay_invitations").getFullList().then((relayInvitations) => {
      relayInvitations.forEach((record) => {
        var _a3;
        (_a3 = this.store) == null ? void 0 : _a3.ingest(record);
      });
    });
    await this.pb.collection("shared_folders").getFullList({
      expand: "relay,creator"
    }).then((remoteFolders) => {
      remoteFolders.forEach((record) => {
        var _a3;
        (_a3 = this.store) == null ? void 0 : _a3.ingest(record);
      });
    });
    await this.pb.collection("subscriptions").getFullList({
      expand: "relay,user",
      fetch: customFetch
    }).then((subscriptions) => {
      subscriptions.forEach((record) => {
        var _a3;
        (_a3 = this.store) == null ? void 0 : _a3.ingest(record);
      });
    });
  }
  async acceptInvitation(shareKey) {
    var _a2;
    const response = await this.pb.send("/api/accept-invitation", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        key: shareKey
      })
    });
    this.log("[InviteAccept]", response);
    const relay = (_a2 = this.store) == null ? void 0 : _a2.ingest(response);
    if (!relay) {
      throw new Error("Failed to accept invitation");
    }
    return relay;
  }
  async createRelay(name) {
    const guid = v4_default();
    const record = await this.pb.collection("relays").create({
      guid,
      name,
      path: null
    });
    if (!this.user) {
      throw new Error("Not Logged In");
    }
    const relay = new RelayAuto(
      record,
      this.relayRoles,
      this.relayInvitations,
      this.remoteFolders,
      this.subscriptions,
      this.user
    );
    this.relays.set(relay.id, relay);
    return relay;
  }
  async updateRelay(relay) {
    var _a2;
    const record = await this.pb.collection("relays").update(relay.id, {
      name: relay.name.trim()
    });
    const updated = (_a2 = this.store) == null ? void 0 : _a2.ingest(record);
    if (!updated) {
      throw new Error("Failed to update relay");
    }
    return updated;
  }
  async deleteRemote(folder) {
    folder.remote = void 0;
    const remote = this.remoteFolders.find(
      (remote2) => remote2.guid === folder.guid
    );
    if (!remote) {
      return false;
    }
    await this.pb.collection("shared_folders").delete(remote.id);
    folder.remote = void 0;
    return true;
  }
  async createRemoteFolder(sharedFolder, relay) {
    var _a2, _b2;
    const record = await this.pb.collection("shared_folders").create(
      {
        name: sharedFolder.name,
        guid: sharedFolder.guid,
        relay: relay.id,
        creator: (_a2 = this.user) == null ? void 0 : _a2.id,
        private: false
      },
      { expand: "relay" }
    );
    const folder = (_b2 = this.store) == null ? void 0 : _b2.ingest(record);
    if (!folder) {
      throw new Error("Failed to create folder");
    }
    return folder;
  }
  async destroyRelay(relay) {
    var _a2;
    await this.pb.collection("relays").delete(relay.id);
    (_a2 = this.store) == null ? void 0 : _a2.cascade("relays", relay.id);
    return true;
  }
  async leaveRelay(relay) {
    var _a2;
    const role = this.relayRoles.find((role2) => {
      var _a3, _b2;
      return role2.user.id === ((_a3 = this.user) == null ? void 0 : _a3.id) && ((_b2 = role2.relay) == null ? void 0 : _b2.id) === relay.id;
    });
    if (role) {
      await this.pb.collection("relay_roles").delete(role.id);
    } else {
      this.warn("No role found to leave relay");
    }
    (_a2 = this.store) == null ? void 0 : _a2.cascade("relay", relay.id);
  }
  async kick(relay_role) {
    return this.pb.collection("relay_roles").delete(relay_role.id);
  }
  destroy() {
    if (this._offLoginManager) {
      this._offLoginManager();
    }
  }
};

// src/TimeProvider.ts
var DefaultTimeProvider = class {
  constructor() {
    this.all = [];
  }
  getTime() {
    return Date.now();
  }
  setInterval(callback, ms) {
    const timer = window.setInterval(callback, ms);
    this.all.push(timer);
    return timer;
  }
  clearInterval(timerId) {
    window.clearInterval(timerId);
  }
  destroy() {
    for (const timer of this.all) {
      this.clearInterval(timer);
    }
    this.all = [];
  }
};

// src/main.ts
var DEFAULT_SETTINGS = {
  sharedFolders: [],
  showDocumentStatus: false,
  debugging: false
};
var Live = class extends import_obsidian24.Plugin {
  constructor() {
    super(...arguments);
    this.settingsFileLocked = true;
  }
  enableDebugging(save) {
    setDebugging(true);
    if (save) {
      this.settings.debugging = false;
      this.saveSettings();
    }
  }
  disableDebugging(save) {
    setDebugging(false);
    if (save) {
      this.settings.debugging = false;
      this.saveSettings();
    }
  }
  toggleDebugging(save) {
    const setTo = !this.settings.debugging;
    setDebugging(setTo);
    if (save) {
      this.settings.debugging = setTo;
      this.saveSettings();
    }
    return setTo;
  }
  buildApiUrl(path2) {
    return "https://api.system3.md" + path2;
  }
  async onload() {
    await this.loadSettings();
    if (this.settings.debugging) {
      this.enableDebugging();
    }
    this.log = curryLog("[System 3][Relay]", "log");
    this.warn = curryLog("[System 3][Relay]", "warn");
    this.vault = new VaultFacade(this.app);
    const vaultName = this.vault.getName();
    this.fileManager = new FileManagerFacade(this.app);
    this.timeProvider = new DefaultTimeProvider();
    this.register(() => {
      this.timeProvider.destroy();
    });
    this.loginManager = new LoginManager(this.openSettings.bind(this));
    this.relayManager = new RelayManager(this.loginManager);
    this.sharedFolders = new SharedFolders(
      this.relayManager,
      this._createSharedFolder.bind(this)
    );
    this.tokenStore = new LiveTokenStore(
      this.loginManager,
      this.timeProvider,
      vaultName,
      3
    );
    this.networkStatus = new NetworkStatus_default("https://api.system3.md/health?version=0.2.13");
    if (!this.loginManager.setup()) {
      new import_obsidian24.Notice("Please sign in to use relay");
    }
    this.app.workspace.onLayoutReady(async () => {
      await this.loadSharedFolders(this.settings.sharedFolders);
      const workspace = new WorkspaceFacade(this.app.workspace);
      this._liveViews = new LiveViewManager2(
        workspace,
        this.sharedFolders,
        this.loginManager,
        this.networkStatus
      );
      this.registerEditorExtension(this._liveViews.extensions);
      this.register(
        this.loginManager.on(() => {
          if (this.loginManager.loggedIn) {
            this._onLogin();
          } else {
            this._onLogout();
          }
        })
      );
      this.tokenStore.start();
      if (!import_obsidian25.Platform.isIosApp) {
        this.networkStatus.addEventListener("offline", () => {
          this.tokenStore.stop();
          this.sharedFolders.forEach((folder) => folder.disconnect());
          this._liveViews.goOffline();
        });
        this.networkStatus.addEventListener("online", () => {
          this.tokenStore.start();
          this.relayManager.subscribe();
          this.relayManager.update();
          this._liveViews.goOnline();
        });
        this.networkStatus.start();
      }
      this.setup();
      this.settingsFileLocked = false;
      this._liveViews.refresh("init");
    });
  }
  loadSharedFolders(sharedFolderSettings) {
    this.log("Loading shared folders");
    const beforeLock = this.settingsFileLocked;
    this.settingsFileLocked = true;
    let updated = false;
    sharedFolderSettings.forEach(
      (sharedFolderSetting) => {
        const tFolder = this.vault.getFolderByPath(
          sharedFolderSetting.path
        );
        if (!tFolder) {
          this.warn(
            `[System 3][Relay][Shared Folder]: Invalid settings, ${sharedFolderSetting.path} does not exist`
          );
          return;
        }
        this.sharedFolders._new(
          sharedFolderSetting.path,
          sharedFolderSetting.guid,
          sharedFolderSetting == null ? void 0 : sharedFolderSetting.relay
        );
        updated = true;
      }
    );
    if (!this._offSaveSettings) {
      this._offSaveSettings = this.sharedFolders.subscribe(() => {
        this.saveSettings();
      });
    }
    this.settingsFileLocked = beforeLock;
    if (updated) {
      this.sharedFolders.notifyListeners();
    }
  }
  async _createSharedFolder(path2, guid, relayId, awaitingUpdates) {
    const folder = new SharedFolder(
      guid,
      path2,
      this.loginManager,
      this.vault,
      this.fileManager,
      this.tokenStore,
      this.relayManager,
      relayId,
      awaitingUpdates
    );
    return folder;
  }
  _onLogout() {
    var _a2, _b2;
    (_a2 = this.tokenStore) == null ? void 0 : _a2.clear();
    (_b2 = this.relayManager) == null ? void 0 : _b2.logout();
    this._liveViews.refresh("logout");
  }
  _onLogin() {
    var _a2;
    this.loadSharedFolders(this.settings.sharedFolders);
    (_a2 = this.relayManager) == null ? void 0 : _a2.login();
    this._liveViews.refresh("login");
  }
  async openSettings() {
    const setting = this.app.setting;
    await setting.open();
    setting.openTabById("system3-relay");
  }
  setup() {
    this.folderNavDecorations = new FolderNavigationDecorations(
      this.vault,
      this.app.workspace,
      this.sharedFolders,
      this.settings.showDocumentStatus
    );
    this.folderNavDecorations.refresh();
    this.settingsTab = new LiveSettingsTab(this.app, this);
    this.addSettingTab(this.settingsTab);
    const workspaceLog = curryLog("[Live][Workspace]", "log");
    this.registerEvent(
      this.app.workspace.on("file-open", (file) => {
        workspaceLog("file-open");
        plugin._liveViews.refresh("file-open");
      })
    );
    this.registerEvent(
      this.app.workspace.on("layout-change", () => {
        workspaceLog("layout-change");
        this._liveViews.refresh("layout-change");
      })
    );
    const vaultLog = curryLog("[System 3][Relay][Vault]", "log");
    const handleErrorEvent = (event) => {
      const error = event.error;
      if (error instanceof ObsidianLiveException) {
        toast(error);
      }
    };
    const errorListener = (event) => handleErrorEvent(event);
    window.addEventListener("error", errorListener, true);
    this.register(
      () => window.removeEventListener("error", errorListener, true)
    );
    const handlePromiseRejection = (event) => {
      if (event.reason instanceof ObsidianLiveException) {
        toast(event.reason);
      }
    };
    const rejectionListener = (event) => handlePromiseRejection(event);
    window.addEventListener("unhandledrejection", rejectionListener, true);
    this.register(
      () => window.removeEventListener(
        "unhandledrejection",
        rejectionListener,
        true
      )
    );
    this.registerEvent(
      this.app.vault.on("create", (file) => {
        if (file instanceof import_obsidian24.TFolder) {
          return;
        }
        const folder = this.sharedFolders.lookup(file.path);
        if (folder) {
          folder.whenReady().then((folder2) => {
            folder2.getFile(file.path, true, true);
          });
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("delete", (file) => {
        if (file instanceof import_obsidian24.TFolder) {
          const folder2 = this.sharedFolders.find(
            (folder3) => folder3.path === file.path
          );
          if (folder2) {
            this.sharedFolders.delete(folder2);
          }
          return;
        }
        const folder = this.sharedFolders.lookup(file.path);
        if (folder) {
          vaultLog("Delete", file);
          folder.whenReady().then((folder2) => {
            folder2.deleteFile(file.path);
          });
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("rename", (file, oldPath) => {
        if (file instanceof import_obsidian24.TFolder) {
          const sharedFolder = this.sharedFolders.find((folder2) => {
            return folder2.path == oldPath;
          });
          if (sharedFolder) {
            sharedFolder.path = file.path;
            this.sharedFolders.update();
          }
          return;
        }
        const fromFolder = this.sharedFolders.lookup(oldPath);
        const toFolder = this.sharedFolders.lookup(file.path);
        const folder = fromFolder || toFolder;
        if (fromFolder && toFolder) {
          vaultLog("Rename", file, oldPath);
          fromFolder.renameFile(file.path, oldPath);
          toFolder.renameFile(file.path, oldPath);
          this._liveViews.refresh("rename");
        } else if (folder) {
          vaultLog("Rename", file, oldPath);
          folder.renameFile(file.path, oldPath);
          this._liveViews.refresh("rename");
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("modify", (file) => {
        const folder = this.sharedFolders.lookup(file.path);
        if (folder) {
          vaultLog("Modify", file);
          this.app.metadataCache.trigger("resolve", file);
        }
      })
    );
    const plugin = this;
    const patchOnUnloadFile = around(import_obsidian24.MarkdownView.prototype, {
      // When this is called, the active editors haven't yet updated.
      onUnloadFile(old) {
        return function(file) {
          plugin._liveViews.wipe();
          return old.call(this, file);
        };
      }
    });
    this.register(patchOnUnloadFile);
  }
  onunload() {
    var _a2, _b2, _c, _d, _e, _f;
    this.settingsFileLocked = true;
    if (this._offSaveSettings) {
      this._offSaveSettings();
    }
    this.sharedFolders.destroy();
    (_a2 = this.folderNavDecorations) == null ? void 0 : _a2.destroy();
    (_b2 = this.tokenStore) == null ? void 0 : _b2.stop();
    (_c = this.tokenStore) == null ? void 0 : _c.clearState();
    (_d = this.relayManager) == null ? void 0 : _d.destroy();
    (_e = this.networkStatus) == null ? void 0 : _e.stop();
    (_f = this._liveViews) == null ? void 0 : _f.destroy();
    auditTeardown();
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveSettings() {
    if (!this.settingsFileLocked) {
      this.settings.sharedFolders = this.sharedFolders.toSettings();
      this.log("Saving settings", this.settings);
      await this.saveData(this.settings);
    } else {
      this.log("Saving settings: settings file locked");
    }
  }
};
/*! Bundled license information:

moment/moment.js:
  (*! moment.js *)
  (*! version : 2.29.4 *)
  (*! authors : Tim Wood, Iskren Chernev, Moment.js contributors *)
  (*! license : MIT *)
  (*! momentjs.com *)

lucide-svelte/dist/defaultAttributes.js:
  (**
   * @license lucide-svelte v0.377.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/arrow-right-left.svelte:
  (**
   * @license lucide-svelte v0.377.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/chevron-left.svelte:
  (**
   * @license lucide-svelte v0.377.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/folder.svelte:
  (**
   * @license lucide-svelte v0.377.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/layers.svelte:
  (**
   * @license lucide-svelte v0.377.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/satellite.svelte:
  (**
   * @license lucide-svelte v0.377.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/settings.svelte:
  (**
   * @license lucide-svelte v0.377.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/index.js:
  (**
   * @license lucide-svelte v0.377.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)
*/
